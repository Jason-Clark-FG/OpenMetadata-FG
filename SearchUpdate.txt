Subject: [PATCH] Changes
---
Index: pom.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/pom.xml b/pom.xml
--- a/pom.xml	(revision d10bcccecad7a11724e8df23cf8c879f9f0673da)
+++ b/pom.xml	(date 1744005109962)
@@ -107,8 +107,8 @@
     <commons-lang.version>2.6</commons-lang.version>
     <lombok.version>1.18.34</lombok.version>
     <tomcat-jdbc.version>11.0.5</tomcat-jdbc.version>
-    <elasticsearch.version>7.17.23</elasticsearch.version>
-    <opensearch.version>2.6.0</opensearch.version>
+    <elasticsearch.version>8.17.4</elasticsearch.version>
+    <opensearch.version>2.22.0</opensearch.version>
     <httpasyncclient.version>4.1.5</httpasyncclient.version>
     <openapiswagger.version>2.2.25</openapiswagger.version>
 
@@ -345,12 +345,12 @@
       </dependency>
       <dependency>
         <groupId>org.opensearch.client</groupId>
-        <artifactId>opensearch-rest-high-level-client</artifactId>
+        <artifactId>opensearch-java</artifactId>
         <version>${opensearch.version}</version>
       </dependency>
       <dependency>
-        <groupId>org.elasticsearch.client</groupId>
-        <artifactId>elasticsearch-rest-high-level-client</artifactId>
+        <groupId>co.elastic.clients</groupId>
+        <artifactId>elasticsearch-java</artifactId>
         <version>${elasticsearch.version}</version>
       </dependency>
       <dependency>
Index: openmetadata-service/src/main/java/org/openmetadata/service/search/opensearch/OpenSearchClient.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openmetadata-service/src/main/java/org/openmetadata/service/search/opensearch/OpenSearchClient.java b/openmetadata-service/src/main/java/org/openmetadata/service/search/opensearch/OpenSearchClient.java
--- a/openmetadata-service/src/main/java/org/openmetadata/service/search/opensearch/OpenSearchClient.java	(revision d10bcccecad7a11724e8df23cf8c879f9f0673da)
+++ b/openmetadata-service/src/main/java/org/openmetadata/service/search/opensearch/OpenSearchClient.java	(date 1744005109975)
@@ -14,7 +14,6 @@
 import static org.openmetadata.service.Entity.TABLE;
 import static org.openmetadata.service.events.scheduled.ServicesStatusJobHandler.HEALTHY_STATUS;
 import static org.openmetadata.service.events.scheduled.ServicesStatusJobHandler.UNHEALTHY_STATUS;
-import static org.openmetadata.service.exception.CatalogGenericExceptionMapper.getResponse;
 import static org.openmetadata.service.search.EntityBuilderConstant.DOMAIN_DISPLAY_NAME_KEYWORD;
 import static org.openmetadata.service.search.EntityBuilderConstant.ES_TAG_FQN_FIELD;
 import static org.openmetadata.service.search.EntityBuilderConstant.FIELD_DISPLAY_NAME_NGRAM;
@@ -33,7 +32,6 @@
 import static org.openmetadata.service.search.opensearch.OpenSearchEntitiesProcessor.getUpdateRequest;
 import static org.openmetadata.service.util.FullyQualifiedName.getParentFQN;
 
-import com.fasterxml.jackson.databind.JsonNode;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -76,7 +74,7 @@
 import org.openmetadata.schema.entity.data.EntityHierarchy;
 import org.openmetadata.schema.entity.data.QueryCostSearchResult;
 import org.openmetadata.schema.entity.data.Table;
-import org.openmetadata.schema.search.SearchRequest;
+import org.openmetadata.schema.search.SearchRequestInternal;
 import org.openmetadata.schema.service.configuration.elasticsearch.ElasticSearchConfiguration;
 import org.openmetadata.schema.settings.SettingsType;
 import org.openmetadata.schema.tests.DataQualityReport;
@@ -100,6 +98,8 @@
 import org.openmetadata.service.search.SearchIndexUtils;
 import org.openmetadata.service.search.SearchResultListMapper;
 import org.openmetadata.service.search.SearchSortFilter;
+import org.openmetadata.service.search.index.OpenSearchIndexCrud;
+import org.openmetadata.service.search.index.SearchIndexCrud;
 import org.openmetadata.service.search.models.IndexMapping;
 import org.openmetadata.service.search.nlq.NLQService;
 import org.openmetadata.service.search.opensearch.aggregations.OpenAggregations;
@@ -126,34 +126,31 @@
 import org.openmetadata.service.util.FullyQualifiedName;
 import org.openmetadata.service.util.JsonUtils;
 import org.openmetadata.service.workflows.searchIndex.ReindexingUtil;
-import os.org.opensearch.OpenSearchException;
 import os.org.opensearch.OpenSearchStatusException;
 import os.org.opensearch.action.ActionListener;
-import os.org.opensearch.action.admin.cluster.health.ClusterHealthRequest;
-import os.org.opensearch.action.admin.cluster.health.ClusterHealthResponse;
-import os.org.opensearch.action.admin.indices.alias.IndicesAliasesRequest;
-import os.org.opensearch.action.admin.indices.delete.DeleteIndexRequest;
 import os.org.opensearch.action.bulk.BulkRequest;
 import os.org.opensearch.action.bulk.BulkResponse;
 import os.org.opensearch.action.delete.DeleteRequest;
-import os.org.opensearch.action.get.GetRequest;
-import os.org.opensearch.action.get.GetResponse;
 import os.org.opensearch.action.search.SearchResponse;
 import os.org.opensearch.action.support.WriteRequest;
-import os.org.opensearch.action.support.master.AcknowledgedResponse;
 import os.org.opensearch.action.update.UpdateRequest;
 import os.org.opensearch.client.RequestOptions;
 import os.org.opensearch.client.RestClient;
 import os.org.opensearch.client.RestClientBuilder;
 import os.org.opensearch.client.RestHighLevelClient;
 import os.org.opensearch.client.WarningsHandler;
-import os.org.opensearch.client.indices.CreateIndexRequest;
-import os.org.opensearch.client.indices.CreateIndexResponse;
-import os.org.opensearch.client.indices.GetIndexRequest;
 import os.org.opensearch.client.indices.GetMappingsRequest;
 import os.org.opensearch.client.indices.GetMappingsResponse;
-import os.org.opensearch.client.indices.PutMappingRequest;
-import os.org.opensearch.cluster.health.ClusterHealthStatus;
+import os.org.opensearch.client.json.JsonData;
+import os.org.opensearch.client.opensearch._types.FieldValue;
+import os.org.opensearch.client.opensearch._types.HealthStatus;
+import os.org.opensearch.client.opensearch._types.SortOrder;
+import os.org.opensearch.client.opensearch._types.aggregations.StringTermsAggregate;
+import os.org.opensearch.client.opensearch._types.query_dsl.BoolQuery;
+import os.org.opensearch.client.opensearch._types.query_dsl.QueryBuilders;
+import os.org.opensearch.client.opensearch.cluster.HealthResponse;
+import os.org.opensearch.client.opensearch.core.GetRequest;
+import os.org.opensearch.client.opensearch.core.GetResponse;
 import os.org.opensearch.cluster.metadata.MappingMetadata;
 import os.org.opensearch.common.lucene.search.function.CombineFunction;
 import os.org.opensearch.common.lucene.search.function.FieldValueFactorFunction;
@@ -190,7 +187,6 @@
 import os.org.opensearch.search.aggregations.bucket.histogram.DateHistogramAggregationBuilder;
 import os.org.opensearch.search.aggregations.bucket.histogram.DateHistogramInterval;
 import os.org.opensearch.search.aggregations.bucket.terms.IncludeExclude;
-import os.org.opensearch.search.aggregations.bucket.terms.Terms;
 import os.org.opensearch.search.aggregations.bucket.terms.TermsAggregationBuilder;
 import os.org.opensearch.search.aggregations.metrics.MaxAggregationBuilder;
 import os.org.opensearch.search.aggregations.metrics.SumAggregationBuilder;
@@ -211,11 +207,12 @@
 @Slf4j
 // Not tagged with Repository annotation as it is programmatically initialized
 public class OpenSearchClient implements SearchClient {
-  @Getter protected final RestHighLevelClient client;
+  @Getter protected final os.org.opensearch.client.opensearch.OpenSearchClient client;
   private final boolean isClientAvailable;
   private final RBACConditionEvaluator rbacConditionEvaluator;
 
   private final OSLineageGraphBuilder lineageGraphBuilder;
+  private final SearchIndexCrud indexCrud;
 
   private final String clusterAlias;
 
@@ -255,6 +252,7 @@
     QueryBuilderFactory queryBuilderFactory = new OpenSearchQueryBuilderFactory();
     rbacConditionEvaluator = new RBACConditionEvaluator(queryBuilderFactory);
     lineageGraphBuilder = new OSLineageGraphBuilder(client);
+    indexCrud = new OpenSearchIndexCrud(client, clusterAlias);
   }
 
   @Override
@@ -263,107 +261,38 @@
   }
 
   @Override
-  public boolean indexExists(String indexName) {
-    try {
-      GetIndexRequest gRequest = new GetIndexRequest(indexName);
-      gRequest.local(false);
-      return client.indices().exists(gRequest, RequestOptions.DEFAULT);
-    } catch (Exception e) {
-      LOG.error(String.format("Failed to check if index %s exists due to", indexName), e);
-      return false;
-    }
+  public boolean indexExists(IndexMapping indexMapping) {
+    indexCrud.indexExists(indexMapping);
   }
 
   @Override
   public void createIndex(IndexMapping indexMapping, String indexMappingContent) {
-    if (Boolean.TRUE.equals(isClientAvailable)) {
-      try {
-        CreateIndexRequest request =
-            new CreateIndexRequest(indexMapping.getIndexName(clusterAlias));
-        request.source(indexMappingContent, XContentType.JSON);
-        CreateIndexResponse createIndexResponse =
-            client.indices().create(request, RequestOptions.DEFAULT);
-        LOG.debug(
-            "{} Created {}",
-            indexMapping.getIndexName(clusterAlias),
-            createIndexResponse.isAcknowledged());
-        // creating alias for indexes
-        createAliases(indexMapping);
-      } catch (Exception e) {
-        LOG.error("Failed to create Open Search indexes due to", e);
-      }
-    } else {
-      LOG.error(
-          "Failed to create Open Search index as client is not property configured, Please check your OpenMetadata configuration");
-    }
+    indexCrud.createIndex(indexMapping, indexMappingContent);
   }
 
   @Override
   public void addIndexAlias(IndexMapping indexMapping, String... aliasName) {
-    try {
-      IndicesAliasesRequest.AliasActions aliasAction =
-          IndicesAliasesRequest.AliasActions.add()
-              .index(indexMapping.getIndexName(clusterAlias))
-              .aliases(aliasName);
-      IndicesAliasesRequest aliasesRequest = new IndicesAliasesRequest();
-      aliasesRequest.addAliasAction(aliasAction);
-      client.indices().updateAliases(aliasesRequest, RequestOptions.DEFAULT);
-    } catch (Exception e) {
-      LOG.error(
-          String.format(
-              "Failed to create alias for %s due to", indexMapping.getAlias(clusterAlias)),
-          e);
-    }
+    indexCrud.addIndexAlias(indexMapping, aliasName);
   }
 
   @Override
   public void createAliases(IndexMapping indexMapping) {
-    try {
-      Set<String> aliases = new HashSet<>(indexMapping.getParentAliases(clusterAlias));
-      aliases.add(indexMapping.getAlias(clusterAlias));
-      addIndexAlias(indexMapping, aliases.toArray(new String[0]));
-    } catch (Exception e) {
-      LOG.error(
-          String.format(
-              "Failed to create alias for %s due to", indexMapping.getIndexName(clusterAlias)),
-          e);
-    }
+    indexCrud.createAliases(indexMapping);
   }
 
   @Override
   public void updateIndex(IndexMapping indexMapping, String indexMappingContent) {
-    try {
-      PutMappingRequest request = new PutMappingRequest(indexMapping.getIndexName(clusterAlias));
-      JsonNode readProperties = JsonUtils.readTree(indexMappingContent).get("mappings");
-      request.source(JsonUtils.getMap(readProperties));
-      AcknowledgedResponse putMappingResponse =
-          client.indices().putMapping(request, RequestOptions.DEFAULT);
-      LOG.debug(
-          "{} Updated {}", indexMapping.getIndexMappingFile(), putMappingResponse.isAcknowledged());
-    } catch (Exception e) {
-      LOG.warn(
-          String.format(
-              "Failed to Update Open Search index %s", indexMapping.getIndexName(clusterAlias)));
-    }
+    indexCrud.updateIndex(indexMapping, indexMappingContent);
   }
 
   @Override
   public void deleteIndex(IndexMapping indexMapping) {
-    try {
-      DeleteIndexRequest request = new DeleteIndexRequest(indexMapping.getIndexName(clusterAlias));
-      AcknowledgedResponse deleteIndexResponse =
-          client.indices().delete(request, RequestOptions.DEFAULT);
-      LOG.debug(
-          "{} Deleted {}",
-          indexMapping.getIndexName(clusterAlias),
-          deleteIndexResponse.isAcknowledged());
-    } catch (Exception e) {
-      LOG.error("Failed to delete Open Search indexes due to", e);
-    }
+    indexCrud.deleteIndex(indexMapping);
   }
 
   @Override
-  public Response search(SearchRequest request, SubjectContext subjectContext) throws IOException {
+  public Response search(SearchRequestInternal request, SubjectContext subjectContext)
+      throws IOException {
     SearchSettings searchSettings =
         SettingsCache.getSetting(SettingsType.SEARCH_SETTINGS, SearchSettings.class);
     return doSearch(request, subjectContext, searchSettings);
@@ -371,13 +300,13 @@
 
   @Override
   public Response previewSearch(
-      SearchRequest request, SubjectContext subjectContext, SearchSettings searchSettings)
+      SearchRequestInternal request, SubjectContext subjectContext, SearchSettings searchSettings)
       throws IOException {
     return doSearch(request, subjectContext, searchSettings);
   }
 
   public Response doSearch(
-      SearchRequest request, SubjectContext subjectContext, SearchSettings searchSettings)
+      SearchRequestInternal request, SubjectContext subjectContext, SearchSettings searchSettings)
       throws IOException {
     OpenSearchSourceBuilderFactory searchBuilderFactory =
         new OpenSearchSourceBuilderFactory(searchSettings);
@@ -531,7 +460,7 @@
   }
 
   @Override
-  public Response searchWithNLQ(SearchRequest request, SubjectContext subjectContext)
+  public Response searchWithNLQ(SearchRequestInternal request, SubjectContext subjectContext)
       throws IOException {
     LOG.info("Searching with NLQ: {}", request.getQuery());
 
@@ -568,7 +497,8 @@
     }
   }
 
-  private Response fallbackToBasicSearch(SearchRequest request, SubjectContext subjectContext) {
+  private Response fallbackToBasicSearch(
+      SearchRequestInternal request, SubjectContext subjectContext) {
     try {
       LOG.debug("Falling back to basic query_string search for NLQ: {}", request.getQuery());
 
@@ -596,27 +526,30 @@
   @Override
   public Response getDocByID(String indexName, String entityId) throws IOException {
     try {
-      GetRequest request =
-          new GetRequest(Entity.getSearchRepository().getIndexOrAliasName(indexName), entityId);
-      GetResponse response = client.get(request, RequestOptions.DEFAULT);
+      GetRequest request = new GetRequest.Builder().index(indexName).id(entityId).build();
 
-      if (response.isExists()) {
-        return Response.status(OK).entity(response.toString()).build();
+      GetResponse<JsonData> response = client.get(request, JsonData.class);
+
+      if (response.found()) {
+        return Response.status(Response.Status.OK).entity(response.source()).build();
       }
 
-    } catch (OpenSearchException e) {
-      if (e.status() == RestStatus.NOT_FOUND) {
+    } catch (os.org.opensearch.client.opensearch._types.OpenSearchException e) {
+      if (e.status() == NOT_FOUND.getStatusCode()) {
         throw new SearchIndexNotFoundException(
-            String.format("Failed to to find doc with id %s", entityId));
+            String.format("Failed to find doc with id %s", entityId));
       } else {
         throw new SearchException(String.format("Search failed due to %s", e.getMessage()));
       }
     }
-    return getResponse(NOT_FOUND, "Document not found.");
+
+    return Response.status(Response.Status.NOT_FOUND).entity("Document not found.").build();
   }
 
   private void buildHierarchyQuery(
-      SearchRequest request, SearchSourceBuilder searchSourceBuilder, RestHighLevelClient client)
+      SearchRequestInternal request,
+      os.org.opensearch.client.opensearch.core.SearchRequest.Builder searchSourceBuilder,
+      os.org.opensearch.client.opensearch.OpenSearchClient client)
       throws IOException {
 
     if (Boolean.FALSE.equals(request.getIsHierarchy())) {
@@ -629,63 +562,109 @@
     String domainIndex =
         Entity.getSearchRepository().getIndexMapping(DOMAIN).getIndexName(clusterAlias);
 
-    BoolQueryBuilder baseQuery =
-        QueryBuilders.boolQuery()
-            .should(searchSourceBuilder.query())
-            .should(QueryBuilders.matchPhraseQuery("fullyQualifiedName", request.getQuery()))
-            .should(QueryBuilders.matchPhraseQuery("name", request.getQuery()))
-            .should(QueryBuilders.matchPhraseQuery("displayName", request.getQuery()));
+    BoolQuery.Builder baseQuery =
+        QueryBuilders.bool()
+            .should(searchSourceBuilder.build().query())
+            .should(
+                QueryBuilders.matchPhrase()
+                    .field("fullyQualifiedName")
+                    .query(request.getQuery())
+                    .build()
+                    .toQuery())
+            .should(
+                QueryBuilders.matchPhrase()
+                    .field("name")
+                    .query(request.getQuery())
+                    .build()
+                    .toQuery())
+            .should(
+                QueryBuilders.matchPhrase()
+                    .field("displayName")
+                    .query(request.getQuery())
+                    .build()
+                    .toQuery());
 
     if (indexName.equalsIgnoreCase(glossaryTermIndex)) {
       baseQuery
-          .should(QueryBuilders.matchPhraseQuery("glossary.fullyQualifiedName", request.getQuery()))
-          .should(QueryBuilders.matchPhraseQuery("glossary.displayName", request.getQuery()))
-          .must(QueryBuilders.matchQuery("status", "Approved"));
+          .should(
+              QueryBuilders.matchPhrase()
+                  .field("glossary.fullyQualifiedName")
+                  .query(request.getQuery())
+                  .build()
+                  .toQuery())
+          .should(
+              QueryBuilders.matchPhrase()
+                  .field("glossary.displayName")
+                  .query(request.getQuery())
+                  .build()
+                  .toQuery())
+          .must(q -> q.match(m -> m.field("status").query(FieldValue.of("Approved"))));
     } else if (indexName.equalsIgnoreCase(domainIndex)) {
       baseQuery
-          .should(QueryBuilders.matchPhraseQuery("parent.fullyQualifiedName", request.getQuery()))
-          .should(QueryBuilders.matchPhraseQuery("parent.displayName", request.getQuery()));
+          .should(
+              QueryBuilders.matchPhrase()
+                  .field("parent.fullyQualifiedName")
+                  .query(request.getQuery())
+                  .build()
+                  .toQuery())
+          .should(
+              QueryBuilders.matchPhrase()
+                  .field("parent.displayName")
+                  .query(request.getQuery())
+                  .build()
+                  .toQuery());
     }
 
-    baseQuery.minimumShouldMatch(1);
-    searchSourceBuilder.query(baseQuery);
+    baseQuery.minimumShouldMatch("1");
+    searchSourceBuilder.query(baseQuery.build().toQuery());
 
-    SearchResponse searchResponse =
-        client.search(
-            new os.org.opensearch.action.search.SearchRequest(request.getIndex())
-                .source(searchSourceBuilder),
-            RequestOptions.DEFAULT);
+    os.org.opensearch.client.opensearch.core.SearchResponse<JsonData> searchResponse =
+        client.search(searchSourceBuilder.index(request.getIndex()).build(), JsonData.class);
 
-    Terms parentTerms = searchResponse.getAggregations().get("fqnParts_agg");
+    StringTermsAggregate parentTerms = searchResponse.aggregations().get("fqnParts_agg").sterms();
 
     // Build  es query to get parent terms for the user input query , to build correct hierarchy
     // In case of default search , no need to get parent terms they are already present in the
     // response
     if (parentTerms != null
-        && !parentTerms.getBuckets().isEmpty()
+        && parentTerms.buckets().array() != null
+        && !parentTerms.buckets().array().isEmpty()
         && !request.getQuery().equals("*")) {
-      BoolQueryBuilder parentTermQueryBuilder = QueryBuilders.boolQuery();
 
-      parentTerms.getBuckets().stream()
-          .map(Terms.Bucket::getKeyAsString)
+      BoolQuery.Builder parentTermQueryBuilder = new BoolQuery.Builder();
+
+      parentTerms
+          .buckets()
+          .array()
           .forEach(
-              parentTerm ->
+              bucket ->
                   parentTermQueryBuilder.should(
-                      QueryBuilders.matchQuery("fullyQualifiedName", parentTerm)));
+                      q ->
+                          q.match(
+                              m ->
+                                  m.field("fullyQualifiedName")
+                                      .query(bucket.key().stringValue()))));
+
       if (indexName.equalsIgnoreCase(glossaryTermIndex)) {
-        parentTermQueryBuilder
-            .minimumShouldMatch(1)
-            .must(QueryBuilders.matchQuery("status", "Approved"));
-      } else {
-        parentTermQueryBuilder.minimumShouldMatch(1);
+        parentTermQueryBuilder.must(
+            q -> q.match(m -> m.field("status").query(FieldValue.of("Approved"))));
       }
-      searchSourceBuilder.query(parentTermQueryBuilder);
+
+      // Build a new search request with the updated query
+      os.org.opensearch.client.opensearch.core.SearchRequest updatedRequest =
+          new os.org.opensearch.client.opensearch.core.SearchRequest.Builder()
+              .index(indexName)
+              .query(q -> q.bool(parentTermQueryBuilder.build()))
+              .sort(s -> s.field(f -> f.field("fullyQualifiedName").order(SortOrder.Asc)))
+              .build();
+
+      // Perform the updated search
+      client.search(updatedRequest, JsonData.class);
     }
-
-    searchSourceBuilder.sort(SortBuilders.fieldSort("fullyQualifiedName").order(SortOrder.ASC));
   }
 
-  public List<?> buildSearchHierarchy(SearchRequest request, SearchResponse searchResponse) {
+  public List<?> buildSearchHierarchy(
+      SearchRequestInternal request, SearchResponse searchResponse) {
     List<?> response = new ArrayList<>();
     String indexName = request.getIndex();
     String glossaryTermIndex =
@@ -1518,7 +1497,7 @@
     }
   }
 
-  public Response suggest(SearchRequest request) throws IOException {
+  public Response suggest(SearchRequestInternal request) throws IOException {
     String fieldName = request.getFieldName();
     SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();
     CompletionSuggestionBuilder suggestionBuilder =
@@ -2472,10 +2451,10 @@
 
   @Override
   public SearchHealthStatus getSearchHealthStatus() throws IOException {
-    ClusterHealthRequest request = new ClusterHealthRequest();
-    ClusterHealthResponse response = client.cluster().health(request, RequestOptions.DEFAULT);
-    if (response.getStatus().equals(ClusterHealthStatus.GREEN)
-        || response.getStatus().equals(ClusterHealthStatus.YELLOW)) {
+    HealthResponse response = client.cluster().health(); // No request object needed
+    HealthStatus status = response.status();
+
+    if (status == HealthStatus.Green || status == HealthStatus.Yellow) {
       return new SearchHealthStatus(HEALTHY_STATUS);
     } else {
       return new SearchHealthStatus(UNHEALTHY_STATUS);
Index: openmetadata-service/src/main/java/org/openmetadata/service/search/aggregation/AggregationContainer.java
===================================================================
diff --git a/openmetadata-service/src/main/java/org/openmetadata/service/search/aggregation/AggregationContainer.java b/openmetadata-service/src/main/java/org/openmetadata/service/search/aggregation/AggregationContainer.java
new file mode 100644
--- /dev/null	(date 1744005109981)
+++ b/openmetadata-service/src/main/java/org/openmetadata/service/search/aggregation/AggregationContainer.java	(date 1744005109981)
@@ -0,0 +1,5 @@
+package org.openmetadata.service.search.aggregation;
+
+public interface AggregationContainer {
+  AggregationContainer getAggregation();
+}
Index: openmetadata-service/src/main/java/org/openmetadata/service/search/aggregation/OsAggregationContainer.java
===================================================================
diff --git a/openmetadata-service/src/main/java/org/openmetadata/service/search/aggregation/OsAggregationContainer.java b/openmetadata-service/src/main/java/org/openmetadata/service/search/aggregation/OsAggregationContainer.java
new file mode 100644
--- /dev/null	(date 1744005109983)
+++ b/openmetadata-service/src/main/java/org/openmetadata/service/search/aggregation/OsAggregationContainer.java	(date 1744005109983)
@@ -0,0 +1,15 @@
+package org.openmetadata.service.search.aggregation;
+
+import os.org.opensearch.client.opensearch._types.aggregations.Aggregation;
+
+public class OsAggregationContainer implements AggregationContainer {
+  private final Aggregation aggregation;
+
+  public OsAggregationContainer(Aggregation aggregation) {
+    this.aggregation = aggregation;
+  }
+
+  public AggregationContainer getAggregation() {
+    return this;
+  }
+}
Index: openmetadata-service/src/main/java/org/openmetadata/service/search/opensearch/OpenSearchSourceBuilderFactory.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openmetadata-service/src/main/java/org/openmetadata/service/search/opensearch/OpenSearchSourceBuilderFactory.java b/openmetadata-service/src/main/java/org/openmetadata/service/search/opensearch/OpenSearchSourceBuilderFactory.java
--- a/openmetadata-service/src/main/java/org/openmetadata/service/search/opensearch/OpenSearchSourceBuilderFactory.java	(revision d10bcccecad7a11724e8df23cf8c879f9f0673da)
+++ b/openmetadata-service/src/main/java/org/openmetadata/service/search/opensearch/OpenSearchSourceBuilderFactory.java	(date 1744005109978)
@@ -3,7 +3,6 @@
 import static org.openmetadata.common.utils.CommonUtil.listOrEmpty;
 import static org.openmetadata.service.search.EntityBuilderConstant.POST_TAG;
 import static org.openmetadata.service.search.EntityBuilderConstant.PRE_TAG;
-import static os.org.opensearch.index.query.MultiMatchQueryBuilder.Type.MOST_FIELDS;
 
 import java.util.ArrayList;
 import java.util.HashMap;
@@ -15,28 +14,38 @@
 import org.openmetadata.schema.api.search.FieldValueBoost;
 import org.openmetadata.schema.api.search.SearchSettings;
 import org.openmetadata.schema.api.search.TermBoost;
+import org.openmetadata.service.search.SearchContext;
 import org.openmetadata.service.search.SearchSourceBuilderFactory;
 import org.openmetadata.service.search.indexes.*;
-import os.org.opensearch.common.lucene.search.function.CombineFunction;
-import os.org.opensearch.common.lucene.search.function.FieldValueFactorFunction;
-import os.org.opensearch.common.lucene.search.function.FunctionScoreQuery;
-import os.org.opensearch.common.unit.Fuzziness;
-import os.org.opensearch.index.query.BoolQueryBuilder;
-import os.org.opensearch.index.query.MultiMatchQueryBuilder;
-import os.org.opensearch.index.query.Operator;
-import os.org.opensearch.index.query.QueryBuilder;
-import os.org.opensearch.index.query.QueryBuilders;
-import os.org.opensearch.index.query.QueryStringQueryBuilder;
-import os.org.opensearch.index.query.functionscore.FieldValueFactorFunctionBuilder;
-import os.org.opensearch.index.query.functionscore.FunctionScoreQueryBuilder;
-import os.org.opensearch.index.query.functionscore.ScoreFunctionBuilders;
-import os.org.opensearch.search.aggregations.AggregationBuilders;
-import os.org.opensearch.search.builder.SearchSourceBuilder;
-import os.org.opensearch.search.fetch.subphase.highlight.HighlightBuilder;
+import os.org.opensearch.client.json.JsonData;
+import os.org.opensearch.client.opensearch._types.FieldValue;
+import os.org.opensearch.client.opensearch._types.aggregations.AggregationBuilders;
+import os.org.opensearch.client.opensearch._types.query_dsl.BoolQuery;
+import os.org.opensearch.client.opensearch._types.query_dsl.FieldValueFactorModifier;
+import os.org.opensearch.client.opensearch._types.query_dsl.FieldValueFactorScoreFunction;
+import os.org.opensearch.client.opensearch._types.query_dsl.FunctionBoostMode;
+import os.org.opensearch.client.opensearch._types.query_dsl.FunctionScore;
+import os.org.opensearch.client.opensearch._types.query_dsl.FunctionScoreMode;
+import os.org.opensearch.client.opensearch._types.query_dsl.FunctionScoreQuery;
+import os.org.opensearch.client.opensearch._types.query_dsl.MultiMatchQuery;
+import os.org.opensearch.client.opensearch._types.query_dsl.Operator;
+import os.org.opensearch.client.opensearch._types.query_dsl.Query;
+import os.org.opensearch.client.opensearch._types.query_dsl.QueryBuilders;
+import os.org.opensearch.client.opensearch._types.query_dsl.QueryStringQuery;
+import os.org.opensearch.client.opensearch._types.query_dsl.RangeQuery;
+import os.org.opensearch.client.opensearch._types.query_dsl.TextQueryType;
+import os.org.opensearch.client.opensearch.core.SearchRequest;
+import os.org.opensearch.client.opensearch.core.search.BuiltinHighlighterType;
+import os.org.opensearch.client.opensearch.core.search.Highlight;
+import os.org.opensearch.client.opensearch.core.search.HighlightField;
+import os.org.opensearch.client.opensearch.core.search.HighlighterType;
 
 public class OpenSearchSourceBuilderFactory
     implements SearchSourceBuilderFactory<
-        SearchSourceBuilder, QueryBuilder, HighlightBuilder, FunctionScoreQueryBuilder> {
+        SearchRequest.Builder,
+        QueryStringQuery.Builder,
+        Highlight.Builder,
+        FunctionScoreQuery.Builder> {
 
   private final SearchSettings searchSettings;
 
@@ -45,23 +54,23 @@
   }
 
   @Override
-  public QueryStringQueryBuilder buildSearchQueryBuilder(String query, Map<String, Float> fields) {
-    return QueryBuilders.queryStringQuery(query)
+  public QueryStringQuery.Builder buildSearchQueryBuilder(String query, List<String> fields) {
+    return new QueryStringQuery.Builder()
         .fields(fields)
-        .type(MOST_FIELDS)
-        .defaultOperator(Operator.AND)
-        .fuzziness(Fuzziness.AUTO)
+        .type(TextQueryType.MostFields)
+        .defaultOperator(Operator.And)
+        .fuzziness("auto")
         .fuzzyPrefixLength(3)
-        .tieBreaker(0.5f);
+        .tieBreaker(0.5d);
   }
 
   @Override
-  public SearchSourceBuilder searchBuilder(
-      QueryBuilder query, HighlightBuilder highlightBuilder, int from, int size) {
-    SearchSourceBuilder builder = new SearchSourceBuilder();
-    builder.query(query);
+  public SearchContext searchBuilder(
+      QueryStringQuery.Builder query, Highlight.Builder highlightBuilder, int from, int size) {
+    SearchRequest.Builder builder = new SearchRequest.Builder();
+    builder.query(Query.of(q -> q.queryString(query.build())));
     if (highlightBuilder != null) {
-      builder.highlighter(highlightBuilder);
+      builder.highlight(highlightBuilder.build());
     }
     builder.from(from);
     builder.size(size);
@@ -69,287 +78,285 @@
   }
 
   @Override
-  public SearchSourceBuilder buildUserOrTeamSearchBuilder(String query, int from, int size) {
-    QueryStringQueryBuilder queryBuilder = buildSearchQueryBuilder(query, UserIndex.getFields());
+  public SearchRequest.Builder buildUserOrTeamSearchBuilder(String query, int from, int size) {
+    QueryStringQuery.Builder queryBuilder =
+        buildSearchQueryBuilder(query, UserIndex.getFieldsWithWeights().stream().toList());
     return searchBuilder(queryBuilder, null, from, size);
   }
 
-  private SearchSourceBuilder addAggregation(SearchSourceBuilder searchSourceBuilder) {
+  private SearchRequest.Builder addAggregation(SearchRequest.Builder searchSourceBuilder) {
     searchSettings
         .getGlobalSettings()
         .getAggregations()
         .forEach(
             agg ->
-                searchSourceBuilder.aggregation(
-                    AggregationBuilders.terms(agg.getName())
+                searchSourceBuilder.aggregations(
+                    agg.getName(),
+                    AggregationBuilders.terms()
                         .field(agg.getField())
-                        .size(searchSettings.getGlobalSettings().getMaxAggregateSize())));
+                        .size(searchSettings.getGlobalSettings().getMaxAggregateSize())
+                        .build()
+                        ._toAggregation()));
     return searchSourceBuilder;
   }
 
   @Override
-  public SearchSourceBuilder buildTestCaseSearch(String query, int from, int size) {
-    QueryStringQueryBuilder queryBuilder =
-        buildSearchQueryBuilder(query, TestCaseIndex.getFields());
-    HighlightBuilder hb = buildHighlights(List.of("testSuite.name", "testSuite.description"));
+  public SearchRequest.Builder buildTestCaseSearch(String query, int from, int size) {
+    QueryStringQuery.Builder queryBuilder =
+        buildSearchQueryBuilder(query, TestCaseIndex.getFieldsWithWeights().stream().toList());
+    Highlight.Builder hb = buildHighlights(List.of("testSuite.name", "testSuite.description"));
     return searchBuilder(queryBuilder, hb, from, size);
   }
 
   @Override
-  public SearchSourceBuilder buildCostAnalysisReportDataSearch(String query, int from, int size) {
-    QueryStringQueryBuilder queryBuilder = QueryBuilders.queryStringQuery(query);
+  public SearchRequest.Builder buildCostAnalysisReportDataSearch(String query, int from, int size) {
+    QueryStringQuery.Builder queryBuilder = new QueryStringQuery.Builder().query(query);
     return searchBuilder(queryBuilder, null, from, size);
   }
 
   @Override
-  public SearchSourceBuilder buildTestCaseResolutionStatusSearch(String query, int from, int size) {
-    QueryStringQueryBuilder queryBuilder =
-        buildSearchQueryBuilder(query, TestCaseResolutionStatusIndex.getFields());
-    HighlightBuilder hb = buildHighlights(new ArrayList<>());
+  public SearchRequest.Builder buildTestCaseResolutionStatusSearch(
+      String query, int from, int size) {
+    QueryStringQuery.Builder queryBuilder =
+        buildSearchQueryBuilder(
+            query, TestCaseResolutionStatusIndex.getFieldsWithWeights().stream().toList());
+    Highlight.Builder hb = buildHighlights(new ArrayList<>());
     return searchBuilder(queryBuilder, hb, from, size);
   }
 
   @Override
-  public SearchSourceBuilder buildTestCaseResultSearch(String query, int from, int size) {
-    QueryStringQueryBuilder queryBuilder =
-        buildSearchQueryBuilder(query, TestCaseResultIndex.getFields());
-    HighlightBuilder hb = buildHighlights(new ArrayList<>());
+  public SearchRequest.Builder buildTestCaseResultSearch(String query, int from, int size) {
+    QueryStringQuery.Builder queryBuilder =
+        buildSearchQueryBuilder(
+            query, TestCaseResultIndex.getFieldsWithWeights().stream().toList());
+    Highlight.Builder hb = buildHighlights(new ArrayList<>());
     return searchBuilder(queryBuilder, hb, from, size);
   }
 
   @Override
-  public SearchSourceBuilder buildServiceSearchBuilder(String query, int from, int size) {
-    QueryStringQueryBuilder queryBuilder =
-        buildSearchQueryBuilder(query, SearchIndex.getDefaultFields());
-    HighlightBuilder hb = buildHighlights(new ArrayList<>());
+  public SearchRequest.Builder buildServiceSearchBuilder(String query, int from, int size) {
+    QueryStringQuery.Builder queryBuilder =
+        buildSearchQueryBuilder(query, SearchIndex.getDefaultFields().stream().toList());
+    Highlight.Builder hb = buildHighlights(new ArrayList<>());
     return searchBuilder(queryBuilder, hb, from, size);
   }
 
   @Override
-  public SearchSourceBuilder buildAggregateSearchBuilder(String query, int from, int size) {
-    QueryStringQueryBuilder queryBuilder =
-        QueryBuilders.queryStringQuery(query)
-            .fields(SearchIndex.getAllFields())
-            .fuzziness(Fuzziness.AUTO);
-    SearchSourceBuilder searchSourceBuilder = searchBuilder(queryBuilder, null, from, size);
+  public SearchRequest.Builder buildAggregateSearchBuilder(String query, int from, int size) {
+    QueryStringQuery.Builder queryBuilder =
+        new QueryStringQuery.Builder()
+            .query(query)
+            .fields(SearchIndex.getAllFields().stream().toList())
+            .fuzziness("auto");
+    SearchRequest.Builder searchSourceBuilder = searchBuilder(queryBuilder, null, from, size);
     return addAggregation(searchSourceBuilder);
   }
 
   @Override
-  public SearchSourceBuilder buildDataAssetSearchBuilder(
+  public SearchRequest.Builder buildDataAssetSearchBuilder(
       String indexName, String query, int from, int size) {
+
     AssetTypeConfiguration assetConfig = findAssetTypeConfig(indexName, searchSettings);
-    Map<String, Float> fields;
-    if (assetConfig.getSearchFields() != null && !assetConfig.getSearchFields().isEmpty()) {
-      fields = new HashMap<>();
-      assetConfig
-          .getSearchFields()
-          .forEach(
-              fieldBoost -> fields.put(fieldBoost.getField(), fieldBoost.getBoost().floatValue()));
-    } else {
-      fields = SearchIndex.getDefaultFields();
-    }
+    List<String> fields =
+        assetConfig.getSearchFields() != null && !assetConfig.getSearchFields().isEmpty()
+            ? assetConfig.getSearchFields().stream()
+                .map(fieldBoost -> fieldBoost.getField() + "^" + fieldBoost.getBoost().floatValue())
+                .toList()
+            : SearchIndex.getDefaultFields().stream().toList();
 
-    BoolQueryBuilder baseQuery = QueryBuilders.boolQuery();
+    BoolQuery.Builder baseQuery = new BoolQuery.Builder();
+
     if (query == null || query.trim().isEmpty() || query.trim().equals("*")) {
-      baseQuery.must(QueryBuilders.matchAllQuery());
+      baseQuery.must(QueryBuilders.matchAll().build().toQuery());
     } else if (containsQuerySyntax(query)) {
-      QueryStringQueryBuilder queryStringBuilder =
-          QueryBuilders.queryStringQuery(query)
+      QueryStringQuery queryStringQuery =
+          new QueryStringQuery.Builder()
+              .query(query)
               .fields(fields)
-              .defaultOperator(Operator.AND)
-              .type(MultiMatchQueryBuilder.Type.MOST_FIELDS)
-              .fuzziness(Fuzziness.AUTO)
+              .defaultOperator(Operator.And)
+              .fuzziness("auto")
               .fuzzyPrefixLength(1)
-              .tieBreaker(0.3f);
-
-      baseQuery.must(queryStringBuilder);
+              .tieBreaker(0.3d)
+              .build();
+      baseQuery.must(new Query.Builder().queryString(queryStringQuery).build());
     } else {
-      MultiMatchQueryBuilder multiMatchQueryBuilder =
-          QueryBuilders.multiMatchQuery(query)
-              .type(MultiMatchQueryBuilder.Type.MOST_FIELDS)
-              .fuzziness(Fuzziness.AUTO)
+      MultiMatchQuery.Builder multiMatchQuery =
+          new MultiMatchQuery.Builder()
+              .query(query)
+              .fields(fields)
+              .type(TextQueryType.MostFields)
+              .fuzziness("AUTO")
               .prefixLength(1)
-              .operator(Operator.AND)
-              .tieBreaker(0.3f);
-
-      for (Map.Entry<String, Float> fieldEntry : fields.entrySet()) {
-        String fieldName = fieldEntry.getKey();
-        Float boost = fieldEntry.getValue();
-        multiMatchQueryBuilder.field(fieldName, boost);
-      }
+              .operator(Operator.And)
+              .tieBreaker(0.3d);
+      baseQuery.must(new Query.Builder().multiMatch(multiMatchQuery.build()).build());
+    }
 
-      baseQuery.must(multiMatchQueryBuilder);
-    }
+    List<FunctionScore> functions = new ArrayList<>();
+    searchSettings
+        .getGlobalSettings()
+        .getTermBoosts()
+        .forEach(tb -> functions.add(buildTermBoostFunction(tb)));
+    assetConfig.getTermBoosts().forEach(tb -> functions.add(buildTermBoostFunction(tb)));
+    searchSettings
+        .getGlobalSettings()
+        .getFieldValueBoosts()
+        .forEach(fvb -> functions.add(buildFieldValueBoostFunction(fvb)));
+    assetConfig
+        .getFieldValueBoosts()
+        .forEach(fvb -> functions.add(buildFieldValueBoostFunction(fvb)));
 
-    List<FunctionScoreQueryBuilder.FilterFunctionBuilder> functions = new ArrayList<>();
-    if (searchSettings.getGlobalSettings().getTermBoosts() != null) {
-      for (TermBoost tb : searchSettings.getGlobalSettings().getTermBoosts()) {
-        functions.add(buildTermBoostFunction(tb));
-      }
-    }
-    if (assetConfig.getTermBoosts() != null) {
-      for (TermBoost tb : assetConfig.getTermBoosts()) {
-        functions.add(buildTermBoostFunction(tb));
-      }
-    }
-    if (searchSettings.getGlobalSettings().getFieldValueBoosts() != null) {
-      for (FieldValueBoost fvb : searchSettings.getGlobalSettings().getFieldValueBoosts()) {
-        functions.add(buildFieldValueBoostFunction(fvb));
-      }
-    }
-    if (assetConfig.getFieldValueBoosts() != null) {
-      for (FieldValueBoost fvb : assetConfig.getFieldValueBoosts()) {
-        functions.add(buildFieldValueBoostFunction(fvb));
-      }
-    }
-
-    QueryBuilder finalQuery = baseQuery;
+    Query finalQuery = new Query.Builder().bool(baseQuery.build()).build();
     if (!functions.isEmpty()) {
-      float functionBoostFactor = 0.3f;
-      FunctionScoreQueryBuilder functionScore =
-          QueryBuilders.functionScoreQuery(
-              baseQuery, functions.toArray(new FunctionScoreQueryBuilder.FilterFunctionBuilder[0]));
-
-      if (assetConfig.getScoreMode() != null) {
-        functionScore.scoreMode(toScoreMode(assetConfig.getScoreMode().value()));
-      } else {
-        functionScore.scoreMode(FunctionScoreQuery.ScoreMode.SUM);
-      }
-
-      if (assetConfig.getBoostMode() != null) {
-        functionScore.boostMode(toCombineFunction(assetConfig.getBoostMode().value()));
-      } else {
-        functionScore.boostMode(CombineFunction.SUM);
-      }
+      FunctionScoreQuery.Builder functionScoreQuery =
+          new FunctionScoreQuery.Builder()
+              .query(finalQuery)
+              .functions(functions)
+              .scoreMode(toScoreMode(assetConfig.getScoreMode().value()))
+              .boostMode(toCombineFunction(assetConfig.getBoostMode().value()));
 
-      BoolQueryBuilder combinedQuery = QueryBuilders.boolQuery();
-      combinedQuery.must(baseQuery);
-      combinedQuery.should(functionScore.boost(functionBoostFactor));
-      finalQuery = combinedQuery;
+      finalQuery = new Query.Builder().functionScore(functionScoreQuery.build()).build();
     }
 
-    HighlightBuilder highlightBuilder = null;
+    Highlight highlight = null;
     if (query != null && !query.trim().isEmpty()) {
-      if (assetConfig.getHighlightFields() != null && !assetConfig.getHighlightFields().isEmpty()) {
-        highlightBuilder = buildHighlights(assetConfig.getHighlightFields());
-      } else if (searchSettings.getGlobalSettings().getHighlightFields() != null) {
-        highlightBuilder = buildHighlights(searchSettings.getGlobalSettings().getHighlightFields());
+      List<String> highlightFields =
+          assetConfig.getHighlightFields() != null
+              ? assetConfig.getHighlightFields()
+              : searchSettings.getGlobalSettings().getHighlightFields();
+      if (highlightFields != null && !highlightFields.isEmpty()) {
+        Highlight.Builder highlightBuilder = new Highlight.Builder();
+        highlightFields.forEach(
+            field -> highlightBuilder.fields(field, new HighlightField.Builder().build()));
+        highlight = highlightBuilder.build();
       }
     }
 
-    SearchSourceBuilder searchSourceBuilder =
-        new SearchSourceBuilder()
-            .query(finalQuery)
-            .from(Math.min(from, searchSettings.getGlobalSettings().getMaxResultHits()))
-            .size(Math.min(size, searchSettings.getGlobalSettings().getMaxResultHits()));
-
-    if (highlightBuilder != null) {
-      searchSourceBuilder.highlighter(highlightBuilder);
-    }
+    return new SearchRequest.Builder()
+        .index(indexName)
+        .query(finalQuery)
+        .from(Math.min(from, searchSettings.getGlobalSettings().getMaxResultHits()))
+        .size(Math.min(size, searchSettings.getGlobalSettings().getMaxResultHits()))
+        .highlight(highlight)
+        .explain(true);
+  }
 
-    addConfiguredAggregations(searchSourceBuilder, assetConfig);
-    searchSourceBuilder.explain(true);
-    return searchSourceBuilder;
+  private FunctionScore buildTermBoostFunction(TermBoost tb) {
+    return new FunctionScore.Builder()
+        .filter(f -> f.term(t -> t.field(tb.getField()).value(FieldValue.of(tb.getValue()))))
+        .weight(tb.getBoost())
+        .build();
   }
 
-  private FunctionScoreQueryBuilder.FilterFunctionBuilder buildTermBoostFunction(TermBoost tb) {
-    return new FunctionScoreQueryBuilder.FilterFunctionBuilder(
-        QueryBuilders.termQuery(tb.getField(), tb.getValue()),
-        ScoreFunctionBuilders.weightFactorFunction(tb.getBoost().floatValue()));
-  }
-
-  private FunctionScoreQueryBuilder.FilterFunctionBuilder buildFieldValueBoostFunction(
-      FieldValueBoost fvb) {
-    QueryBuilder condition = QueryBuilders.matchAllQuery();
+  private FunctionScore buildFieldValueBoostFunction(FieldValueBoost fvb) {
+    BoolQuery.Builder condition =
+        new BoolQuery.Builder().must(QueryBuilders.matchAll().build()._toQuery());
     if (fvb.getCondition() != null && fvb.getCondition().getRange() != null) {
-      BoolQueryBuilder rangeQuery = QueryBuilders.boolQuery();
+      BoolQuery.Builder rangeQuery = QueryBuilders.bool();
       if (fvb.getCondition().getRange().getGt() != null) {
         rangeQuery.filter(
-            QueryBuilders.rangeQuery(fvb.getField()).gt(fvb.getCondition().getRange().getGt()));
+            new RangeQuery.Builder()
+                .field(fvb.getField())
+                .gt(JsonData.of(fvb.getCondition().getRange().getGt()))
+                .build()
+                .toQuery());
       }
       if (fvb.getCondition().getRange().getGte() != null) {
         rangeQuery.filter(
-            QueryBuilders.rangeQuery(fvb.getField()).gte(fvb.getCondition().getRange().getGte()));
+            new RangeQuery.Builder()
+                .field(fvb.getField())
+                .gte(JsonData.of(fvb.getCondition().getRange().getGte()))
+                .build()
+                .toQuery());
       }
       if (fvb.getCondition().getRange().getLt() != null) {
         rangeQuery.filter(
-            QueryBuilders.rangeQuery(fvb.getField()).lt(fvb.getCondition().getRange().getLt()));
+            new RangeQuery.Builder()
+                .field(fvb.getField())
+                .lt(JsonData.of(fvb.getCondition().getRange().getLt()))
+                .build()
+                .toQuery());
       }
       if (fvb.getCondition().getRange().getLte() != null) {
         rangeQuery.filter(
-            QueryBuilders.rangeQuery(fvb.getField()).lte(fvb.getCondition().getRange().getLte()));
+            new RangeQuery.Builder()
+                .field(fvb.getField())
+                .lte(JsonData.of(fvb.getCondition().getRange().getLte()))
+                .build()
+                .toQuery());
       }
       condition = rangeQuery;
     }
 
-    FieldValueFactorFunctionBuilder factorBuilder =
-        ScoreFunctionBuilders.fieldValueFactorFunction(fvb.getField())
-            .factor(fvb.getFactor().floatValue())
-            .missing(fvb.getMissing() == null ? 0.0f : fvb.getMissing().floatValue());
+    FieldValueFactorScoreFunction.Builder factorBuilder =
+        new FieldValueFactorScoreFunction.Builder()
+            .field(fvb.getField())
+            .factor(fvb.getFactor())
+            .missing(fvb.getMissing() == null ? 0.0f : fvb.getMissing());
 
     if (fvb.getModifier() != null) {
-      switch (fvb.getModifier().value()) {
-        case "log":
-          factorBuilder.modifier(FieldValueFactorFunction.Modifier.LOG);
-          break;
-        case "log1p":
-          try {
-            factorBuilder.modifier(FieldValueFactorFunction.Modifier.LOG1P);
-          } catch (NoSuchFieldError e) {
-            factorBuilder.modifier(FieldValueFactorFunction.Modifier.LOG);
-          }
-          break;
-        case "sqrt":
-          try {
-            factorBuilder.modifier(FieldValueFactorFunction.Modifier.SQRT);
-          } catch (NoSuchFieldError ignored) {
-          }
-          break;
-        default:
-          break;
-      }
-    }
-    return new FunctionScoreQueryBuilder.FilterFunctionBuilder(condition, factorBuilder);
+      factorBuilder.modifier(toModifier(fvb.getModifier().value()));
+    }
+    return new FunctionScore.Builder()
+        .filter(condition.build()._toQuery())
+        .fieldValueFactor(factorBuilder.build())
+        .build();
+  }
+
+  private FieldValueFactorModifier toModifier(String value) {
+    return switch (value) {
+      case "log" -> FieldValueFactorModifier.Log;
+      case "log1p" -> FieldValueFactorModifier.Log1p;
+      case "sqrt" -> FieldValueFactorModifier.Sqrt;
+        // TODO: Add other modifiers as needed
+      default -> null;
+    };
   }
 
-  private FunctionScoreQuery.ScoreMode toScoreMode(String mode) {
+  private FunctionScoreMode toScoreMode(String mode) {
     return switch (mode.toLowerCase()) {
-      case "avg" -> FunctionScoreQuery.ScoreMode.AVG;
-      case "max" -> FunctionScoreQuery.ScoreMode.MAX;
-      case "min" -> FunctionScoreQuery.ScoreMode.MIN;
-      case "multiply" -> FunctionScoreQuery.ScoreMode.MULTIPLY;
-      case "first" -> FunctionScoreQuery.ScoreMode.FIRST;
-      default -> FunctionScoreQuery.ScoreMode.SUM;
+      case "avg" -> FunctionScoreMode.Avg;
+      case "max" -> FunctionScoreMode.Max;
+      case "min" -> FunctionScoreMode.Min;
+      case "multiply" -> FunctionScoreMode.Multiply;
+      case "first" -> FunctionScoreMode.First;
+      default -> FunctionScoreMode.Sum;
     };
   }
 
-  private CombineFunction toCombineFunction(String mode) {
+  private FunctionBoostMode toCombineFunction(String mode) {
     return switch (mode.toLowerCase()) {
-      case "sum" -> CombineFunction.SUM;
-      case "avg" -> CombineFunction.AVG;
-      case "max" -> CombineFunction.MAX;
-      case "min" -> CombineFunction.MIN;
-      case "replace" -> CombineFunction.REPLACE;
-      default -> CombineFunction.MULTIPLY;
+      case "sum" -> FunctionBoostMode.Sum;
+      case "avg" -> FunctionBoostMode.Avg;
+      case "max" -> FunctionBoostMode.Max;
+      case "min" -> FunctionBoostMode.Min;
+      case "replace" -> FunctionBoostMode.Replace;
+      default -> FunctionBoostMode.Multiply;
     };
   }
 
-  public HighlightBuilder buildHighlights(List<String> fields) {
-    HighlightBuilder hb = new HighlightBuilder();
+  public Highlight.Builder buildHighlights(List<String> fields) {
+    Highlight.Builder hb = new Highlight.Builder();
     hb.preTags(PRE_TAG);
     hb.postTags(POST_TAG);
     hb.requireFieldMatch(false);
-    for (String field : fields) {
-      HighlightBuilder.Field highlightField = new HighlightBuilder.Field(field);
-      highlightField.highlighterType("unified");
-      hb.field(highlightField);
-    }
+    Map<String, HighlightField> highlightFields =
+        fields.stream()
+            .collect(
+                Collectors.toMap(
+                    field -> field,
+                    field ->
+                        HighlightField.of(
+                            hf ->
+                                hf.type(
+                                    HighlighterType.of(
+                                        h -> h.builtin(BuiltinHighlighterType.Unified))))));
+    hb.fields(highlightFields);
     return hb;
   }
 
   private void addConfiguredAggregations(
-      SearchSourceBuilder searchSourceBuilder, AssetTypeConfiguration assetConfig) {
+      SearchRequest.Builder searchSourceBuilder, AssetTypeConfiguration assetConfig) {
     Map<String, Aggregation> aggregations = new HashMap<>();
 
     // Add asset type aggregations
@@ -363,19 +370,36 @@
 
     for (var entry : aggregations.entrySet()) {
       Aggregation agg = entry.getValue();
-      searchSourceBuilder.aggregation(
-          AggregationBuilders.terms(agg.getName())
+      searchSourceBuilder.aggregations(
+          agg.getName(),
+          AggregationBuilders.terms()
               .field(agg.getField())
-              .size(searchSettings.getGlobalSettings().getMaxAggregateSize()));
+              .size(searchSettings.getGlobalSettings().getMaxAggregateSize())
+              .build()
+              ._toAggregation());
     }
   }
 
   @Override
-  public SearchSourceBuilder buildCommonSearchBuilder(String query, int from, int size) {
-    QueryStringQueryBuilder queryStringBuilder =
+  public SearchRequest.Builder buildTimeSeriesSearchBuilder(
+      String indexName, String query, int from, int size) {
+    return switch (indexName) {
+      case "test_case_result_search_index" -> buildTestCaseResultSearch(query, from, size);
+      case "test_case_resolution_status_search_index" -> buildTestCaseResolutionStatusSearch(
+          query, from, size);
+      case "raw_cost_analysis_report_data_index",
+          "aggregated_cost_analysis_report_data_index" -> buildCostAnalysisReportDataSearch(
+          query, from, size);
+      default -> buildAggregateSearchBuilder(query, from, size);
+    };
+  }
+
+  @Override
+  public SearchRequest.Builder buildCommonSearchBuilder(String query, int from, int size) {
+    QueryStringQuery.Builder queryStringBuilder =
         buildSearchQueryBuilder(query, getAllSearchFieldsFromSettings(searchSettings));
 
-    List<FunctionScoreQueryBuilder.FilterFunctionBuilder> functions = new ArrayList<>();
+    List<FunctionScore> functions = new ArrayList<>();
 
     // Add global term boosts
     if (searchSettings.getGlobalSettings().getTermBoosts() != null) {
@@ -391,37 +415,45 @@
       }
     }
 
-    QueryBuilder finalQuery = queryStringBuilder;
+    BoolQuery.Builder finalQuery =
+        new BoolQuery.Builder().must(queryStringBuilder.build()._toQuery());
     if (!functions.isEmpty()) {
-      FunctionScoreQueryBuilder functionScore =
-          QueryBuilders.functionScoreQuery(
-              queryStringBuilder,
-              functions.toArray(new FunctionScoreQueryBuilder.FilterFunctionBuilder[0]));
-      functionScore.scoreMode(FunctionScoreQuery.ScoreMode.SUM);
-      functionScore.boostMode(CombineFunction.MULTIPLY);
-      finalQuery = functionScore;
+      FunctionScoreQuery.Builder functionScoreQuery =
+          new FunctionScoreQuery.Builder()
+              .query(finalQuery.build()._toQuery())
+              .functions(functions)
+              .boostMode(FunctionBoostMode.Multiply)
+              .scoreMode(FunctionScoreMode.Sum);
+      finalQuery = new BoolQuery.Builder().must(functionScoreQuery.build()._toQuery());
     }
 
-    SearchSourceBuilder searchSourceBuilder =
-        new SearchSourceBuilder()
-            .query(finalQuery)
+    SearchRequest.Builder searchSourceBuilder =
+        new SearchRequest.Builder()
+            .query(finalQuery.build()._toQuery())
             .from(Math.min(from, searchSettings.getGlobalSettings().getMaxResultHits()))
             .size(Math.min(size, searchSettings.getGlobalSettings().getMaxResultHits()));
 
     // Add global highlight fields if configured
     if (searchSettings.getGlobalSettings().getHighlightFields() != null) {
-      searchSourceBuilder.highlighter(
-          buildHighlights(searchSettings.getGlobalSettings().getHighlightFields()));
+      searchSourceBuilder.highlight(
+          buildHighlights(searchSettings.getGlobalSettings().getHighlightFields()).build());
     }
 
+    // Add specific data asset aggregations
     addAggregation(searchSourceBuilder);
+
     return searchSourceBuilder;
   }
 
-  public SearchSourceBuilder addAggregationsToNLQQuery(
-      SearchSourceBuilder searchSourceBuilder, String indexName) {
+  // Add this new method for applying aggregations to NLQ queries
+  public SearchRequest.Builder addAggregationsToNLQQuery(
+      SearchRequest.Builder searchSourceBuilder, String indexName) {
+    // Find the appropriate asset type configuration
     AssetTypeConfiguration assetConfig = findAssetTypeConfig(indexName, searchSettings);
+
+    // Apply aggregations based on asset type and global settings
     addConfiguredAggregations(searchSourceBuilder, assetConfig);
+
     return searchSourceBuilder;
   }
 }
Index: openmetadata-service/src/main/java/org/openmetadata/service/search/aggregation/EsAggregationContainer.java
===================================================================
diff --git a/openmetadata-service/src/main/java/org/openmetadata/service/search/aggregation/EsAggregationContainer.java b/openmetadata-service/src/main/java/org/openmetadata/service/search/aggregation/EsAggregationContainer.java
new file mode 100644
--- /dev/null	(date 1744005109957)
+++ b/openmetadata-service/src/main/java/org/openmetadata/service/search/aggregation/EsAggregationContainer.java	(date 1744005109957)
@@ -0,0 +1,15 @@
+package org.openmetadata.service.search.aggregation;
+
+import es.co.elastic.clients.elasticsearch._types.aggregations.Aggregation;
+
+public class EsAggregationContainer implements AggregationContainer {
+  private final Aggregation aggregation;
+
+  public EsAggregationContainer(Aggregation aggregation) {
+    this.aggregation = aggregation;
+  }
+
+  public AggregationContainer getAggregation() {
+    return this;
+  }
+}
Index: openmetadata-service/src/main/java/org/openmetadata/service/search/SearchRequestContext.java
===================================================================
diff --git a/openmetadata-service/src/main/java/org/openmetadata/service/search/SearchRequestContext.java b/openmetadata-service/src/main/java/org/openmetadata/service/search/SearchRequestContext.java
new file mode 100644
--- /dev/null	(date 1744005109952)
+++ b/openmetadata-service/src/main/java/org/openmetadata/service/search/SearchRequestContext.java	(date 1744005109952)
@@ -0,0 +1,26 @@
+package org.openmetadata.service.search;
+
+import es.co.elastic.clients.elasticsearch._types.aggregations.Aggregation;
+import es.co.elastic.clients.elasticsearch.core.SearchRequest;
+import java.util.HashMap;
+import java.util.Map;
+import lombok.Builder;
+import lombok.Getter;
+import lombok.Setter;
+import org.openmetadata.service.search.queries.OMQueryBuilder;
+
+@Getter
+@Setter
+@Builder
+public class SearchRequestContext {
+  protected String index;
+  protected OMQueryBuilder query;
+  protected Map<String, Aggregation> aggregations = new HashMap<>();
+  private int from;
+  private int size;
+
+  public final SearchRequest.Builder aggregations(String key, Aggregation value) {
+    this.aggregations = _mapPut(this.aggregations, key, value);
+    return this;
+  }
+}
Index: openmetadata-shaded-deps/elasticsearch-dep/pom.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openmetadata-shaded-deps/elasticsearch-dep/pom.xml b/openmetadata-shaded-deps/elasticsearch-dep/pom.xml
--- a/openmetadata-shaded-deps/elasticsearch-dep/pom.xml	(revision d10bcccecad7a11724e8df23cf8c879f9f0673da)
+++ b/openmetadata-shaded-deps/elasticsearch-dep/pom.xml	(date 1744005109985)
@@ -17,8 +17,8 @@
              the dependency reduced pom is not reflected in a multi-module build
              correctly. -->
         <dependency>
-            <groupId>org.elasticsearch.client</groupId>
-            <artifactId>elasticsearch-rest-high-level-client</artifactId>
+            <groupId>co.elastic.clients</groupId>
+             <artifactId>elasticsearch-java</artifactId>
             <optional>true</optional>
             <exclusions>
                 <exclusion>
@@ -111,12 +111,12 @@
                     </artifactSet>
                     <relocations combine.children="append">
                         <relocation>
-                            <pattern>org.elasticsearch</pattern>
-                            <shadedPattern>es.org.elasticsearch</shadedPattern>
+                            <pattern>co.elastic</pattern>
+                            <shadedPattern>es.co.elastic</shadedPattern>
                         </relocation>
                         <relocation>
-                            <pattern>org.elasticsearch.client</pattern>
-                            <shadedPattern>es.org.elasticsearch.client</shadedPattern>
+                            <pattern>co.elastic.clients</pattern>
+                            <shadedPattern>es.co.elastic.clients</shadedPattern>
                         </relocation>
                         <relocation>
                             <pattern>org.apache.lucene</pattern>
Index: openmetadata-shaded-deps/opensearch-dep/pom.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openmetadata-shaded-deps/opensearch-dep/pom.xml b/openmetadata-shaded-deps/opensearch-dep/pom.xml
--- a/openmetadata-shaded-deps/opensearch-dep/pom.xml	(revision d10bcccecad7a11724e8df23cf8c879f9f0673da)
+++ b/openmetadata-shaded-deps/opensearch-dep/pom.xml	(date 1744005109987)
@@ -18,7 +18,7 @@
              correctly. -->
         <dependency>
             <groupId>org.opensearch.client</groupId>
-            <artifactId>opensearch-rest-high-level-client</artifactId>
+            <artifactId>opensearch-java</artifactId>
             <optional>true</optional>
             <exclusions>
                 <exclusion>
Index: openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/SearchIndex.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/SearchIndex.java b/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/SearchIndex.java
--- a/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/SearchIndex.java	(revision d10bcccecad7a11724e8df23cf8c879f9f0673da)
+++ b/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/SearchIndex.java	(date 1744005110010)
@@ -9,12 +9,33 @@
 import static org.openmetadata.service.Entity.getEntityByName;
 import static org.openmetadata.service.jdbi3.LineageRepository.buildEntityLineageData;
 import static org.openmetadata.service.search.EntityBuilderConstant.DISPLAY_NAME_KEYWORD;
+import static org.openmetadata.service.search.EntityBuilderConstant.DOMAIN_DISPLAY_NAME_KEYWORD;
+import static org.openmetadata.service.search.EntityBuilderConstant.ENTITY_TYPE;
+import static org.openmetadata.service.search.EntityBuilderConstant.ES_TAG_FQN_FIELD;
 import static org.openmetadata.service.search.EntityBuilderConstant.FIELD_DISPLAY_NAME_NGRAM;
 import static org.openmetadata.service.search.EntityBuilderConstant.FIELD_NAME_NGRAM;
 import static org.openmetadata.service.search.EntityBuilderConstant.FULLY_QUALIFIED_NAME;
 import static org.openmetadata.service.search.EntityBuilderConstant.FULLY_QUALIFIED_NAME_PARTS;
-import static org.openmetadata.service.util.FullyQualifiedName.getParentFQN;
+import static org.openmetadata.service.search.EntityBuilderConstant.INDEX;
+import static org.openmetadata.service.search.EntityBuilderConstant.MAX_AGGREGATE_SIZE;
+import static org.openmetadata.service.search.EntityBuilderConstant.NAME_KEYWORD;
+import static org.openmetadata.service.search.EntityBuilderConstant.OWNER_DISPLAY_NAME_KEYWORD;
+import static org.openmetadata.service.search.EntityBuilderConstant.POST_TAG;
+import static org.openmetadata.service.search.EntityBuilderConstant.PRE_TAG;
+import static org.openmetadata.service.search.EntityBuilderConstant.SERVICE_DISPLAY_NAME_KEYWORD;
+import static org.openmetadata.service.search.EntityBuilderConstant.SERVICE_TYPE;
+import static org.openmetadata.service.search.EntityBuilderConstant.TIER_TAG_FQN;
 
+import co.elastic.clients.elasticsearch._types.aggregations.Aggregation;
+import co.elastic.clients.elasticsearch._types.query_dsl.FieldValueFactorModifier;
+import co.elastic.clients.elasticsearch._types.query_dsl.FunctionBoostMode;
+import co.elastic.clients.elasticsearch._types.query_dsl.FunctionScore;
+import co.elastic.clients.elasticsearch._types.query_dsl.FunctionScoreMode;
+import co.elastic.clients.elasticsearch._types.query_dsl.FunctionScoreQuery;
+import co.elastic.clients.elasticsearch._types.query_dsl.Operator;
+import co.elastic.clients.elasticsearch._types.query_dsl.QueryStringQuery;
+import co.elastic.clients.elasticsearch.core.search.Highlight;
+import co.elastic.clients.elasticsearch.core.search.HighlightField;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
@@ -23,6 +44,7 @@
 import java.util.Map;
 import java.util.Optional;
 import java.util.Set;
+import java.util.stream.Stream;
 import org.apache.commons.lang3.tuple.ImmutablePair;
 import org.apache.commons.lang3.tuple.Pair;
 import org.openmetadata.schema.EntityInterface;
@@ -42,6 +64,9 @@
 import org.openmetadata.service.search.models.SearchSuggest;
 import org.openmetadata.service.util.FullyQualifiedName;
 import org.openmetadata.service.util.JsonUtils;
+import os.org.opensearch.client.json.JsonData;
+import os.org.opensearch.client.opensearch._types.query_dsl.MatchQuery;
+import os.org.opensearch.client.opensearch._types.query_dsl.RangeQuery;
 
 public interface SearchIndex {
   Set<String> DEFAULT_EXCLUDED_FIELDS =
@@ -354,34 +379,471 @@
     return details;
   }
 
-  static Map<String, Float> getDefaultFields() {
-    Map<String, Float> fields = new HashMap<>();
-    fields.put(DISPLAY_NAME_KEYWORD, 10.0f);
-    fields.put(FIELD_NAME, 10.0f);
-    fields.put(FIELD_NAME_NGRAM, 1.0f);
-    fields.put(FIELD_DISPLAY_NAME, 10.0f);
-    fields.put(FIELD_DISPLAY_NAME_NGRAM, 1.0f);
-    fields.put(FIELD_DESCRIPTION, 2.0f);
-    fields.put(FULLY_QUALIFIED_NAME, 5.0f);
-    fields.put(FULLY_QUALIFIED_NAME_PARTS, 5.0f);
+  static Set<String> getDefaultFields() {
+    Set<String> fieldWithBoost = new HashSet<>();
+    fieldWithBoost.add(String.format("%s^10", FIELD_DISPLAY_NAME));
+    fieldWithBoost.add(String.format("%s^1", FIELD_DISPLAY_NAME_NGRAM));
+    fieldWithBoost.add(String.format("%s^10", FIELD_NAME));
+    fieldWithBoost.add(String.format("%s^1", FIELD_NAME_NGRAM));
+    fieldWithBoost.add(String.format("%s^8", DISPLAY_NAME_KEYWORD));
+    fieldWithBoost.add(String.format("%s^8", NAME_KEYWORD));
+    fieldWithBoost.add(String.format("%s^2", FIELD_DESCRIPTION));
+    fieldWithBoost.add(String.format("%s^5", FULLY_QUALIFIED_NAME));
+    fieldWithBoost.add(String.format("%s^5", FULLY_QUALIFIED_NAME_PARTS));
+    return fieldWithBoost;
+  }
+
+  static Set<String> getAllFields() {
+    Set<String> fields = getDefaultFields();
+    fields.addAll(TableIndex.getFieldsWithWeights());
+    fields.addAll(DashboardIndex.getFieldsWithWeights());
+    fields.addAll(DashboardDataModelIndex.getFieldsWithWeights());
+    fields.addAll(PipelineIndex.getFieldsWithWeights());
+    fields.addAll(TopicIndex.getFieldsWithWeights());
+    fields.addAll(MlModelIndex.getFieldsWithWeights());
+    fields.addAll(ContainerIndex.getFieldsWithWeights());
+    fields.addAll(SearchEntityIndex.getFieldsWithWeights());
+    fields.addAll(GlossaryTermIndex.getFieldsWithWeights());
+    fields.addAll(TagIndex.getFieldsWithWeights());
+    fields.addAll(DataProductIndex.getFieldsWithWeights());
+    fields.addAll(APIEndpointIndex.getFieldsWithWeights());
     return fields;
   }
 
-  static Map<String, Float> getAllFields() {
-    Map<String, Float> fields = getDefaultFields();
-    fields.putAll(TableIndex.getFields());
-    fields.putAll(StoredProcedureIndex.getFields());
-    fields.putAll(DashboardIndex.getFields());
-    fields.putAll(DashboardDataModelIndex.getFields());
-    fields.putAll(PipelineIndex.getFields());
-    fields.putAll(TopicIndex.getFields());
-    fields.putAll(MlModelIndex.getFields());
-    fields.putAll(ContainerIndex.getFields());
-    fields.putAll(SearchEntityIndex.getFields());
-    fields.putAll(GlossaryTermIndex.getFields());
-    fields.putAll(TagIndex.getFields());
-    fields.putAll(DataProductIndex.getFields());
-    fields.putAll(APIEndpointIndex.getFields());
-    return fields;
+  static Map<String, Aggregation> addBaseElasticSearchAggregation() {
+    Map<String, Aggregation> aggregationMap = new HashMap<>();
+    aggregationMap.put(
+        SERVICE_TYPE,
+        new Aggregation.Builder()
+            .terms(termAgg -> termAgg.field(SERVICE_TYPE).size(MAX_AGGREGATE_SIZE))
+            .build());
+    aggregationMap.put(
+        SERVICE_DISPLAY_NAME_KEYWORD,
+        new Aggregation.Builder()
+            .terms(termAgg -> termAgg.field(SERVICE_DISPLAY_NAME_KEYWORD).size(MAX_AGGREGATE_SIZE))
+            .build());
+    aggregationMap.put(
+        ENTITY_TYPE,
+        new Aggregation.Builder()
+            .terms(termAgg -> termAgg.field(ENTITY_TYPE).size(MAX_AGGREGATE_SIZE))
+            .build());
+    aggregationMap.put(
+        TIER_TAG_FQN,
+        new Aggregation.Builder()
+            .terms(termAgg -> termAgg.field(TIER_TAG_FQN).size(MAX_AGGREGATE_SIZE))
+            .build());
+    aggregationMap.put(
+        OWNER_DISPLAY_NAME_KEYWORD,
+        new Aggregation.Builder()
+            .terms(termAgg -> termAgg.field(OWNER_DISPLAY_NAME_KEYWORD).size(MAX_AGGREGATE_SIZE))
+            .build());
+    aggregationMap.put(
+        DOMAIN_DISPLAY_NAME_KEYWORD,
+        new Aggregation.Builder()
+            .terms(termAgg -> termAgg.field(DOMAIN_DISPLAY_NAME_KEYWORD).size(MAX_AGGREGATE_SIZE))
+            .build());
+    aggregationMap.put(
+        ES_TAG_FQN_FIELD,
+        new Aggregation.Builder()
+            .terms(termAgg -> termAgg.field(ES_TAG_FQN_FIELD).size(MAX_AGGREGATE_SIZE))
+            .build());
+    aggregationMap.put(
+        INDEX,
+        new Aggregation.Builder()
+            .terms(termAgg -> termAgg.field(INDEX).size(MAX_AGGREGATE_SIZE))
+            .build());
+    return aggregationMap;
+  }
+
+  static Map<String, os.org.opensearch.client.opensearch._types.aggregations.Aggregation>
+      addBaseOpenSearchAggregation() {
+    Map<String, os.org.opensearch.client.opensearch._types.aggregations.Aggregation>
+        aggregationMap = new HashMap<>();
+    aggregationMap.put(
+        SERVICE_TYPE,
+        new os.org.opensearch.client.opensearch._types.aggregations.Aggregation.Builder()
+            .terms(termAgg -> termAgg.field(SERVICE_TYPE).size(MAX_AGGREGATE_SIZE))
+            .build());
+    aggregationMap.put(
+        SERVICE_DISPLAY_NAME_KEYWORD,
+        new os.org.opensearch.client.opensearch._types.aggregations.Aggregation.Builder()
+            .terms(termAgg -> termAgg.field(SERVICE_DISPLAY_NAME_KEYWORD).size(MAX_AGGREGATE_SIZE))
+            .build());
+    aggregationMap.put(
+        ENTITY_TYPE,
+        new os.org.opensearch.client.opensearch._types.aggregations.Aggregation.Builder()
+            .terms(termAgg -> termAgg.field(ENTITY_TYPE).size(MAX_AGGREGATE_SIZE))
+            .build());
+    aggregationMap.put(
+        TIER_TAG_FQN,
+        new os.org.opensearch.client.opensearch._types.aggregations.Aggregation.Builder()
+            .terms(termAgg -> termAgg.field(TIER_TAG_FQN).size(MAX_AGGREGATE_SIZE))
+            .build());
+    aggregationMap.put(
+        OWNER_DISPLAY_NAME_KEYWORD,
+        new os.org.opensearch.client.opensearch._types.aggregations.Aggregation.Builder()
+            .terms(termAgg -> termAgg.field(OWNER_DISPLAY_NAME_KEYWORD).size(MAX_AGGREGATE_SIZE))
+            .build());
+    aggregationMap.put(
+        DOMAIN_DISPLAY_NAME_KEYWORD,
+        new os.org.opensearch.client.opensearch._types.aggregations.Aggregation.Builder()
+            .terms(termAgg -> termAgg.field(DOMAIN_DISPLAY_NAME_KEYWORD).size(MAX_AGGREGATE_SIZE))
+            .build());
+    aggregationMap.put(
+        ES_TAG_FQN_FIELD,
+        new os.org.opensearch.client.opensearch._types.aggregations.Aggregation.Builder()
+            .terms(termAgg -> termAgg.field(ES_TAG_FQN_FIELD).size(MAX_AGGREGATE_SIZE))
+            .build());
+    aggregationMap.put(
+        INDEX,
+        new os.org.opensearch.client.opensearch._types.aggregations.Aggregation.Builder()
+            .terms(termAgg -> termAgg.field(INDEX).size(MAX_AGGREGATE_SIZE))
+            .build());
+    return aggregationMap;
+  }
+
+  static FunctionScoreQuery boostEsScore(String query, Set<String> fields) {
+    QueryStringQuery queryStringQuery =
+        QueryStringQuery.of(
+            q ->
+                q.query(query)
+                    .fields(fields.stream().toList())
+                    .defaultOperator(Operator.And)
+                    .fuzziness("AUTO")
+                    .fuzzyPrefixLength(3)
+                    .tieBreaker(0.5));
+    return getFunctionQuery(queryStringQuery, query).build();
+  }
+
+  static os.org.opensearch.client.opensearch._types.query_dsl.FunctionScoreQuery boostOsScore(
+      String query, Set<String> fields) {
+    os.org.opensearch.client.opensearch._types.query_dsl.QueryStringQuery queryStringQuery =
+        os.org.opensearch.client.opensearch._types.query_dsl.QueryStringQuery.of(
+            q ->
+                q.query(query)
+                    .fields(fields.stream().toList())
+                    .defaultOperator(
+                        os.org.opensearch.client.opensearch._types.query_dsl.Operator.And)
+                    .fuzziness("AUTO")
+                    .fuzzyPrefixLength(3)
+                    .tieBreaker(0.5));
+    return getFunctionQuery(queryStringQuery, query).build();
+  }
+
+  private static FunctionScoreQuery.Builder getFunctionQuery(
+      QueryStringQuery queryStr, String query) {
+
+    // Boost based on the existence of "displayName.keyword"
+    FunctionScore displayNameBoost =
+        FunctionScore.of(
+            funcScore ->
+                funcScore
+                    .filter(
+                        queryBuilder ->
+                            queryBuilder.exists(
+                                existQuery -> existQuery.field("displayName.keyword")))
+                    .weight(10.0));
+
+    // Only use name if displayName doesn't exist
+    FunctionScore nameBoost =
+        FunctionScore.of(
+            funcScore ->
+                funcScore
+                    .filter(
+                        queryBuilder ->
+                            queryBuilder.bool(
+                                boolQuery ->
+                                    boolQuery
+                                        .mustNot(
+                                            q ->
+                                                q.exists(
+                                                    existQuery ->
+                                                        existQuery.field("displayName.keyword")))
+                                        .must(
+                                            q ->
+                                                q.match(
+                                                    matchQuery ->
+                                                        matchQuery
+                                                            .field("name.keyword")
+                                                            .query(query)))))
+                    .weight(8.0));
+
+    // Tier 1
+    FunctionScore tier1Boost =
+        FunctionScore.of(
+            funcScore ->
+                funcScore
+                    .filter(
+                        queryBuilder ->
+                            queryBuilder.term(
+                                termQuery -> termQuery.field("tier.tagFQN").value("Tier.Tier1")))
+                    .weight(5.0));
+
+    // Tier 2
+    FunctionScore tier2Boost =
+        FunctionScore.of(
+            funcScore ->
+                funcScore
+                    .filter(
+                        queryBuilder ->
+                            queryBuilder.term(
+                                termQuery -> termQuery.field("tier.tagFQN").value("Tier.Tier2")))
+                    .weight(3.0));
+
+    // Tier 3
+    FunctionScore tier3Boost =
+        FunctionScore.of(
+            funcScore ->
+                funcScore
+                    .filter(
+                        queryBuilder ->
+                            queryBuilder.term(
+                                termQuery -> termQuery.field("tier.tagFQN").value("Tier.Tier3")))
+                    .weight(1.0));
+
+    // Weekly Stats
+    FunctionScore weeklyStatsBoost =
+        FunctionScore.of(
+            funcScore ->
+                funcScore
+                    .filter(
+                        queryBuilder ->
+                            queryBuilder.range(
+                                rangeQuery ->
+                                    rangeQuery.number(
+                                        n -> n.field("usageSummary.weeklyStats.count").gt(0.0))))
+                    .fieldValueFactor(
+                        fvf ->
+                            fvf.field("usageSummary.weeklyStats.count")
+                                .factor(1.5)
+                                .modifier(FieldValueFactorModifier.Sqrt)
+                                .missing(1.0)));
+
+    // Votes
+    FunctionScore totalVotesBoost =
+        FunctionScore.of(
+            funcScore ->
+                funcScore
+                    .filter(
+                        queryBuilder ->
+                            queryBuilder.range(
+                                rangeQuery ->
+                                    rangeQuery.number(n -> n.field("totalVotes").gt(0.0))))
+                    .fieldValueFactor(
+                        fvf ->
+                            fvf.field("totalVotes")
+                                .factor(2.0)
+                                .modifier(FieldValueFactorModifier.Ln1p)
+                                .missing(0.0)));
+
+    return new FunctionScoreQuery.Builder()
+        .query(queryStr._toQuery())
+        .functions(
+            List.of(
+                displayNameBoost,
+                nameBoost,
+                tier1Boost,
+                tier2Boost,
+                tier3Boost,
+                weeklyStatsBoost,
+                totalVotesBoost))
+        .scoreMode(FunctionScoreMode.Sum)
+        .boostMode(FunctionBoostMode.Sum);
+  }
+
+  private static os.org.opensearch.client.opensearch._types.query_dsl.FunctionScoreQuery.Builder
+      getFunctionQuery(
+          os.org.opensearch.client.opensearch._types.query_dsl.QueryStringQuery queryStr,
+          String query) {
+
+    // Boost based on the existence of "displayName.keyword"
+    os.org.opensearch.client.opensearch._types.query_dsl.FunctionScore displayNameBoost =
+        os.org.opensearch.client.opensearch._types.query_dsl.FunctionScore.of(
+            funcScore ->
+                funcScore
+                    .filter(
+                        queryBuilder ->
+                            queryBuilder.exists(
+                                existQuery -> existQuery.field("displayName.keyword")))
+                    .weight(10.0));
+
+    // Only use name if displayName doesn't exist
+    os.org.opensearch.client.opensearch._types.query_dsl.FunctionScore nameBoost =
+        os.org.opensearch.client.opensearch._types.query_dsl.FunctionScore.of(
+            funcScore ->
+                funcScore
+                    .filter(
+                        queryBuilder ->
+                            queryBuilder.bool(
+                                boolQuery ->
+                                    boolQuery
+                                        .mustNot(
+                                            q ->
+                                                q.exists(
+                                                    existQuery ->
+                                                        existQuery.field("displayName.keyword")))
+                                        .must(
+                                            q ->
+                                                q.match(
+                                                    new MatchQuery.Builder()
+                                                        .field("name.keyword")
+                                                        .query(fV -> fV.stringValue(query))
+                                                        .build()))))
+                    .weight(8.0));
+
+    // Tier 1
+    os.org.opensearch.client.opensearch._types.query_dsl.FunctionScore tier1Boost =
+        os.org.opensearch.client.opensearch._types.query_dsl.FunctionScore.of(
+            funcScore ->
+                funcScore
+                    .filter(
+                        queryBuilder ->
+                            queryBuilder.term(
+                                termQuery ->
+                                    termQuery
+                                        .field("tier.tagFQN")
+                                        .value(fV -> fV.stringValue("Tier.Tier1"))))
+                    .weight(5.0));
+
+    // Tier 2
+    os.org.opensearch.client.opensearch._types.query_dsl.FunctionScore tier2Boost =
+        os.org.opensearch.client.opensearch._types.query_dsl.FunctionScore.of(
+            funcScore ->
+                funcScore
+                    .filter(
+                        queryBuilder ->
+                            queryBuilder.term(
+                                termQuery ->
+                                    termQuery
+                                        .field("tier.tagFQN")
+                                        .value(fV -> fV.stringValue("Tier.Tier2"))))
+                    .weight(3.0));
+
+    // Tier 3
+    os.org.opensearch.client.opensearch._types.query_dsl.FunctionScore tier3Boost =
+        os.org.opensearch.client.opensearch._types.query_dsl.FunctionScore.of(
+            funcScore ->
+                funcScore
+                    .filter(
+                        queryBuilder ->
+                            queryBuilder.term(
+                                termQuery ->
+                                    termQuery
+                                        .field("tier.tagFQN")
+                                        .value(fV -> fV.stringValue("Tier.Tier3"))))
+                    .weight(1.0));
+
+    // Weekly Stats
+    os.org.opensearch.client.opensearch._types.query_dsl.FunctionScore weeklyStatsBoost =
+        os.org.opensearch.client.opensearch._types.query_dsl.FunctionScore.of(
+            funcScore ->
+                funcScore
+                    .filter(
+                        queryBuilder ->
+                            queryBuilder.range(
+                                new RangeQuery.Builder()
+                                    .field("usageSummary.weeklyStats.count")
+                                    .gt(JsonData.of(0.0))
+                                    .build()))
+                    .fieldValueFactor(
+                        fvf ->
+                            fvf.field("usageSummary.weeklyStats.count")
+                                .factor(1.5)
+                                .modifier(
+                                    os.org.opensearch.client.opensearch._types.query_dsl
+                                        .FieldValueFactorModifier.Sqrt)
+                                .missing(1.0)));
+
+    // Votes
+    os.org.opensearch.client.opensearch._types.query_dsl.FunctionScore totalVotesBoost =
+        os.org.opensearch.client.opensearch._types.query_dsl.FunctionScore.of(
+            funcScore ->
+                funcScore
+                    .filter(
+                        queryBuilder ->
+                            queryBuilder.range(
+                                new RangeQuery.Builder()
+                                    .field("totalVotes")
+                                    .gt(JsonData.of(0.0))
+                                    .build()))
+                    .fieldValueFactor(
+                        fvf ->
+                            fvf.field("totalVotes")
+                                .factor(2.0)
+                                .modifier(
+                                    os.org.opensearch.client.opensearch._types.query_dsl
+                                        .FieldValueFactorModifier.Ln1p)
+                                .missing(0.0)));
+
+    return new os.org.opensearch.client.opensearch._types.query_dsl.FunctionScoreQuery.Builder()
+        .query(queryStr.toQuery())
+        .functions(
+            List.of(
+                displayNameBoost,
+                nameBoost,
+                tier1Boost,
+                tier2Boost,
+                tier3Boost,
+                weeklyStatsBoost,
+                totalVotesBoost))
+        .scoreMode(os.org.opensearch.client.opensearch._types.query_dsl.FunctionScoreMode.Sum)
+        .boostMode(os.org.opensearch.client.opensearch._types.query_dsl.FunctionBoostMode.Sum);
+  }
+
+  static Highlight buildElasticSearchHighlights(Set<String> fields) {
+    List<String> defaultFields =
+        List.of(
+            FIELD_DISPLAY_NAME,
+            FIELD_NAME,
+            FIELD_DESCRIPTION,
+            FIELD_DISPLAY_NAME_NGRAM,
+            FIELD_NAME_NGRAM);
+    defaultFields = Stream.concat(defaultFields.stream(), fields.stream()).toList();
+
+    Highlight.Builder highlightBuilder = new Highlight.Builder();
+
+    // Add fields to the highlight builder
+    for (String field : defaultFields) {
+      HighlightField highlightField =
+          new HighlightField.Builder()
+              .matchedFields(field)
+              .preTags(PRE_TAG)
+              .postTags(POST_TAG)
+              .build();
+      highlightBuilder.fields(Map.of(field, highlightField));
+    }
+
+    highlightBuilder.preTags(PRE_TAG);
+    highlightBuilder.postTags(POST_TAG);
+
+    return highlightBuilder.build();
+  }
+
+  static os.org.opensearch.client.opensearch.core.search.Highlight buildOpenSearchHighlights(
+      Set<String> fields) {
+    List<String> defaultFields =
+        List.of(
+            FIELD_DISPLAY_NAME,
+            FIELD_NAME,
+            FIELD_DESCRIPTION,
+            FIELD_DISPLAY_NAME_NGRAM,
+            FIELD_NAME_NGRAM);
+    defaultFields = Stream.concat(defaultFields.stream(), fields.stream()).toList();
+
+    os.org.opensearch.client.opensearch.core.search.Highlight.Builder highlightBuilder =
+        new os.org.opensearch.client.opensearch.core.search.Highlight.Builder();
+
+    // Add fields to the highlight builder
+    for (String field : defaultFields) {
+      os.org.opensearch.client.opensearch.core.search.HighlightField highlightField =
+          new os.org.opensearch.client.opensearch.core.search.HighlightField.Builder()
+              .matchedFields(field)
+              .preTags(PRE_TAG)
+              .postTags(POST_TAG)
+              .build();
+      highlightBuilder.fields(Map.of(field, highlightField));
+    }
+
+    return highlightBuilder.build();
   }
 }
Index: openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/GlossaryTermIndex.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/GlossaryTermIndex.java b/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/GlossaryTermIndex.java
--- a/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/GlossaryTermIndex.java	(revision d10bcccecad7a11724e8df23cf8c879f9f0673da)
+++ b/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/GlossaryTermIndex.java	(date 1744005110018)
@@ -1,13 +1,31 @@
 package org.openmetadata.service.search.indexes;
 
+import co.elastic.clients.elasticsearch._types.aggregations.Aggregation;
+import co.elastic.clients.elasticsearch.core.SearchRequest;
 import java.util.ArrayList;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 import org.openmetadata.schema.entity.data.GlossaryTerm;
 import org.openmetadata.service.Entity;
 import org.openmetadata.service.search.models.SearchSuggest;
 
 public class GlossaryTermIndex implements SearchIndex {
+  public static final Set<String> FIELDS_WITH_WEIGHT = new HashSet<>();
+  public static final Set<String> HIGHLIGHT_FIELDS = new HashSet<>();
+
+  static {
+    Set<String> fields = SearchIndex.getDefaultFields();
+    fields.add("synonyms^5");
+    fields.add("synonyms.ngram^1");
+    fields.add("glossary.name^5");
+    fields.add("glossary.displayName^5");
+    FIELDS_WITH_WEIGHT.addAll(fields);
+
+    HIGHLIGHT_FIELDS.add("synonyms");
+  }
+
   final GlossaryTerm glossaryTerm;
 
   public GlossaryTermIndex(GlossaryTerm glossaryTerm) {
@@ -36,12 +54,57 @@
     return doc;
   }
 
-  public static Map<String, Float> getFields() {
-    Map<String, Float> fields = SearchIndex.getDefaultFields();
-    fields.put("synonyms", 5.0f);
-    fields.put("synonyms.ngram", 1.0f);
-    fields.put("glossary.name", 5.0f);
-    fields.put("glossary.displayName", 5.0f);
-    return fields;
+  public static Set<String> getHighLightFields() {
+    return HIGHLIGHT_FIELDS;
+  }
+
+  public static Set<String> getFieldsWithWeights() {
+    return FIELDS_WITH_WEIGHT;
+  }
+
+  public static SearchRequest.Builder addEsEntityAggregation(SearchRequest.Builder requestBuilder) {
+    // add Base Aggregations for ElasticSearch
+    SearchIndex.addBaseElasticSearchAggregation(requestBuilder);
+
+    requestBuilder
+        .aggregations(
+            "glossary.name.keyword",
+            new Aggregation.Builder()
+                .terms(termAgg -> termAgg.field("glossary.name.keyword"))
+                .build())
+        .aggregations(
+            "fqnParts_agg",
+            new Aggregation.Builder()
+                .terms(termAgg -> termAgg.field("fqnParts_agg").size(1000))
+                .build())
+        .aggregations(
+            "status", new Aggregation.Builder().terms(termAgg -> termAgg.field("status")).build());
+    return requestBuilder;
+  }
+
+  public static os.org.opensearch.client.opensearch.core.SearchRequest.Builder
+      addOsEntityAggregation(
+          os.org.opensearch.client.opensearch.core.SearchRequest.Builder requestBuilder) {
+
+    // add Base Aggregations for OpenSearch
+    SearchIndex.addBaseOpenSearchAggregation(requestBuilder);
+
+    requestBuilder
+        .aggregations(
+            "glossary.name.keyword",
+            new os.org.opensearch.client.opensearch._types.aggregations.Aggregation.Builder()
+                .terms(termAgg -> termAgg.field("glossary.name.keyword"))
+                .build())
+        .aggregations(
+            "fqnParts_agg",
+            new os.org.opensearch.client.opensearch._types.aggregations.Aggregation.Builder()
+                .terms(termAgg -> termAgg.field("fqnParts_agg").size(1000))
+                .build())
+        .aggregations(
+            "status",
+            new os.org.opensearch.client.opensearch._types.aggregations.Aggregation.Builder()
+                .terms(termAgg -> termAgg.field("status"))
+                .build());
+    return requestBuilder;
   }
 }
Index: openmetadata-service/src/main/java/org/openmetadata/service/apps/bundles/insights/workflows/dataAssets/processors/DataInsightsElasticSearchProcessor.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openmetadata-service/src/main/java/org/openmetadata/service/apps/bundles/insights/workflows/dataAssets/processors/DataInsightsElasticSearchProcessor.java b/openmetadata-service/src/main/java/org/openmetadata/service/apps/bundles/insights/workflows/dataAssets/processors/DataInsightsElasticSearchProcessor.java
--- a/openmetadata-service/src/main/java/org/openmetadata/service/apps/bundles/insights/workflows/dataAssets/processors/DataInsightsElasticSearchProcessor.java	(revision d10bcccecad7a11724e8df23cf8c879f9f0673da)
+++ b/openmetadata-service/src/main/java/org/openmetadata/service/apps/bundles/insights/workflows/dataAssets/processors/DataInsightsElasticSearchProcessor.java	(date 1744005110021)
@@ -3,9 +3,9 @@
 import static org.openmetadata.service.apps.bundles.insights.workflows.dataAssets.DataAssetsWorkflow.DATA_STREAM_KEY;
 import static org.openmetadata.service.workflows.searchIndex.ReindexingUtil.getUpdatedStats;
 
-import es.org.elasticsearch.action.bulk.BulkRequest;
-import es.org.elasticsearch.action.index.IndexRequest;
-import es.org.elasticsearch.xcontent.XContentType;
+import co.elastic.clients.elasticsearch.core.BulkRequest;
+import co.elastic.clients.elasticsearch.core.IndexRequest;
+import co.elastic.clients.elasticsearch.indices.CreateIndexRequest;
 import java.util.List;
 import java.util.Map;
 import lombok.extern.slf4j.Slf4j;
@@ -68,7 +68,7 @@
     return bulkRequests;
   }
 
-  private static IndexRequest getIndexRequest(String index, Map<String, Object> entity) {
+  private static CreateIndexRequest getIndexRequest(String index, Map<String, Object> entity) {
     IndexRequest indexRequest = new IndexRequest(index);
     indexRequest.source(JsonUtils.pojoToJson(entity), XContentType.JSON);
     indexRequest.opType("create");
Index: openmetadata-clients/openmetadata-java-client/pom.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openmetadata-clients/openmetadata-java-client/pom.xml b/openmetadata-clients/openmetadata-java-client/pom.xml
--- a/openmetadata-clients/openmetadata-java-client/pom.xml	(revision d10bcccecad7a11724e8df23cf8c879f9f0673da)
+++ b/openmetadata-clients/openmetadata-java-client/pom.xml	(date 1744005110027)
@@ -92,8 +92,8 @@
             <artifactId>lombok</artifactId>
         </dependency>
         <dependency>
-            <groupId>org.elasticsearch.client</groupId>
-            <artifactId>elasticsearch-rest-high-level-client</artifactId>
+            <groupId>co.elastic.clients</groupId>
+            <artifactId>elasticsearch-java</artifactId>
         </dependency>
         <!-- TEST -->
         <dependency>
Index: openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/DashboardDataModelIndex.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/DashboardDataModelIndex.java b/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/DashboardDataModelIndex.java
--- a/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/DashboardDataModelIndex.java	(revision d10bcccecad7a11724e8df23cf8c879f9f0673da)
+++ b/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/DashboardDataModelIndex.java	(date 1744005110035)
@@ -1,7 +1,10 @@
 package org.openmetadata.service.search.indexes;
 
 import static org.openmetadata.service.search.EntityBuilderConstant.COLUMNS_NAME_KEYWORD;
+import static org.openmetadata.service.search.EntityBuilderConstant.FIELD_COLUMN_NAMES;
 
+import co.elastic.clients.elasticsearch._types.aggregations.Aggregation;
+import es.co.elastic.clients.elasticsearch.core.SearchRequest;
 import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.List;
@@ -16,6 +19,18 @@
 
 public record DashboardDataModelIndex(DashboardDataModel dashboardDataModel)
     implements ColumnIndex {
+  public static final Set<String> FIELDS_WITH_WEIGHT = new HashSet<>();
+  public static final Set<String> HIGHLIGHT_FIELDS = new HashSet<>();
+
+  static {
+    Set<String> fields = SearchIndex.getDefaultFields();
+    fields.add(String.format("%s^10", COLUMNS_NAME_KEYWORD));
+    fields.add("columns.name^2");
+    fields.add("columns.displayName^1");
+    fields.add("columns.description^1");
+    fields.add("columns.children.name^2");
+    FIELDS_WITH_WEIGHT.addAll(fields);
+  }
 
   @Override
   public List<SearchSuggest> getSuggest() {
@@ -69,13 +84,62 @@
     return doc;
   }
 
-  public static Map<String, Float> getFields() {
-    Map<String, Float> fields = SearchIndex.getDefaultFields();
-    fields.put(COLUMNS_NAME_KEYWORD, 10.0f);
-    fields.put("columns.name", 2.0f);
-    fields.put("columns.displayName", 1.0f);
-    fields.put("columns.description", 1.0f);
-    fields.put("columns.children.name", 2.0f);
-    return fields;
+  public static Set<String> getHighLightFields() {
+    return HIGHLIGHT_FIELDS;
+  }
+
+  public static Set<String> getFieldsWithWeights() {
+    return FIELDS_WITH_WEIGHT;
+  }
+
+  public static SearchRequest.Builder addEsEntityAggregation(SearchRequest.Builder requestBuilder) {
+    // add Base Aggregations for ElasticSearch
+    SearchIndex.addBaseElasticSearchAggregation(requestBuilder);
+
+    requestBuilder
+        .aggregations(
+            "dataModelType",
+            new Aggregation.Builder().terms(termAgg -> termAgg.field("dataModelType")).build())
+        .aggregations(
+            COLUMNS_NAME_KEYWORD,
+            new Aggregation.Builder().terms(termAgg -> termAgg.field(COLUMNS_NAME_KEYWORD)).build())
+        .aggregations(
+            "project.keyword",
+            new Aggregation.Builder().terms(termAgg -> termAgg.field("project.keyword")).build())
+        .aggregations(
+            FIELD_COLUMN_NAMES,
+            new Aggregation.Builder().terms(termAgg -> termAgg.field(FIELD_COLUMN_NAMES)).build());
+    return requestBuilder;
+  }
+
+  public static os.org.opensearch.client.opensearch.core.SearchRequest.Builder
+      addOsEntityAggregation(
+          os.org.opensearch.client.opensearch.core.SearchRequest.Builder requestBuilder) {
+
+    // add Base Aggregations for OpenSearch
+    SearchIndex.addBaseOpenSearchAggregation(requestBuilder);
+
+    requestBuilder
+        .aggregations(
+            "dataModelType",
+            new os.org.opensearch.client.opensearch._types.aggregations.Aggregation.Builder()
+                .terms(termAgg -> termAgg.field("dataModelType"))
+                .build())
+        .aggregations(
+            COLUMNS_NAME_KEYWORD,
+            new os.org.opensearch.client.opensearch._types.aggregations.Aggregation.Builder()
+                .terms(termAgg -> termAgg.field(COLUMNS_NAME_KEYWORD))
+                .build())
+        .aggregations(
+            "project.keyword",
+            new os.org.opensearch.client.opensearch._types.aggregations.Aggregation.Builder()
+                .terms(termAgg -> termAgg.field("project.keyword"))
+                .build())
+        .aggregations(
+            FIELD_COLUMN_NAMES,
+            new os.org.opensearch.client.opensearch._types.aggregations.Aggregation.Builder()
+                .terms(termAgg -> termAgg.field(FIELD_COLUMN_NAMES))
+                .build());
+    return requestBuilder;
   }
 }
Index: openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/IngestionPipelineIndex.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/IngestionPipelineIndex.java b/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/IngestionPipelineIndex.java
--- a/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/IngestionPipelineIndex.java	(revision d10bcccecad7a11724e8df23cf8c879f9f0673da)
+++ b/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/IngestionPipelineIndex.java	(date 1744005110039)
@@ -2,6 +2,7 @@
 
 import java.util.ArrayList;
 import java.util.HashMap;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Optional;
@@ -15,6 +16,13 @@
 import org.openmetadata.service.util.JsonUtils;
 
 public class IngestionPipelineIndex implements SearchIndex {
+  public static final Set<String> FIELDS_WITH_WEIGHT = new HashSet<>();
+  public static final Set<String> HIGHLIGHT_FIELDS = new HashSet<>();
+
+  static {
+    FIELDS_WITH_WEIGHT.addAll(SearchIndex.getDefaultFields());
+  }
+
   final IngestionPipeline ingestionPipeline;
   final Set<String> excludeFields = Set.of("sourceConfig", "openMetadataServerConnection");
 
@@ -84,7 +92,11 @@
     return doc;
   }
 
-  public static Map<String, Float> getFields() {
-    return SearchIndex.getDefaultFields();
+  public static Set<String> getHighLightFields() {
+    return HIGHLIGHT_FIELDS;
+  }
+
+  public static Set<String> getFieldsWithWeights() {
+    return FIELDS_WITH_WEIGHT;
   }
 }
Index: openmetadata-service/src/main/java/org/openmetadata/service/search/opensearch/queries/OpenSearchQueryBuilder.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openmetadata-service/src/main/java/org/openmetadata/service/search/opensearch/queries/OpenSearchQueryBuilder.java b/openmetadata-service/src/main/java/org/openmetadata/service/search/opensearch/queries/OpenSearchQueryBuilder.java
--- a/openmetadata-service/src/main/java/org/openmetadata/service/search/opensearch/queries/OpenSearchQueryBuilder.java	(revision d10bcccecad7a11724e8df23cf8c879f9f0673da)
+++ b/openmetadata-service/src/main/java/org/openmetadata/service/search/opensearch/queries/OpenSearchQueryBuilder.java	(date 1744005110042)
@@ -1,23 +1,25 @@
 package org.openmetadata.service.search.opensearch.queries;
 
 import java.util.List;
+import java.util.stream.Collectors;
 import org.openmetadata.service.search.queries.OMQueryBuilder;
-import os.org.opensearch.index.query.BoolQueryBuilder;
-import os.org.opensearch.index.query.MatchAllQueryBuilder;
-import os.org.opensearch.index.query.QueryBuilder;
-import os.org.opensearch.index.query.QueryBuilders;
+import os.org.opensearch.client.opensearch._types.FieldValue;
+import os.org.opensearch.client.opensearch._types.query_dsl.BoolQuery;
+import os.org.opensearch.client.opensearch._types.query_dsl.MultiMatchQuery;
+import os.org.opensearch.client.opensearch._types.query_dsl.Operator;
+import os.org.opensearch.client.opensearch._types.query_dsl.Query;
+import os.org.opensearch.client.opensearch._types.query_dsl.QueryBuilders;
+import os.org.opensearch.client.opensearch._types.query_dsl.QueryStringQuery;
+import os.org.opensearch.client.opensearch._types.query_dsl.TermsQueryField;
+import os.org.opensearch.client.opensearch._types.query_dsl.TextQueryType;
 
 public class OpenSearchQueryBuilder implements OMQueryBuilder {
-  private QueryBuilder query;
+  private Query query;
 
   public OpenSearchQueryBuilder() {
     // Default constructor
   }
 
-  public OpenSearchQueryBuilder(QueryBuilder query) {
-    this.query = query;
-  }
-
   @Override
   public boolean isEmpty() {
     return query == null;
@@ -25,50 +27,51 @@
 
   @Override
   public boolean isMatchNone() {
-    if (query instanceof BoolQueryBuilder boolQuery) {
+    if (query != null && query.isBool()) {
+      BoolQuery boolQuery = query.bool();
       return boolQuery.must().isEmpty()
           && boolQuery.should().isEmpty()
           && boolQuery.mustNot().size() == 1
-          && boolQuery.mustNot().get(0) instanceof MatchAllQueryBuilder;
+          && boolQuery.mustNot().get(0).isMatchAll();
     }
     return false;
   }
 
   @Override
   public boolean isMatchAll() {
-    return query instanceof MatchAllQueryBuilder;
+    return query != null && query.isMatchAll();
   }
 
   @Override
   public OMQueryBuilder must(List<OMQueryBuilder> queries) {
-    BoolQueryBuilder boolQuery = getOrCreateBoolQuery();
-    for (OMQueryBuilder q : queries) {
-      OpenSearchQueryBuilder eqb = (OpenSearchQueryBuilder) q;
-      boolQuery.must(eqb.build());
-    }
-    this.query = boolQuery;
+    BoolQuery.Builder boolQuery = getOrCreateBoolQuery();
+    boolQuery.must(convertQueries(queries));
+    this.query = boolQuery.build().toQuery();
+    return this;
+  }
+
+  @Override
+  public OMQueryBuilder must(List<OMQueryBuilder> queries, List<OMQueryBuilder> filters) {
+    BoolQuery.Builder boolQuery = getOrCreateBoolQuery();
+    boolQuery.must(convertQueries(queries));
+    boolQuery.filter(convertQueries(filters));
+    this.query = boolQuery.build().toQuery();
     return this;
   }
 
   @Override
   public OMQueryBuilder should(List<OMQueryBuilder> queries) {
-    BoolQueryBuilder boolQuery = getOrCreateBoolQuery();
-    for (OMQueryBuilder q : queries) {
-      OpenSearchQueryBuilder eqb = (OpenSearchQueryBuilder) q;
-      boolQuery.should(eqb.build());
-    }
-    this.query = boolQuery;
+    BoolQuery.Builder boolQuery = getOrCreateBoolQuery();
+    boolQuery.should(convertQueries(queries));
+    this.query = boolQuery.build().toQuery();
     return this;
   }
 
   @Override
   public OMQueryBuilder mustNot(List<OMQueryBuilder> queries) {
-    BoolQueryBuilder boolQuery = getOrCreateBoolQuery();
-    for (OMQueryBuilder q : queries) {
-      OpenSearchQueryBuilder eqb = (OpenSearchQueryBuilder) q;
-      boolQuery.mustNot(eqb.build());
-    }
-    this.query = boolQuery;
+    BoolQuery.Builder boolQuery = getOrCreateBoolQuery();
+    boolQuery.mustNot(convertQueries(queries));
+    this.query = boolQuery.build().toQuery();
     return this;
   }
 
@@ -77,6 +80,11 @@
     return must(List.of(query));
   }
 
+  @Override
+  public OMQueryBuilder must(OMQueryBuilder query, OMQueryBuilder filter) {
+    return must(List.of(query), List.of(filter));
+  }
+
   @Override
   public OMQueryBuilder should(OMQueryBuilder query) {
     return should(List.of(query));
@@ -84,7 +92,8 @@
 
   @Override
   public boolean hasClauses() {
-    if (query instanceof BoolQueryBuilder boolQuery) {
+    if (query != null && query.isBool()) {
+      BoolQuery boolQuery = query.bool();
       return !boolQuery.must().isEmpty()
           || !boolQuery.should().isEmpty()
           || !boolQuery.mustNot().isEmpty();
@@ -92,56 +101,108 @@
     return query != null;
   }
 
-  public QueryBuilder build() {
+  public Query build() {
     return query;
   }
 
-  public OpenSearchQueryBuilder setQuery(QueryBuilder query) {
+  public OpenSearchQueryBuilder setQuery(Query query) {
     this.query = query;
     return this;
   }
 
-  // Helper methods
-
   public OpenSearchQueryBuilder matchNoneQuery() {
-    this.query = QueryBuilders.boolQuery().mustNot(QueryBuilders.matchAllQuery());
+    this.query = QueryBuilders.matchNone().build().toQuery();
     return this;
   }
 
   public OpenSearchQueryBuilder matchAllQuery() {
-    this.query = QueryBuilders.matchAllQuery();
+    this.query = QueryBuilders.matchAll().build().toQuery();
     return this;
   }
 
   public OpenSearchQueryBuilder boolQuery() {
-    this.query = QueryBuilders.boolQuery();
+    this.query = QueryBuilders.bool().build().toQuery();
     return this;
   }
 
   public OpenSearchQueryBuilder termQuery(String field, String value) {
-    this.query = QueryBuilders.termQuery(field, value);
+    this.query = QueryBuilders.term().field(field).value(FieldValue.of(value)).build().toQuery();
     return this;
   }
 
   public OpenSearchQueryBuilder termsQuery(String field, List<String> values) {
-    this.query = QueryBuilders.termsQuery(field, values);
+    List<FieldValue> fieldValues = values.stream().map(FieldValue::of).toList();
+    TermsQueryField termsQueryField = new TermsQueryField.Builder().value(fieldValues).build();
+    this.query = QueryBuilders.terms().field(field).terms(termsQueryField).build().toQuery();
     return this;
   }
 
   public OpenSearchQueryBuilder existsQuery(String field) {
-    this.query = QueryBuilders.existsQuery(field);
+    this.query = QueryBuilders.exists().field(field).build().toQuery();
+    return this;
+  }
+
+  @Override
+  public OpenSearchQueryBuilder queryStringQuery(
+      String query,
+      List<String> fields,
+      String textQueryType,
+      String operator,
+      String fuzziness,
+      int fuzzyPrefixLength,
+      double tieBreaker) {
+    this.query =
+        new QueryStringQuery.Builder()
+            .query(query)
+            .fields(fields)
+            .type(TextQueryType.valueOf(textQueryType))
+            .defaultOperator(Operator.valueOf(operator))
+            .fuzziness(fuzziness)
+            .fuzzyPrefixLength(fuzzyPrefixLength)
+            .tieBreaker(tieBreaker)
+            .build()
+            .toQuery();
+    return this;
+  }
+
+  @Override
+  public OMQueryBuilder multiMatchQuery(
+      String query,
+      List<String> fields,
+      String queryType,
+      String operator,
+      String fuzziness,
+      int prefixLength,
+      double tieBreaker) {
+    this.query =
+        new MultiMatchQuery.Builder()
+            .query(query)
+            .fields(fields)
+            .type(TextQueryType.valueOf(queryType))
+            .fuzziness(fuzziness)
+            .prefixLength(prefixLength)
+            .operator(Operator.valueOf(operator))
+            .tieBreaker(tieBreaker)
+            .build()
+            .toQuery();
     return this;
   }
 
-  private BoolQueryBuilder getOrCreateBoolQuery() {
-    if (query instanceof BoolQueryBuilder) {
-      return (BoolQueryBuilder) query;
+  private BoolQuery.Builder getOrCreateBoolQuery() {
+    if (query != null && query.isBool()) {
+      return new BoolQuery.Builder().must(query.bool().toQuery());
     } else {
-      BoolQueryBuilder boolQuery = QueryBuilders.boolQuery();
+      BoolQuery.Builder boolQuery = QueryBuilders.bool();
       if (query != null) {
         boolQuery.must(query);
       }
       return boolQuery;
     }
   }
+
+  private List<Query> convertQueries(List<OMQueryBuilder> queries) {
+    return queries.stream()
+        .map(q -> ((OpenSearchQueryBuilder) q).build())
+        .collect(Collectors.toList());
+  }
 }
Index: openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/UserIndex.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/UserIndex.java b/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/UserIndex.java
--- a/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/UserIndex.java	(revision d10bcccecad7a11724e8df23cf8c879f9f0673da)
+++ b/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/UserIndex.java	(date 1744005110049)
@@ -1,6 +1,7 @@
 package org.openmetadata.service.search.indexes;
 
 import java.util.ArrayList;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
@@ -9,6 +10,13 @@
 import org.openmetadata.service.search.models.SearchSuggest;
 
 public class UserIndex implements SearchIndex {
+  public static final Set<String> FIELDS_WITH_WEIGHT = new HashSet<>();
+  public static final Set<String> HIGHLIGHT_FIELDS = new HashSet<>();
+
+  static {
+    FIELDS_WITH_WEIGHT.addAll(SearchIndex.getDefaultFields());
+  }
+
   final User user;
   final Set<String> excludeFields = Set.of("owns", "follows", "authenticationMechanism");
 
@@ -43,7 +51,11 @@
     return doc;
   }
 
-  public static Map<String, Float> getFields() {
-    return SearchIndex.getDefaultFields();
+  public static Set<String> getHighLightFields() {
+    return HIGHLIGHT_FIELDS;
+  }
+
+  public static Set<String> getFieldsWithWeights() {
+    return FIELDS_WITH_WEIGHT;
   }
 }
Index: openmetadata-service/src/main/java/org/openmetadata/service/search/SearchClient.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openmetadata-service/src/main/java/org/openmetadata/service/search/SearchClient.java b/openmetadata-service/src/main/java/org/openmetadata/service/search/SearchClient.java
--- a/openmetadata-service/src/main/java/org/openmetadata/service/search/SearchClient.java	(revision d10bcccecad7a11724e8df23cf8c879f9f0673da)
+++ b/openmetadata-service/src/main/java/org/openmetadata/service/search/SearchClient.java	(date 1744005110047)
@@ -19,7 +19,7 @@
 import org.openmetadata.schema.dataInsight.custom.DataInsightCustomChart;
 import org.openmetadata.schema.dataInsight.custom.DataInsightCustomChartResultList;
 import org.openmetadata.schema.entity.data.QueryCostSearchResult;
-import org.openmetadata.schema.search.SearchRequest;
+import org.openmetadata.schema.search.SearchRequestInternal;
 import org.openmetadata.schema.service.configuration.elasticsearch.ElasticSearchConfiguration;
 import org.openmetadata.schema.tests.DataQualityReport;
 import org.openmetadata.schema.type.EntityReference;
@@ -27,9 +27,9 @@
 import org.openmetadata.service.search.models.IndexMapping;
 import org.openmetadata.service.security.policyevaluator.SubjectContext;
 import org.openmetadata.service.util.ResultList;
-import os.org.opensearch.action.bulk.BulkRequest;
-import os.org.opensearch.action.bulk.BulkResponse;
 import os.org.opensearch.client.RequestOptions;
+import os.org.opensearch.client.opensearch.core.BulkRequest;
+import os.org.opensearch.client.opensearch.core.BulkResponse;
 
 public interface SearchClient {
   String UPSTREAM_LINEAGE_FIELD = "upstreamLineage";
@@ -164,7 +164,7 @@
 
   ElasticSearchConfiguration.SearchType getSearchType();
 
-  boolean indexExists(String indexName);
+  boolean indexExists(IndexMapping indexMapping);
 
   void createIndex(IndexMapping indexMapping, String indexMappingContent);
 
@@ -177,12 +177,13 @@
   void addIndexAlias(IndexMapping indexMapping, String... aliasName);
 
   Response previewSearch(
-      SearchRequest request, SubjectContext subjectContext, SearchSettings searchSettings)
+      SearchRequestInternal request, SubjectContext subjectContext, SearchSettings searchSettings)
       throws IOException;
 
-  Response search(SearchRequest request, SubjectContext subjectContext) throws IOException;
+  Response search(SearchRequestInternal request, SubjectContext subjectContext) throws IOException;
 
-  Response searchWithNLQ(SearchRequest request, SubjectContext subjectContext) throws IOException;
+  Response searchWithNLQ(SearchRequestInternal request, SubjectContext subjectContext)
+      throws IOException;
 
   Response getDocByID(String indexName, String entityId) throws IOException;
 
@@ -267,7 +268,7 @@
   DataQualityReport genericAggregation(
       String query, String index, SearchAggregation aggregationMetadata) throws IOException;
 
-  Response suggest(SearchRequest request) throws IOException;
+  Response suggest(SearchRequestInternal request) throws IOException;
 
   void createEntity(String indexName, String docId, String doc);
 
@@ -336,9 +337,9 @@
         Response.Status.NOT_IMPLEMENTED, NOT_IMPLEMENTED_ERROR_TYPE, NOT_IMPLEMENTED_METHOD);
   }
 
-  default es.org.elasticsearch.action.bulk.BulkResponse bulk(
-      es.org.elasticsearch.action.bulk.BulkRequest data,
-      es.org.elasticsearch.client.RequestOptions options)
+  default es.co.elastic.clients.elasticsearch.core.BulkResponse bulk(
+      es.co.elastic.clients.elasticsearch.core.BulkRequest data,
+      org.elasticsearch.client.RequestOptions options)
       throws IOException {
     throw new CustomExceptionMessage(
         Response.Status.NOT_IMPLEMENTED, NOT_IMPLEMENTED_ERROR_TYPE, NOT_IMPLEMENTED_METHOD);
Index: openmetadata-service/src/main/java/org/openmetadata/service/search/opensearch/queries/OpenSearchQueryBuilderFactory.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openmetadata-service/src/main/java/org/openmetadata/service/search/opensearch/queries/OpenSearchQueryBuilderFactory.java b/openmetadata-service/src/main/java/org/openmetadata/service/search/opensearch/queries/OpenSearchQueryBuilderFactory.java
--- a/openmetadata-service/src/main/java/org/openmetadata/service/search/opensearch/queries/OpenSearchQueryBuilderFactory.java	(revision d10bcccecad7a11724e8df23cf8c879f9f0673da)
+++ b/openmetadata-service/src/main/java/org/openmetadata/service/search/opensearch/queries/OpenSearchQueryBuilderFactory.java	(date 1744005110044)
@@ -35,4 +35,30 @@
   public OMQueryBuilder existsQuery(String field) {
     return new OpenSearchQueryBuilder().existsQuery(field);
   }
+
+  @Override
+  public OMQueryBuilder queryStringQuery(
+      String query,
+      List<String> fields,
+      String textQueryType,
+      String operator,
+      String fuzziness,
+      int fuzzinessPrefixLength,
+      double tieBreaker) {
+    return new OpenSearchQueryBuilder()
+        .queryStringQuery(query, fields, operator, fuzziness, fuzzinessPrefixLength, tieBreaker);
+  }
+
+  @Override
+  public OMQueryBuilder multiMatchQuery(
+      String query,
+      List<String> fields,
+      String operator,
+      String queryType,
+      String fuzziness,
+      int prefixLength,
+      double tieBreaker) {
+    return new OpenSearchQueryBuilder()
+        .multiMatchQuery(query, fields, queryType, operator, fuzziness, prefixLength, tieBreaker);
+  }
 }
Index: openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/TagIndex.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/TagIndex.java b/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/TagIndex.java
--- a/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/TagIndex.java	(revision d10bcccecad7a11724e8df23cf8c879f9f0673da)
+++ b/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/TagIndex.java	(date 1744005110051)
@@ -1,13 +1,25 @@
 package org.openmetadata.service.search.indexes;
 
+import co.elastic.clients.elasticsearch._types.aggregations.Aggregation;
+import co.elastic.clients.elasticsearch.core.SearchRequest;
 import java.util.ArrayList;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 import org.openmetadata.schema.entity.classification.Tag;
 import org.openmetadata.service.Entity;
 import org.openmetadata.service.search.models.SearchSuggest;
 
 public record TagIndex(Tag tag) implements SearchIndex {
+  public static final Set<String> FIELDS_WITH_WEIGHT = new HashSet<>();
+  public static final Set<String> HIGHLIGHT_FIELDS = new HashSet<>();
+
+  static {
+    Set<String> fields = SearchIndex.getDefaultFields();
+    fields.add("classification.name^10");
+    FIELDS_WITH_WEIGHT.addAll(fields);
+  }
 
   @Override
   public List<SearchSuggest> getSuggest() {
@@ -33,9 +45,38 @@
     return doc;
   }
 
-  public static Map<String, Float> getFields() {
-    Map<String, Float> fields = SearchIndex.getDefaultFields();
-    fields.put("classification.name", 7.0f);
-    return fields;
+  public static Set<String> getHighLightFields() {
+    return HIGHLIGHT_FIELDS;
+  }
+
+  public static Set<String> getFieldsWithWeights() {
+    return FIELDS_WITH_WEIGHT;
+  }
+
+  public static SearchRequest.Builder addEsEntityAggregation(SearchRequest.Builder requestBuilder) {
+    // add Base Aggregations for ElasticSearch
+    SearchIndex.addBaseElasticSearchAggregation(requestBuilder);
+
+    requestBuilder.aggregations(
+        "classification.name.keyword",
+        new Aggregation.Builder()
+            .terms(termAgg -> termAgg.field("classification.name.keyword"))
+            .build());
+    return requestBuilder;
+  }
+
+  public static os.org.opensearch.client.opensearch.core.SearchRequest.Builder
+      addOsEntityAggregation(
+          os.org.opensearch.client.opensearch.core.SearchRequest.Builder requestBuilder) {
+
+    // add Base Aggregations for OpenSearch
+    SearchIndex.addBaseOpenSearchAggregation(requestBuilder);
+
+    requestBuilder.aggregations(
+        "classification.name.keyword",
+        new os.org.opensearch.client.opensearch._types.aggregations.Aggregation.Builder()
+            .terms(termAgg -> termAgg.field("classification.name.keyword"))
+            .build());
+    return requestBuilder;
   }
 }
Index: openmetadata-service/src/main/java/org/openmetadata/service/resources/search/SearchResource.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openmetadata-service/src/main/java/org/openmetadata/service/resources/search/SearchResource.java b/openmetadata-service/src/main/java/org/openmetadata/service/resources/search/SearchResource.java
--- a/openmetadata-service/src/main/java/org/openmetadata/service/resources/search/SearchResource.java	(revision d10bcccecad7a11724e8df23cf8c879f9f0673da)
+++ b/openmetadata-service/src/main/java/org/openmetadata/service/resources/search/SearchResource.java	(date 1744005110056)
@@ -46,7 +46,7 @@
 import javax.ws.rs.core.UriInfo;
 import lombok.extern.slf4j.Slf4j;
 import org.openmetadata.schema.search.PreviewSearchRequest;
-import org.openmetadata.schema.search.SearchRequest;
+import org.openmetadata.schema.search.SearchRequestInternal;
 import org.openmetadata.schema.type.EntityReference;
 import org.openmetadata.service.Entity;
 import org.openmetadata.service.resources.Collection;
@@ -188,8 +188,8 @@
       domains = subjectContext.getUserDomains();
     }
 
-    SearchRequest request =
-        new SearchRequest()
+    SearchRequestInternal request =
+        new SearchRequestInternal()
             .withQuery(query)
             .withSize(size)
             .withIndex(Entity.getSearchRepository().getIndexOrAliasName(index))
@@ -237,8 +237,8 @@
 
     SubjectContext subjectContext = getSubjectContext(securityContext);
 
-    SearchRequest searchRequest =
-        new SearchRequest()
+    SearchRequestInternal searchRequest =
+        new SearchRequestInternal()
             .withQuery(previewRequest.getQuery())
             .withSize(previewRequest.getSize())
             .withIndex(Entity.getSearchRepository().getIndexOrAliasName(previewRequest.getIndex()))
@@ -337,8 +337,8 @@
       domains = subjectContext.getUserDomains();
     }
 
-    SearchRequest request =
-        new SearchRequest()
+    SearchRequestInternal request =
+        new SearchRequestInternal()
             .withQuery(nlqQuery)
             .withSize(size)
             .withIndex(Entity.getSearchRepository().getIndexOrAliasName(index))
@@ -493,8 +493,8 @@
       query = "*";
     }
 
-    SearchRequest request =
-        new SearchRequest()
+    SearchRequestInternal request =
+        new SearchRequestInternal()
             .withQuery(query)
             .withSize(size)
             .withIndex(index)
@@ -574,7 +574,7 @@
   public Response aggregateSearchRequest(
       @Context UriInfo uriInfo,
       @Context SecurityContext securityContext,
-      @Valid SearchRequest searchRequest)
+      @Valid SearchRequestInternal searchRequest)
       throws IOException {
     return searchRepository.aggregate(
         searchRequest.getIndex(),
Index: openmetadata-service/src/main/java/org/openmetadata/service/search/elasticsearch/ElasticSearchSourceBuilderFactory.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openmetadata-service/src/main/java/org/openmetadata/service/search/elasticsearch/ElasticSearchSourceBuilderFactory.java b/openmetadata-service/src/main/java/org/openmetadata/service/search/elasticsearch/ElasticSearchSourceBuilderFactory.java
--- a/openmetadata-service/src/main/java/org/openmetadata/service/search/elasticsearch/ElasticSearchSourceBuilderFactory.java	(revision d10bcccecad7a11724e8df23cf8c879f9f0673da)
+++ b/openmetadata-service/src/main/java/org/openmetadata/service/search/elasticsearch/ElasticSearchSourceBuilderFactory.java	(date 1744005109862)
@@ -1,26 +1,27 @@
 package org.openmetadata.service.search.elasticsearch;
 
 import static org.openmetadata.common.utils.CommonUtil.listOrEmpty;
+import static org.openmetadata.common.utils.CommonUtil.nullOrEmpty;
 import static org.openmetadata.service.search.EntityBuilderConstant.MAX_ANALYZED_OFFSET;
 import static org.openmetadata.service.search.EntityBuilderConstant.POST_TAG;
 import static org.openmetadata.service.search.EntityBuilderConstant.PRE_TAG;
 
-import es.org.elasticsearch.common.lucene.search.function.CombineFunction;
-import es.org.elasticsearch.common.lucene.search.function.FieldValueFactorFunction;
-import es.org.elasticsearch.common.lucene.search.function.FunctionScoreQuery;
-import es.org.elasticsearch.common.unit.Fuzziness;
-import es.org.elasticsearch.index.query.BoolQueryBuilder;
-import es.org.elasticsearch.index.query.MultiMatchQueryBuilder;
-import es.org.elasticsearch.index.query.Operator;
-import es.org.elasticsearch.index.query.QueryBuilder;
-import es.org.elasticsearch.index.query.QueryBuilders;
-import es.org.elasticsearch.index.query.QueryStringQueryBuilder;
-import es.org.elasticsearch.index.query.functionscore.FieldValueFactorFunctionBuilder;
-import es.org.elasticsearch.index.query.functionscore.FunctionScoreQueryBuilder;
-import es.org.elasticsearch.index.query.functionscore.ScoreFunctionBuilders;
-import es.org.elasticsearch.search.aggregations.AggregationBuilders;
-import es.org.elasticsearch.search.builder.SearchSourceBuilder;
-import es.org.elasticsearch.search.fetch.subphase.highlight.HighlightBuilder;
+import es.co.elastic.clients.elasticsearch._types.aggregations.AggregationBuilders;
+import es.co.elastic.clients.elasticsearch._types.query_dsl.BoolQuery;
+import es.co.elastic.clients.elasticsearch._types.query_dsl.FieldValueFactorModifier;
+import es.co.elastic.clients.elasticsearch._types.query_dsl.FieldValueFactorScoreFunction;
+import es.co.elastic.clients.elasticsearch._types.query_dsl.FunctionBoostMode;
+import es.co.elastic.clients.elasticsearch._types.query_dsl.FunctionScore;
+import es.co.elastic.clients.elasticsearch._types.query_dsl.FunctionScoreMode;
+import es.co.elastic.clients.elasticsearch._types.query_dsl.FunctionScoreQuery;
+import es.co.elastic.clients.elasticsearch._types.query_dsl.NumberRangeQuery;
+import es.co.elastic.clients.elasticsearch._types.query_dsl.Operator;
+import es.co.elastic.clients.elasticsearch._types.query_dsl.Query;
+import es.co.elastic.clients.elasticsearch._types.query_dsl.QueryBuilders;
+import es.co.elastic.clients.elasticsearch._types.query_dsl.TextQueryType;
+import es.co.elastic.clients.elasticsearch.core.SearchRequest;
+import es.co.elastic.clients.elasticsearch.core.search.Highlight;
+import es.co.elastic.clients.elasticsearch.core.search.HighlightField;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
@@ -31,37 +32,42 @@
 import org.openmetadata.schema.api.search.FieldValueBoost;
 import org.openmetadata.schema.api.search.SearchSettings;
 import org.openmetadata.schema.api.search.TermBoost;
+import org.openmetadata.service.search.SearchContext;
 import org.openmetadata.service.search.SearchSourceBuilderFactory;
+import org.openmetadata.service.search.aggregation.ESAggregation;
+import org.openmetadata.service.search.elasticsearch.queries.ElasticQueryBuilder;
+import org.openmetadata.service.search.highlight.OMHighlight;
 import org.openmetadata.service.search.indexes.*;
+import org.openmetadata.service.search.queries.OMQueryBuilder;
 
 public class ElasticSearchSourceBuilderFactory
     implements SearchSourceBuilderFactory<
-        SearchSourceBuilder, QueryBuilder, HighlightBuilder, FunctionScoreQueryBuilder> {
-
+        SearchContext, OMQueryBuilder, OMHighlight, FunctionScoreQuery.Builder> {
+  
   private final SearchSettings searchSettings;
+  private OMHighlight highlightBuilder;
 
   public ElasticSearchSourceBuilderFactory(SearchSettings searchSettings) {
     this.searchSettings = searchSettings;
   }
 
   @Override
-  public QueryStringQueryBuilder buildSearchQueryBuilder(String query, Map<String, Float> fields) {
-    return QueryBuilders.queryStringQuery(query)
-        .fields(fields)
-        .type(MultiMatchQueryBuilder.Type.MOST_FIELDS)
-        .defaultOperator(Operator.AND)
-        .fuzziness(Fuzziness.AUTO)
-        .fuzzyPrefixLength(3)
-        .tieBreaker(0.5f);
+  public OMQueryBuilder buildQuerySearchQuery(SearchContext context, String query, List<String> fields) {
+    return context.getQueryBuilder().queryStringQuery(query, fields, TextQueryType.MostFields.jsonValue(), 
+        Operator.And.jsonValue(), "auto", 3, 0.5d);
   }
 
   @Override
-  public SearchSourceBuilder searchBuilder(
-      QueryBuilder query, HighlightBuilder highlightBuilder, int from, int size) {
-    SearchSourceBuilder builder = new SearchSourceBuilder();
+  public SearchRequest.Builder searchBuilder(
+      SearchContext context,
+      Query query,
+      Highlight.Builder highlightBuilder,
+      int from,
+      int size) {
+    SearchRequest.Builder builder = new SearchRequest.Builder();
     builder.query(query);
     if (highlightBuilder != null) {
-      builder.highlighter(highlightBuilder);
+      builder.highlight(highlightBuilder.build());
     }
     builder.from(from);
     builder.size(size);
@@ -69,288 +75,292 @@
   }
 
   @Override
-  public SearchSourceBuilder buildUserOrTeamSearchBuilder(String query, int from, int size) {
-    QueryStringQueryBuilder queryBuilder = buildSearchQueryBuilder(query, UserIndex.getFields());
-    return searchBuilder(queryBuilder, null, from, size);
+  public SearchContext buildUserOrTeamSearchBuilder(SearchContext context, String query, int from, int size) {
+    OMQueryBuilder queryStringQuery =
+        buildQuerySearchQuery(context, query, UserIndex.getFieldsWithWeights().stream().toList());
+    return searchBuilder(queryStringQuery, null, from, size);
   }
 
-  private SearchSourceBuilder addAggregation(SearchSourceBuilder searchSourceBuilder) {
+  private SearchRequest.Builder addAggregation(SearchContext context, SearchRequest.Builder searchSourceBuilder) {
     searchSettings
         .getGlobalSettings()
         .getAggregations()
         .forEach(
             agg ->
-                searchSourceBuilder.aggregation(
-                    AggregationBuilders.terms(agg.getName())
+                    context.getAggregationBuilder().addAggregation(agg.getName(), new ESAggregation())
+                searchSourceBuilder.aggregations(
+                    agg.getName(),
+                    AggregationBuilders.terms()
                         .field(agg.getField())
-                        .size(searchSettings.getGlobalSettings().getMaxAggregateSize())));
+                        .size(searchSettings.getGlobalSettings().getMaxAggregateSize())
+                        .build()
+                        ._toAggregation()));
     return searchSourceBuilder;
   }
 
   @Override
-  public SearchSourceBuilder buildTestCaseSearch(String query, int from, int size) {
-    QueryStringQueryBuilder queryBuilder =
-        buildSearchQueryBuilder(query, TestCaseIndex.getFields());
-    HighlightBuilder hb = buildHighlights(List.of("testSuite.name", "testSuite.description"));
-    return searchBuilder(queryBuilder, hb, from, size);
+  public SearchContext buildTestCaseSearch(SearchContext context, String query, int from, int size) {
+    OMQueryBuilder queryStringQuery =
+        buildQuerySearchQuery(context, query, TestCaseIndex.getFieldsWithWeights().stream().toList());
+    context.setQuery(queryStringQuery);
+    context.setHighlightBuilder(highlightBuilder.buildHighlights(List.of("testSuite.name", "testSuite.description")));
+    return context;
+    return searchBuilder(queryStringQuery, hb, from, size);
   }
 
   @Override
-  public SearchSourceBuilder buildCostAnalysisReportDataSearch(String query, int from, int size) {
-    QueryStringQueryBuilder queryBuilder = QueryBuilders.queryStringQuery(query);
-    return searchBuilder(queryBuilder, null, from, size);
+  public SearchContext buildCostAnalysisReportDataSearch(SearchContext context, String query, int from, int size) {
+    OMQueryBuilder queryStringQuery =
+            queryBuilderFactory.queryStringQuery(
+                    query,
+                    null,
+                    null,
+                    null,
+                    null,
+                    0,
+                    0.0d);
+    context.setQuery(queryStringQuery);
+    return context;
   }
 
   @Override
-  public SearchSourceBuilder buildTestCaseResolutionStatusSearch(String query, int from, int size) {
-    QueryStringQueryBuilder queryBuilder =
-        buildSearchQueryBuilder(query, TestCaseResolutionStatusIndex.getFields());
-    HighlightBuilder hb = buildHighlights(new ArrayList<>());
-    return searchBuilder(queryBuilder, hb, from, size);
+  public SearchContext buildTestCaseResolutionStatusSearch(SearchContext context,
+                                                           String query, int from, int size) {
+    OMQueryBuilder queryStringQuery = buildQuerySearchQuery(context, query, TestCaseResolutionStatusIndex.getFieldsWithWeights().stream().toList());
+    context.setQuery(queryStringQuery);
+    context.setHighlightBuilder(highlightBuilder.buildHighlights(new ArrayList<>()));
+    return context;
   }
 
   @Override
-  public SearchSourceBuilder buildTestCaseResultSearch(String query, int from, int size) {
-    QueryStringQueryBuilder queryBuilder =
-        buildSearchQueryBuilder(query, TestCaseResultIndex.getFields());
-    HighlightBuilder hb = buildHighlights(new ArrayList<>());
-    return searchBuilder(queryBuilder, hb, from, size);
+  public SearchContext buildTestCaseResultSearch(
+          SearchContext context, String query, int from, int size) {
+    OMQueryBuilder queryStringQuery = buildQuerySearchQuery(context, query, TestCaseResultIndex.getFieldsWithWeights().stream().toList());
+    context.setQuery(queryStringQuery);
+    context.setHighlightBuilder(highlightBuilder.buildHighlights(new ArrayList<>()));
+    return context;
   }
 
   @Override
-  public SearchSourceBuilder buildServiceSearchBuilder(String query, int from, int size) {
-    QueryStringQueryBuilder queryBuilder =
-        buildSearchQueryBuilder(query, SearchIndex.getDefaultFields());
-    HighlightBuilder hb = buildHighlights(new ArrayList<>());
-    return searchBuilder(queryBuilder, hb, from, size);
+  public SearchContext buildServiceSearchBuilder(SearchContext context, String query, int from, int size) {
+    OMQueryBuilder queryStringQuery  =
+            buildQuerySearchQuery(context, query, SearchIndex.getDefaultFields().stream().toList());
+    context.setQuery(queryStringQuery);
+    context.setHighlightBuilder(highlightBuilder.buildHighlights(new ArrayList<>()));
+    return context;
   }
 
   @Override
-  public SearchSourceBuilder buildAggregateSearchBuilder(String query, int from, int size) {
-    QueryStringQueryBuilder queryBuilder =
-        QueryBuilders.queryStringQuery(query)
-            .fields(SearchIndex.getAllFields())
-            .fuzziness(Fuzziness.AUTO);
-    SearchSourceBuilder searchSourceBuilder = searchBuilder(queryBuilder, null, from, size);
+  public SearchContext buildAggregateSearchBuilder(SearchContext context, String query, int from, int size) {
+    OMQueryBuilder queryStringQuery = buildQuerySearchQuery(context, query, SearchIndex.getAllFields().stream().toList());
+    SearchRequest.Builder searchSourceBuilder = searchBuilder(queryStringQuery, null, from, size);
     return addAggregation(searchSourceBuilder);
   }
 
   @Override
-  public SearchSourceBuilder buildDataAssetSearchBuilder(
-      String indexName, String query, int from, int size) {
+  public SearchContext buildDataAssetSearchBuilder(SearchContext context,
+                                                   String indexName, String query, int from, int size) {
+
     AssetTypeConfiguration assetConfig = findAssetTypeConfig(indexName, searchSettings);
-    Map<String, Float> fields;
-    if (assetConfig.getSearchFields() != null && !assetConfig.getSearchFields().isEmpty()) {
-      fields = new HashMap<>();
-      assetConfig
-          .getSearchFields()
-          .forEach(
-              fieldBoost -> fields.put(fieldBoost.getField(), fieldBoost.getBoost().floatValue()));
-    } else {
-      fields = SearchIndex.getDefaultFields();
-    }
-    BoolQueryBuilder baseQuery = QueryBuilders.boolQuery();
+    List<String> fields =
+        assetConfig.getSearchFields() != null && !assetConfig.getSearchFields().isEmpty()
+            ? assetConfig.getSearchFields().stream()
+                .map(fieldBoost -> fieldBoost.getField() + "^" + fieldBoost.getBoost().floatValue())
+                .toList()
+            : SearchIndex.getDefaultFields().stream().toList();
+
+    OMQueryBuilder baseQuery = queryBuilderFactory.boolQuery();
 
     if (query == null || query.trim().isEmpty() || query.trim().equals("*")) {
-      baseQuery.must(QueryBuilders.matchAllQuery());
+      baseQuery.must(queryBuilderFactory.matchAllQuery());
     } else if (containsQuerySyntax(query)) {
-      QueryStringQueryBuilder queryStringBuilder =
-          QueryBuilders.queryStringQuery(query)
-              .fields(fields)
-              .defaultOperator(Operator.AND)
-              .type(MultiMatchQueryBuilder.Type.MOST_FIELDS)
-              .fuzziness(Fuzziness.AUTO)
-              .fuzzyPrefixLength(1)
-              .tieBreaker(0.3f);
-
-      baseQuery.must(queryStringBuilder);
+      OMQueryBuilder queryStringQuery =
+          queryBuilderFactory.queryStringQuery(
+              query, fields, Operator.And.jsonValue(), "auto", 1, 0.3d);
+      baseQuery.must(queryStringQuery);
     } else {
-      MultiMatchQueryBuilder multiMatchQueryBuilder =
-          QueryBuilders.multiMatchQuery(query)
-              .type(MultiMatchQueryBuilder.Type.MOST_FIELDS)
-              .fuzziness(Fuzziness.AUTO)
-              .prefixLength(1)
-              .operator(Operator.AND)
-              .tieBreaker(0.3f);
-
-      for (Map.Entry<String, Float> fieldEntry : fields.entrySet()) {
-        String fieldName = fieldEntry.getKey();
-        Float boost = fieldEntry.getValue();
-        multiMatchQueryBuilder.field(fieldName, boost);
-      }
+      OMQueryBuilder multiMatchQuery =
+          queryBuilderFactory.multiMatchQuery(
+              query,
+              fields,
+              Operator.And.jsonValue(),
+              TextQueryType.MostFields.jsonValue(),
+              "AUTO",
+              1,
+              0.3d);
+      baseQuery.must(multiMatchQuery);
+    }
 
-      baseQuery.must(multiMatchQueryBuilder);
-    }
+    List<FunctionScore> functions = new ArrayList<>();
+    searchSettings
+        .getGlobalSettings()
+        .getTermBoosts()
+        .forEach(tb -> functions.add(buildTermBoostFunction(tb)));
+    assetConfig.getTermBoosts().forEach(tb -> functions.add(buildTermBoostFunction(tb)));
+    searchSettings
+        .getGlobalSettings()
+        .getFieldValueBoosts()
+        .forEach(fvb -> functions.add(buildFieldValueBoostFunction(fvb)));
+    assetConfig
+        .getFieldValueBoosts()
+        .forEach(fvb -> functions.add(buildFieldValueBoostFunction(fvb)));
 
-    List<FunctionScoreQueryBuilder.FilterFunctionBuilder> functions = new ArrayList<>();
-    if (searchSettings.getGlobalSettings().getTermBoosts() != null) {
-      for (TermBoost tb : searchSettings.getGlobalSettings().getTermBoosts()) {
-        functions.add(buildTermBoostFunction(tb));
-      }
-    }
-    if (assetConfig.getTermBoosts() != null) {
-      for (TermBoost tb : assetConfig.getTermBoosts()) {
-        functions.add(buildTermBoostFunction(tb));
-      }
-    }
-    if (searchSettings.getGlobalSettings().getFieldValueBoosts() != null) {
-      for (FieldValueBoost fvb : searchSettings.getGlobalSettings().getFieldValueBoosts()) {
-        functions.add(buildFieldValueBoostFunction(fvb));
-      }
-    }
-    if (assetConfig.getFieldValueBoosts() != null) {
-      for (FieldValueBoost fvb : assetConfig.getFieldValueBoosts()) {
-        functions.add(buildFieldValueBoostFunction(fvb));
-      }
-    }
-
-    QueryBuilder finalQuery = baseQuery;
+    // TODO: fix this
+    Query finalQuery = ((ElasticQueryBuilder) baseQuery).build();
     if (!functions.isEmpty()) {
-      float functionBoostFactor = 0.3f;
-      FunctionScoreQueryBuilder functionScore =
-          QueryBuilders.functionScoreQuery(
-              baseQuery, functions.toArray(new FunctionScoreQueryBuilder.FilterFunctionBuilder[0]));
-
-      if (assetConfig.getScoreMode() != null) {
-        functionScore.scoreMode(toScoreMode(assetConfig.getScoreMode().value()));
-      } else {
-        functionScore.scoreMode(FunctionScoreQuery.ScoreMode.SUM);
-      }
-
-      if (assetConfig.getBoostMode() != null) {
-        functionScore.boostMode(toCombineFunction(assetConfig.getBoostMode().value()));
-      } else {
-        functionScore.boostMode(CombineFunction.SUM);
-      }
-      BoolQueryBuilder combinedQuery = QueryBuilders.boolQuery();
-      combinedQuery.must(baseQuery);
-      combinedQuery.should(functionScore.boost(functionBoostFactor));
+      FunctionScoreQuery.Builder functionScoreQuery =
+          new FunctionScoreQuery.Builder()
+              .query(finalQuery)
+              .functions(functions)
+              .scoreMode(toScoreMode(assetConfig.getScoreMode().value()))
+              .boostMode(toCombineFunction(assetConfig.getBoostMode().value()));
 
-      finalQuery = combinedQuery;
+      finalQuery = new Query.Builder().functionScore(functionScoreQuery.build()).build();
     }
 
-    HighlightBuilder highlightBuilder = null;
+    Highlight highlight = null;
     if (query != null && !query.trim().isEmpty()) {
-      if (assetConfig.getHighlightFields() != null && !assetConfig.getHighlightFields().isEmpty()) {
-        highlightBuilder = buildHighlights(assetConfig.getHighlightFields());
-      } else if (searchSettings.getGlobalSettings().getHighlightFields() != null) {
-        highlightBuilder = buildHighlights(searchSettings.getGlobalSettings().getHighlightFields());
+      List<String> highlightFields =
+          assetConfig.getHighlightFields() != null
+              ? assetConfig.getHighlightFields()
+              : searchSettings.getGlobalSettings().getHighlightFields();
+      if (highlightFields != null && !highlightFields.isEmpty()) {
+        Highlight.Builder highlightBuilder = new Highlight.Builder();
+        highlightFields.forEach(
+            field -> highlightBuilder.fields(field, new HighlightField.Builder().build()));
+        highlight = highlightBuilder.build();
       }
     }
 
-    SearchSourceBuilder searchSourceBuilder =
-        new SearchSourceBuilder()
-            .query(finalQuery)
-            .from(Math.min(from, searchSettings.getGlobalSettings().getMaxResultHits()))
-            .size(Math.min(size, searchSettings.getGlobalSettings().getMaxResultHits()));
-
-    if (highlightBuilder != null) {
-      searchSourceBuilder.highlighter(highlightBuilder);
-    }
+    return new SearchRequest.Builder()
+        .index(indexName)
+        .query(finalQuery)
+        .from(Math.min(from, searchSettings.getGlobalSettings().getMaxResultHits()))
+        .size(Math.min(size, searchSettings.getGlobalSettings().getMaxResultHits()))
+        .highlight(highlight)
+        .explain(true);
+  }
 
-    addConfiguredAggregations(searchSourceBuilder, assetConfig);
-    searchSourceBuilder.explain(true);
-    return searchSourceBuilder;
+  private FunctionScore buildTermBoostFunction(TermBoost tb) {
+    return new FunctionScore.Builder()
+        .filter(f -> f.term(t -> t.field(tb.getField()).value(tb.getValue())))
+        .weight(tb.getBoost())
+        .build();
   }
 
-  private FunctionScoreQueryBuilder.FilterFunctionBuilder buildTermBoostFunction(TermBoost tb) {
-    return new FunctionScoreQueryBuilder.FilterFunctionBuilder(
-        QueryBuilders.termQuery(tb.getField(), tb.getValue()),
-        ScoreFunctionBuilders.weightFactorFunction(tb.getBoost().floatValue()));
-  }
-
-  private FunctionScoreQueryBuilder.FilterFunctionBuilder buildFieldValueBoostFunction(
-      FieldValueBoost fvb) {
-    QueryBuilder condition = QueryBuilders.matchAllQuery();
+  private FunctionScore buildFieldValueBoostFunction(FieldValueBoost fvb) {
+    BoolQuery.Builder condition =
+        new BoolQuery.Builder().must(QueryBuilders.matchAll().build()._toQuery());
     if (fvb.getCondition() != null && fvb.getCondition().getRange() != null) {
-      BoolQueryBuilder rangeQuery = QueryBuilders.boolQuery();
+      BoolQuery.Builder rangeQuery = QueryBuilders.bool();
       if (fvb.getCondition().getRange().getGt() != null) {
         rangeQuery.filter(
-            QueryBuilders.rangeQuery(fvb.getField()).gt(fvb.getCondition().getRange().getGt()));
+            new NumberRangeQuery.Builder()
+                .field(fvb.getField())
+                .gt(fvb.getCondition().getRange().getGt())
+                .build()
+                ._toRangeQuery()
+                ._toQuery());
       }
       if (fvb.getCondition().getRange().getGte() != null) {
         rangeQuery.filter(
-            QueryBuilders.rangeQuery(fvb.getField()).gte(fvb.getCondition().getRange().getGte()));
+            new NumberRangeQuery.Builder()
+                .field(fvb.getField())
+                .gte(fvb.getCondition().getRange().getGte())
+                .build()
+                ._toRangeQuery()
+                ._toQuery());
       }
       if (fvb.getCondition().getRange().getLt() != null) {
         rangeQuery.filter(
-            QueryBuilders.rangeQuery(fvb.getField()).lt(fvb.getCondition().getRange().getLt()));
+            new NumberRangeQuery.Builder()
+                .field(fvb.getField())
+                .lt(fvb.getCondition().getRange().getLt())
+                .build()
+                ._toRangeQuery()
+                ._toQuery());
       }
       if (fvb.getCondition().getRange().getLte() != null) {
         rangeQuery.filter(
-            QueryBuilders.rangeQuery(fvb.getField()).lte(fvb.getCondition().getRange().getLte()));
+            new NumberRangeQuery.Builder()
+                .field(fvb.getField())
+                .lte(fvb.getCondition().getRange().getLte())
+                .build()
+                ._toRangeQuery()
+                ._toQuery());
       }
       condition = rangeQuery;
     }
 
-    FieldValueFactorFunctionBuilder factorBuilder =
-        ScoreFunctionBuilders.fieldValueFactorFunction(fvb.getField())
-            .factor(fvb.getFactor().floatValue())
-            .missing(fvb.getMissing() == null ? 0.0f : fvb.getMissing().floatValue());
+    FieldValueFactorScoreFunction.Builder factorBuilder =
+        new FieldValueFactorScoreFunction.Builder()
+            .field(fvb.getField())
+            .factor(fvb.getFactor())
+            .missing(fvb.getMissing() == null ? 0.0f : fvb.getMissing());
 
     if (fvb.getModifier() != null) {
-      switch (fvb.getModifier().value()) {
-        case "log":
-          factorBuilder.modifier(FieldValueFactorFunction.Modifier.LOG);
-          break;
-        case "log1p":
-          try {
-            factorBuilder.modifier(FieldValueFactorFunction.Modifier.LOG1P);
-          } catch (NoSuchFieldError e) {
-            factorBuilder.modifier(FieldValueFactorFunction.Modifier.LOG);
-          }
-          break;
-        case "sqrt":
-          try {
-            factorBuilder.modifier(FieldValueFactorFunction.Modifier.SQRT);
-          } catch (NoSuchFieldError ignored) {
-          }
-          break;
-        default:
-          break;
-      }
-    }
-    return new FunctionScoreQueryBuilder.FilterFunctionBuilder(condition, factorBuilder);
+      factorBuilder.modifier(toModifier(fvb.getModifier().value()));
+    }
+    return new FunctionScore.Builder()
+        .filter(condition.build()._toQuery())
+        .fieldValueFactor(factorBuilder.build())
+        .build();
+  }
+
+  private FieldValueFactorModifier toModifier(String value) {
+    return switch (value) {
+      case "log" -> FieldValueFactorModifier.Log;
+      case "log1p" -> FieldValueFactorModifier.Log1p;
+      case "sqrt" -> FieldValueFactorModifier.Sqrt;
+      default -> null;
+    };
   }
 
-  private FunctionScoreQuery.ScoreMode toScoreMode(String mode) {
+  private FunctionScoreMode toScoreMode(String mode) {
+    if (nullOrEmpty(mode)) {
+      return FunctionScoreMode.Sum;
+    }
     return switch (mode.toLowerCase()) {
-      case "avg" -> FunctionScoreQuery.ScoreMode.AVG;
-      case "max" -> FunctionScoreQuery.ScoreMode.MAX;
-      case "min" -> FunctionScoreQuery.ScoreMode.MIN;
-      case "multiply" -> FunctionScoreQuery.ScoreMode.MULTIPLY;
-      case "first" -> FunctionScoreQuery.ScoreMode.FIRST;
-      default -> FunctionScoreQuery.ScoreMode.SUM;
+      case "avg" -> FunctionScoreMode.Avg;
+      case "max" -> FunctionScoreMode.Max;
+      case "min" -> FunctionScoreMode.Min;
+      case "multiply" -> FunctionScoreMode.Multiply;
+      case "first" -> FunctionScoreMode.First;
+      default -> FunctionScoreMode.Sum;
     };
   }
 
-  private CombineFunction toCombineFunction(String mode) {
+  private FunctionBoostMode toCombineFunction(String mode) {
+    if (nullOrEmpty(mode)) {
+      return FunctionBoostMode.Sum;
+    }
     return switch (mode.toLowerCase()) {
-      case "sum" -> CombineFunction.SUM;
-      case "avg" -> CombineFunction.AVG;
-      case "max" -> CombineFunction.MAX;
-      case "min" -> CombineFunction.MIN;
-      case "replace" -> CombineFunction.REPLACE;
-      default -> CombineFunction.MULTIPLY;
+      case "sum" -> FunctionBoostMode.Sum;
+      case "avg" -> FunctionBoostMode.Avg;
+      case "max" -> FunctionBoostMode.Max;
+      case "min" -> FunctionBoostMode.Min;
+      case "replace" -> FunctionBoostMode.Replace;
+      default -> FunctionBoostMode.Multiply;
     };
   }
 
-  public HighlightBuilder buildHighlights(List<String> fields) {
-    HighlightBuilder hb = new HighlightBuilder();
+  public Highlight.Builder buildHighlights(List<String> fields) {
+    Highlight.Builder hb = new Highlight.Builder();
     hb.preTags(PRE_TAG);
     hb.postTags(POST_TAG);
     hb.maxAnalyzedOffset(MAX_ANALYZED_OFFSET);
     hb.requireFieldMatch(false);
-    for (String field : fields) {
-      HighlightBuilder.Field highlightField = new HighlightBuilder.Field(field);
-      highlightField.highlighterType("unified");
-      hb.field(highlightField);
-    }
+    Map<String, HighlightField> highlightFields =
+        fields.stream()
+            .collect(
+                Collectors.toMap(
+                    field -> field, field -> HighlightField.of(hf -> hf.type("unified"))));
+    hb.fields(highlightFields);
     return hb;
   }
 
   private void addConfiguredAggregations(
-      SearchSourceBuilder searchSourceBuilder, AssetTypeConfiguration assetConfig) {
+      SearchRequest.Builder searchSourceBuilder, AssetTypeConfiguration assetConfig) {
     Map<String, Aggregation> aggregations = new HashMap<>();
 
     // Add asset type aggregations
@@ -364,33 +374,36 @@
 
     for (var entry : aggregations.entrySet()) {
       Aggregation agg = entry.getValue();
-      searchSourceBuilder.aggregation(
-          AggregationBuilders.terms(agg.getName())
+      searchSourceBuilder.aggregations(
+          agg.getName(),
+          AggregationBuilders.terms()
               .field(agg.getField())
-              .size(searchSettings.getGlobalSettings().getMaxAggregateSize()));
+              .size(searchSettings.getGlobalSettings().getMaxAggregateSize())
+              .build()
+              ._toAggregation());
     }
   }
 
   @Override
-  public SearchSourceBuilder buildTimeSeriesSearchBuilder(
-      String indexName, String query, int from, int size) {
+  public SearchContext buildTimeSeriesSearchBuilder(
+          SearchContext context, String indexName, String query, int from, int size) {
     return switch (indexName) {
-      case "test_case_result_search_index" -> buildTestCaseResultSearch(query, from, size);
-      case "test_case_resolution_status_search_index" -> buildTestCaseResolutionStatusSearch(
+      case "test_case_result_search_index" -> buildTestCaseResultSearch(context, query, from, size);
+      case "test_case_resolution_status_search_index" -> buildTestCaseResolutionStatusSearch(context,
           query, from, size);
       case "raw_cost_analysis_report_data_index",
-          "aggregated_cost_analysis_report_data_index" -> buildCostAnalysisReportDataSearch(
+          "aggregated_cost_analysis_report_data_index" -> buildCostAnalysisReportDataSearch(context, 
           query, from, size);
-      default -> buildAggregateSearchBuilder(query, from, size);
+      default -> buildAggregateSearchBuilder(context, query, from, size);
     };
   }
 
   @Override
-  public SearchSourceBuilder buildCommonSearchBuilder(String query, int from, int size) {
-    QueryStringQueryBuilder queryStringBuilder =
+  public SearchRequest.Builder buildCommonSearchBuilder(String query, int from, int size) {
+    Query queryStringQuery =
         buildSearchQueryBuilder(query, getAllSearchFieldsFromSettings(searchSettings));
 
-    List<FunctionScoreQueryBuilder.FilterFunctionBuilder> functions = new ArrayList<>();
+    List<FunctionScore> functions = new ArrayList<>();
 
     // Add global term boosts
     if (searchSettings.getGlobalSettings().getTermBoosts() != null) {
@@ -406,27 +419,27 @@
       }
     }
 
-    QueryBuilder finalQuery = queryStringBuilder;
+    BoolQuery.Builder finalQuery = new BoolQuery.Builder().must(queryStringQuery);
     if (!functions.isEmpty()) {
-      FunctionScoreQueryBuilder functionScore =
-          QueryBuilders.functionScoreQuery(
-              queryStringBuilder,
-              functions.toArray(new FunctionScoreQueryBuilder.FilterFunctionBuilder[0]));
-      functionScore.scoreMode(FunctionScoreQuery.ScoreMode.SUM);
-      functionScore.boostMode(CombineFunction.MULTIPLY);
-      finalQuery = functionScore;
+      FunctionScoreQuery.Builder functionScoreQuery =
+          new FunctionScoreQuery.Builder()
+              .query(finalQuery.build()._toQuery())
+              .functions(functions)
+              .boostMode(FunctionBoostMode.Multiply)
+              .scoreMode(FunctionScoreMode.Sum);
+      finalQuery = new BoolQuery.Builder().must(functionScoreQuery.build()._toQuery());
     }
 
-    SearchSourceBuilder searchSourceBuilder =
-        new SearchSourceBuilder()
-            .query(finalQuery)
+    SearchRequest.Builder searchSourceBuilder =
+        new SearchRequest.Builder()
+            .query(finalQuery.build()._toQuery())
             .from(Math.min(from, searchSettings.getGlobalSettings().getMaxResultHits()))
             .size(Math.min(size, searchSettings.getGlobalSettings().getMaxResultHits()));
 
     // Add global highlight fields if configured
     if (searchSettings.getGlobalSettings().getHighlightFields() != null) {
-      searchSourceBuilder.highlighter(
-          buildHighlights(searchSettings.getGlobalSettings().getHighlightFields()));
+      searchSourceBuilder.highlight(
+          buildHighlights(searchSettings.getGlobalSettings().getHighlightFields()).build());
     }
 
     // Add specific data asset aggregations
@@ -436,8 +449,8 @@
   }
 
   // Add this new method for applying aggregations to NLQ queries
-  public SearchSourceBuilder addAggregationsToNLQQuery(
-      SearchSourceBuilder searchSourceBuilder, String indexName) {
+  public SearchRequest.Builder addAggregationsToNLQQuery(
+      SearchRequest.Builder searchSourceBuilder, String indexName) {
     // Find the appropriate asset type configuration
     AssetTypeConfiguration assetConfig = findAssetTypeConfig(indexName, searchSettings);
 
Index: openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/QueryIndex.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/QueryIndex.java b/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/QueryIndex.java
--- a/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/QueryIndex.java	(revision d10bcccecad7a11724e8df23cf8c879f9f0673da)
+++ b/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/QueryIndex.java	(date 1744005110059)
@@ -3,15 +3,28 @@
 import static org.openmetadata.service.Entity.QUERY;
 import static org.openmetadata.service.search.EntityBuilderConstant.QUERY_NGRAM;
 
+import co.elastic.clients.elasticsearch.core.SearchRequest;
 import java.util.ArrayList;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 import org.openmetadata.schema.entity.data.Query;
 import org.openmetadata.service.Entity;
 import org.openmetadata.service.search.ParseTags;
 import org.openmetadata.service.search.models.SearchSuggest;
 
 public class QueryIndex implements SearchIndex {
+  public static final Set<String> FIELDS_WITH_WEIGHT = new HashSet<>();
+  public static final Set<String> HIGHLIGHT_FIELDS = new HashSet<>();
+
+  static {
+    Set<String> fields = SearchIndex.getDefaultFields();
+    fields.add(String.format("%s^10", QUERY));
+    fields.add(String.format("%s^1", QUERY_NGRAM));
+    FIELDS_WITH_WEIGHT.addAll(fields);
+  }
+
   final Query query;
 
   public QueryIndex(Query query) {
@@ -41,10 +54,26 @@
     return doc;
   }
 
-  public static Map<String, Float> getFields() {
-    Map<String, Float> fields = SearchIndex.getDefaultFields();
-    fields.put(QUERY, 10.0f);
-    fields.put(QUERY_NGRAM, 1.0f);
-    return fields;
+  public static Set<String> getHighLightFields() {
+    return HIGHLIGHT_FIELDS;
+  }
+
+  public static Set<String> getFieldsWithWeights() {
+    return FIELDS_WITH_WEIGHT;
+  }
+
+  public static SearchRequest.Builder addEsEntityAggregation(SearchRequest.Builder requestBuilder) {
+    // add Base Aggregations for ElasticSearch
+    SearchIndex.addBaseElasticSearchAggregation(requestBuilder);
+    return requestBuilder;
+  }
+
+  public static os.org.opensearch.client.opensearch.core.SearchRequest.Builder
+      addOsEntityAggregation(
+          os.org.opensearch.client.opensearch.core.SearchRequest.Builder requestBuilder) {
+
+    // add Base Aggregations for OpenSearch
+    SearchIndex.addBaseOpenSearchAggregation(requestBuilder);
+    return requestBuilder;
   }
 }
Index: openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/DataProductIndex.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/DataProductIndex.java b/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/DataProductIndex.java
--- a/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/DataProductIndex.java	(revision d10bcccecad7a11724e8df23cf8c879f9f0673da)
+++ b/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/DataProductIndex.java	(date 1744005110064)
@@ -1,14 +1,24 @@
 package org.openmetadata.service.search.indexes;
 
+import co.elastic.clients.elasticsearch.core.SearchRequest;
 import java.util.ArrayList;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 import org.openmetadata.schema.entity.domains.DataProduct;
 import org.openmetadata.service.Entity;
 import org.openmetadata.service.search.ParseTags;
 import org.openmetadata.service.search.models.SearchSuggest;
 
 public record DataProductIndex(DataProduct dataProduct) implements SearchIndex {
+  public static final Set<String> FIELDS_WITH_WEIGHT = new HashSet<>();
+  public static final Set<String> HIGHLIGHT_FIELDS = new HashSet<>();
+
+  static {
+    FIELDS_WITH_WEIGHT.addAll(SearchIndex.getDefaultFields());
+  }
+
   @Override
   public List<SearchSuggest> getSuggest() {
     List<SearchSuggest> suggest = new ArrayList<>();
@@ -32,7 +42,26 @@
     return doc;
   }
 
-  public static Map<String, Float> getFields() {
-    return SearchIndex.getDefaultFields();
+  public static Set<String> getHighLightFields() {
+    return HIGHLIGHT_FIELDS;
+  }
+
+  public static Set<String> getFieldsWithWeights() {
+    return FIELDS_WITH_WEIGHT;
+  }
+
+  public static SearchRequest.Builder addEsEntityAggregation(SearchRequest.Builder requestBuilder) {
+    // add Base Aggregations for ElasticSearch
+    SearchIndex.addBaseElasticSearchAggregation(requestBuilder);
+    return requestBuilder;
+  }
+
+  public static os.org.opensearch.client.opensearch.core.SearchRequest.Builder
+      addOsEntityAggregation(
+          os.org.opensearch.client.opensearch.core.SearchRequest.Builder requestBuilder) {
+
+    // add Base Aggregations for OpenSearch
+    SearchIndex.addBaseOpenSearchAggregation(requestBuilder);
+    return requestBuilder;
   }
 }
Index: openmetadata-service/src/main/java/org/openmetadata/service/search/elasticsearch/ElasticSearchClient.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openmetadata-service/src/main/java/org/openmetadata/service/search/elasticsearch/ElasticSearchClient.java b/openmetadata-service/src/main/java/org/openmetadata/service/search/elasticsearch/ElasticSearchClient.java
--- a/openmetadata-service/src/main/java/org/openmetadata/service/search/elasticsearch/ElasticSearchClient.java	(revision d10bcccecad7a11724e8df23cf8c879f9f0673da)
+++ b/openmetadata-service/src/main/java/org/openmetadata/service/search/elasticsearch/ElasticSearchClient.java	(date 1744005109918)
@@ -12,7 +12,6 @@
 import static org.openmetadata.service.Entity.TABLE;
 import static org.openmetadata.service.events.scheduled.ServicesStatusJobHandler.HEALTHY_STATUS;
 import static org.openmetadata.service.events.scheduled.ServicesStatusJobHandler.UNHEALTHY_STATUS;
-import static org.openmetadata.service.exception.CatalogGenericExceptionMapper.getResponse;
 import static org.openmetadata.service.search.EntityBuilderConstant.MAX_AGGREGATE_SIZE;
 import static org.openmetadata.service.search.EntityBuilderConstant.MAX_RESULT_HITS;
 import static org.openmetadata.service.search.SearchConstants.SENDING_REQUEST_TO_ELASTIC_SEARCH;
@@ -23,81 +22,25 @@
 import static org.openmetadata.service.search.elasticsearch.ElasticSearchEntitiesProcessor.getUpdateRequest;
 import static org.openmetadata.service.util.FullyQualifiedName.getParentFQN;
 
-import com.fasterxml.jackson.databind.JsonNode;
-import es.org.elasticsearch.ElasticsearchStatusException;
-import es.org.elasticsearch.action.ActionListener;
-import es.org.elasticsearch.action.admin.cluster.health.ClusterHealthRequest;
-import es.org.elasticsearch.action.admin.cluster.health.ClusterHealthResponse;
-import es.org.elasticsearch.action.admin.indices.alias.IndicesAliasesRequest;
-import es.org.elasticsearch.action.admin.indices.delete.DeleteIndexRequest;
-import es.org.elasticsearch.action.bulk.BulkRequest;
-import es.org.elasticsearch.action.bulk.BulkResponse;
-import es.org.elasticsearch.action.delete.DeleteRequest;
-import es.org.elasticsearch.action.get.GetRequest;
-import es.org.elasticsearch.action.get.GetResponse;
-import es.org.elasticsearch.action.index.IndexRequest;
-import es.org.elasticsearch.action.search.SearchResponse;
-import es.org.elasticsearch.action.support.WriteRequest;
-import es.org.elasticsearch.action.support.master.AcknowledgedResponse;
-import es.org.elasticsearch.action.update.UpdateRequest;
-import es.org.elasticsearch.client.RequestOptions;
-import es.org.elasticsearch.client.RestClient;
-import es.org.elasticsearch.client.RestClientBuilder;
-import es.org.elasticsearch.client.RestHighLevelClient;
-import es.org.elasticsearch.client.RestHighLevelClientBuilder;
-import es.org.elasticsearch.client.indices.CreateIndexRequest;
-import es.org.elasticsearch.client.indices.CreateIndexResponse;
-import es.org.elasticsearch.client.indices.GetIndexRequest;
-import es.org.elasticsearch.client.indices.GetMappingsRequest;
-import es.org.elasticsearch.client.indices.GetMappingsResponse;
-import es.org.elasticsearch.client.indices.PutMappingRequest;
-import es.org.elasticsearch.cluster.health.ClusterHealthStatus;
-import es.org.elasticsearch.cluster.metadata.MappingMetadata;
-import es.org.elasticsearch.common.unit.Fuzziness;
-import es.org.elasticsearch.common.xcontent.LoggingDeprecationHandler;
-import es.org.elasticsearch.core.TimeValue;
-import es.org.elasticsearch.index.query.BoolQueryBuilder;
-import es.org.elasticsearch.index.query.MatchQueryBuilder;
-import es.org.elasticsearch.index.query.Operator;
-import es.org.elasticsearch.index.query.PrefixQueryBuilder;
-import es.org.elasticsearch.index.query.QueryBuilder;
-import es.org.elasticsearch.index.query.QueryBuilders;
-import es.org.elasticsearch.index.query.QueryStringQueryBuilder;
-import es.org.elasticsearch.index.query.RangeQueryBuilder;
-import es.org.elasticsearch.index.query.ScriptQueryBuilder;
-import es.org.elasticsearch.index.query.TermQueryBuilder;
-import es.org.elasticsearch.index.reindex.DeleteByQueryRequest;
-import es.org.elasticsearch.index.reindex.UpdateByQueryRequest;
-import es.org.elasticsearch.rest.RestStatus;
-import es.org.elasticsearch.script.Script;
-import es.org.elasticsearch.script.ScriptType;
-import es.org.elasticsearch.search.SearchHit;
-import es.org.elasticsearch.search.SearchHits;
-import es.org.elasticsearch.search.aggregations.AggregationBuilder;
-import es.org.elasticsearch.search.aggregations.AggregationBuilders;
-import es.org.elasticsearch.search.aggregations.BucketOrder;
-import es.org.elasticsearch.search.aggregations.bucket.histogram.DateHistogramAggregationBuilder;
-import es.org.elasticsearch.search.aggregations.bucket.histogram.DateHistogramInterval;
-import es.org.elasticsearch.search.aggregations.bucket.terms.IncludeExclude;
-import es.org.elasticsearch.search.aggregations.bucket.terms.Terms;
-import es.org.elasticsearch.search.aggregations.bucket.terms.TermsAggregationBuilder;
-import es.org.elasticsearch.search.aggregations.metrics.MaxAggregationBuilder;
-import es.org.elasticsearch.search.aggregations.metrics.SumAggregationBuilder;
-import es.org.elasticsearch.search.builder.SearchSourceBuilder;
-import es.org.elasticsearch.search.fetch.subphase.FetchSourceContext;
-import es.org.elasticsearch.search.sort.FieldSortBuilder;
-import es.org.elasticsearch.search.sort.NestedSortBuilder;
-import es.org.elasticsearch.search.sort.SortBuilders;
-import es.org.elasticsearch.search.sort.SortMode;
-import es.org.elasticsearch.search.sort.SortOrder;
-import es.org.elasticsearch.search.suggest.Suggest;
-import es.org.elasticsearch.search.suggest.SuggestBuilder;
-import es.org.elasticsearch.search.suggest.SuggestBuilders;
-import es.org.elasticsearch.search.suggest.completion.CompletionSuggestionBuilder;
-import es.org.elasticsearch.search.suggest.completion.context.CategoryQueryContext;
-import es.org.elasticsearch.xcontent.XContentParser;
-import es.org.elasticsearch.xcontent.XContentType;
+import es.co.elastic.clients.elasticsearch.ElasticsearchClient;
+import es.co.elastic.clients.elasticsearch._types.ElasticsearchException;
+import es.co.elastic.clients.elasticsearch._types.FieldSort;
+import es.co.elastic.clients.elasticsearch._types.FieldValue;
+import es.co.elastic.clients.elasticsearch._types.HealthStatus;
+import es.co.elastic.clients.elasticsearch._types.SortOrder;
+import es.co.elastic.clients.elasticsearch._types.aggregations.StringTermsAggregate;
+import es.co.elastic.clients.elasticsearch._types.mapping.FieldType;
+import es.co.elastic.clients.elasticsearch._types.query_dsl.BoolQuery;
+import es.co.elastic.clients.elasticsearch._types.query_dsl.Query;
+import es.co.elastic.clients.elasticsearch._types.query_dsl.QueryBuilders;
+import es.co.elastic.clients.elasticsearch.cluster.HealthResponse;
+import es.co.elastic.clients.elasticsearch.core.GetRequest;
+import es.co.elastic.clients.elasticsearch.core.GetResponse;
+import es.co.elastic.clients.elasticsearch.core.SearchResponse;
+import es.co.elastic.clients.elasticsearch.core.search.TrackHits;
+import es.co.elastic.clients.json.JsonData;
 import java.io.IOException;
+import java.io.StringReader;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
@@ -139,7 +82,7 @@
 import org.openmetadata.schema.entity.data.EntityHierarchy;
 import org.openmetadata.schema.entity.data.QueryCostSearchResult;
 import org.openmetadata.schema.entity.data.Table;
-import org.openmetadata.schema.search.SearchRequest;
+import org.openmetadata.schema.search.SearchRequestInternal;
 import org.openmetadata.schema.service.configuration.elasticsearch.ElasticSearchConfiguration;
 import org.openmetadata.schema.settings.SettingsType;
 import org.openmetadata.schema.tests.DataQualityReport;
@@ -159,6 +102,7 @@
 import org.openmetadata.service.resources.settings.SettingsCache;
 import org.openmetadata.service.search.SearchAggregation;
 import org.openmetadata.service.search.SearchClient;
+import org.openmetadata.service.search.SearchContext;
 import org.openmetadata.service.search.SearchHealthStatus;
 import org.openmetadata.service.search.SearchIndexUtils;
 import org.openmetadata.service.search.SearchResultListMapper;
@@ -180,6 +124,8 @@
 import org.openmetadata.service.search.elasticsearch.dataInsightAggregators.QueryCostRecordsAggregator;
 import org.openmetadata.service.search.elasticsearch.queries.ElasticQueryBuilder;
 import org.openmetadata.service.search.elasticsearch.queries.ElasticQueryBuilderFactory;
+import org.openmetadata.service.search.index.ElasticSearchIndexCrud;
+import org.openmetadata.service.search.index.SearchIndexCrud;
 import org.openmetadata.service.search.models.IndexMapping;
 import org.openmetadata.service.search.nlq.NLQService;
 import org.openmetadata.service.search.queries.OMQueryBuilder;
@@ -195,10 +141,11 @@
 
   @SuppressWarnings("deprecated")
   @Getter
-  protected final RestHighLevelClient client;
+  protected final ElasticsearchClient client;
 
   private final RBACConditionEvaluator rbacConditionEvaluator;
   private final QueryBuilderFactory queryBuilderFactory;
+  private final SearchIndexCrud indexCrud;
 
   private final boolean isClientAvailable;
 
@@ -232,6 +179,7 @@
     queryBuilderFactory = new ElasticQueryBuilderFactory();
     rbacConditionEvaluator = new RBACConditionEvaluator(queryBuilderFactory);
     lineageGraphBuilder = new ESLineageGraphBuilder(client);
+    indexCrud = new ElasticSearchIndexCrud(client, clusterAlias);
     nlqService = null;
   }
 
@@ -247,109 +195,38 @@
   }
 
   @Override
-  public boolean indexExists(String indexName) {
-    try {
-      GetIndexRequest gRequest = new GetIndexRequest(indexName);
-      gRequest.local(false);
-      return client.indices().exists(gRequest, RequestOptions.DEFAULT);
-    } catch (Exception e) {
-      LOG.error(String.format("Failed to check if index %s exists due to", indexName), e);
-      return false;
-    }
+  public boolean indexExists(IndexMapping indexMapping) {
+    return indexCrud.indexExists(indexMapping);
   }
 
   @Override
   public void createIndex(IndexMapping indexMapping, String indexMappingContent) {
-    if (Boolean.TRUE.equals(isClientAvailable)) {
-      try {
-        CreateIndexRequest request =
-            new CreateIndexRequest(indexMapping.getIndexName(clusterAlias));
-        request.source(indexMappingContent, XContentType.JSON);
-        CreateIndexResponse createIndexResponse =
-            client.indices().create(request, RequestOptions.DEFAULT);
-        LOG.debug(
-            "{} Created {}",
-            indexMapping.getIndexName(clusterAlias),
-            createIndexResponse.isAcknowledged());
-        createAliases(indexMapping);
-      } catch (Exception e) {
-        LOG.error(
-            String.format(
-                "Failed to create index for %s due to", indexMapping.getIndexName(clusterAlias)),
-            e);
-      }
-    } else {
-      LOG.error(
-          "Failed to create Elastic Search index as client is not property configured, Please check your OpenMetadata configuration");
-    }
+    indexCrud.createIndex(indexMapping, indexMappingContent);
   }
 
   @Override
   public void addIndexAlias(IndexMapping indexMapping, String... aliasName) {
-    try {
-      IndicesAliasesRequest.AliasActions aliasAction =
-          IndicesAliasesRequest.AliasActions.add()
-              .index(indexMapping.getIndexName(clusterAlias))
-              .aliases(aliasName);
-      IndicesAliasesRequest aliasesRequest = new IndicesAliasesRequest();
-      aliasesRequest.addAliasAction(aliasAction);
-      client.indices().updateAliases(aliasesRequest, RequestOptions.DEFAULT);
-    } catch (Exception e) {
-      LOG.error(
-          String.format(
-              "Failed to create alias for %s due to", indexMapping.getAlias(clusterAlias)),
-          e);
-    }
+    indexCrud.addIndexAlias(indexMapping, aliasName);
   }
 
   @Override
   public void createAliases(IndexMapping indexMapping) {
-    try {
-      Set<String> aliases = new HashSet<>(indexMapping.getParentAliases(clusterAlias));
-      aliases.add(indexMapping.getAlias(clusterAlias));
-      addIndexAlias(indexMapping, aliases.toArray(new String[0]));
-    } catch (Exception e) {
-      LOG.error(
-          String.format(
-              "Failed to create alias for %s due to", indexMapping.getAlias(clusterAlias)),
-          e);
-    }
+    indexCrud.createAliases(indexMapping);
   }
 
   @Override
   public void updateIndex(IndexMapping indexMapping, String indexMappingContent) {
-    try {
-      PutMappingRequest request = new PutMappingRequest(indexMapping.getIndexName(clusterAlias));
-      JsonNode readProperties = JsonUtils.readTree(indexMappingContent).get("mappings");
-      request.source(JsonUtils.getMap(readProperties));
-      AcknowledgedResponse putMappingResponse =
-          client.indices().putMapping(request, RequestOptions.DEFAULT);
-      LOG.debug(
-          "{} Updated {}", indexMapping.getIndexMappingFile(), putMappingResponse.isAcknowledged());
-    } catch (Exception e) {
-      LOG.warn(
-          String.format(
-              "Failed to Update Elastic Search index %s", indexMapping.getIndexName(clusterAlias)));
-    }
+    indexCrud.updateIndex(indexMapping, indexMappingContent);
   }
 
   @Override
   public void deleteIndex(IndexMapping indexMapping) {
-    try {
-      DeleteIndexRequest request = new DeleteIndexRequest(indexMapping.getIndexName(clusterAlias));
-      AcknowledgedResponse deleteIndexResponse =
-          client.indices().delete(request, RequestOptions.DEFAULT);
-      LOG.debug(
-          "{} Deleted {}",
-          indexMapping.getIndexName(clusterAlias),
-          deleteIndexResponse.isAcknowledged());
-    } catch (Exception e) {
-      LOG.error("Failed to delete Elastic Search indexes due to", e);
-    }
+    indexCrud.deleteIndex(indexMapping);
   }
 
   @Override
-  public Response search(SearchRequest request, SubjectContext subjectContext) throws IOException {
+  public Response search(SearchRequestInternal request, SubjectContext subjectContext)
+      throws IOException {
     SearchSettings searchSettings =
         SettingsCache.getSetting(SettingsType.SEARCH_SETTINGS, SearchSettings.class);
     return doSearch(request, subjectContext, searchSettings);
@@ -357,195 +234,182 @@
 
   @Override
   public Response previewSearch(
-      SearchRequest request, SubjectContext subjectContext, SearchSettings searchSettings)
+      SearchRequestInternal request, SubjectContext subjectContext, SearchSettings searchSettings)
       throws IOException {
     return doSearch(request, subjectContext, searchSettings);
   }
 
   public Response doSearch(
-      SearchRequest request, SubjectContext subjectContext, SearchSettings searchSettings)
+      SearchRequestInternal request, SubjectContext subjectContext, SearchSettings searchSettings)
       throws IOException {
     ElasticSearchSourceBuilderFactory searchBuilderFactory =
         new ElasticSearchSourceBuilderFactory(searchSettings);
-    SearchSourceBuilder searchSourceBuilder =
+    SearchContext searchContext = new SearchContext(new ElasticQueryBuilderFactory(), request);
+    searchContext =
         searchBuilderFactory.getSearchSourceBuilder(
-            request.getIndex(), request.getQuery(), request.getFrom(), request.getSize());
+            searchContext,
+            request.getIndex(),
+            request.getQuery(),
+            request.getFrom(),
+            request.getSize());
 
-    buildSearchRBACQuery(subjectContext, searchSourceBuilder);
+    buildSearchRBACQuery(subjectContext, searchContext);
     // Add Filter
-    buildSearchSourceFilter(request.getQueryFilter(), searchSourceBuilder);
-
-    if (!nullOrEmpty(request.getPostFilter())) {
-      try {
-        XContentParser filterParser =
-            XContentType.JSON
-                .xContent()
-                .createParser(
-                    EsUtils.esXContentRegistry,
-                    LoggingDeprecationHandler.INSTANCE,
-                    request.getPostFilter());
-        QueryBuilder filter = SearchSourceBuilder.fromXContent(filterParser).query();
-        searchSourceBuilder.postFilter(filter);
-      } catch (Exception ex) {
-        LOG.warn("Error parsing post_filter from query parameters, ignoring filter", ex);
-      }
-    }
+    buildSearchSourceFilter(request.getQueryFilter(), searchContext);
+    
 
-    if (!nullOrEmpty(request.getSearchAfter())) {
-      searchSourceBuilder.searchAfter(request.getSearchAfter().toArray());
-    }
-
     /* For backward-compatibility we continue supporting the deleted argument, this should be removed in future versions */
+    if (isAllOrDataAsset(request)) {
+      ElasticQueryBuilder omQueryBuilder = new ElasticQueryBuilder();
+      BoolQuery.Builder boolQueryBuilder = QueryBuilders.bool();
+      boolQueryBuilder.should(
+          QueryBuilders.bool()
+              .must(((ElasticQueryBuilder) searchContext.getQuery()).build())
+              .must(QueryBuilders.exists().field("deleted").build()._toQuery())
+              .must(
+                  QueryBuilders.term()
+                      .field("deleted")
+                      .value(request.getDeleted())
+                      .build()
+                      ._toQuery())
+              .build()
+              ._toQuery());
+      boolQueryBuilder.should(
+          QueryBuilders.bool()
+              .must(((ElasticQueryBuilder) searchContext.getQuery()).build())
+              .mustNot(QueryBuilders.exists().field("deleted").build()._toQuery())
+              .build()
+              ._toQuery());
+      omQueryBuilder.setQuery(boolQueryBuilder.build()._toQuery());
+      searchContext.setQuery(omQueryBuilder);
+    } else if (isIndexWithoutDeleteFields(request)) {
+      searchContext
+      searchSourceBuilder.query(
+          QueryBuilders.bool().must(searchSourceBuilder.build().query()).build()._toQuery());
+    } else {
+      searchSourceBuilder.query(
+          QueryBuilders.bool()
+              .must(searchSourceBuilder.build().query())
+              .must(
+                  QueryBuilders.term()
+                      .field("deleted")
+                      .value(request.getDeleted())
+                      .build()
+                      ._toQuery())
+              .build()
+              ._toQuery());
+    }
+
     if (request
+        .getIndex()
+        .equalsIgnoreCase(
+            Entity.getSearchRepository()
+                .getIndexMapping(GLOSSARY_TERM)
+                .getIndexName(clusterAlias))) {
+      searchSourceBuilder.query(
+          QueryBuilders.bool().must(searchSourceBuilder.build().query()).build()._toQuery());
+    }
+
+    buildHierarchyQuery(request, searchSourceBuilder, client);
+    
+    try {
+
+      searchSourceBuilder.index(request.getIndex());
+      SearchResponse<JsonData> searchResponse =
+          client.search(searchSourceBuilder.build(), JsonData.class);
+
+      if (!request.getIsHierarchy()) {
+        return Response.status(OK).entity(searchResponse.toString()).build();
+      } else {
+        // Build the nested hierarchy from elastic search response
+        List<?> response = buildSearchHierarchy(request, searchResponse);
+        return Response.status(OK).entity(response).build();
+      }
+
+    } catch (ElasticsearchException e) {
+      if (e.status() == NOT_FOUND.getStatusCode()) {
+        throw new SearchIndexNotFoundException(
+            String.format("Failed to to find index %s", request.getIndex()));
+      } else {
+        throw new SearchException(String.format("Search failed due to %s", e.getMessage()));
+      }
+    }
+  }
+
+  private boolean isAllOrDataAsset(SearchRequestInternal request) {
+    return request
             .getIndex()
             .equalsIgnoreCase(Entity.getSearchRepository().getIndexOrAliasName(GLOBAL_SEARCH_ALIAS))
         || request
             .getIndex()
-            .equalsIgnoreCase(Entity.getSearchRepository().getIndexOrAliasName("dataAsset"))) {
-      es.org.elasticsearch.index.query.BoolQueryBuilder boolQueryBuilder =
-          QueryBuilders.boolQuery();
-      boolQueryBuilder.should(
-          QueryBuilders.boolQuery()
-              .must(searchSourceBuilder.query())
-              .must(QueryBuilders.existsQuery("deleted"))
-              .must(QueryBuilders.termQuery("deleted", request.getDeleted())));
-      boolQueryBuilder.should(
-          QueryBuilders.boolQuery()
-              .must(searchSourceBuilder.query())
-              .mustNot(QueryBuilders.existsQuery("deleted")));
-      searchSourceBuilder.query(boolQueryBuilder);
-    } else if (request
+            .equalsIgnoreCase(Entity.getSearchRepository().getIndexOrAliasName("dataAsset"));
+  }
+  
+  private boolean isIndexWithoutDeleteFields(SearchRequestInternal request){
+    return request
+            .getIndex()
+            .equalsIgnoreCase(
+                    Entity.getSearchRepository()
+                            .getIndexMapping(GLOSSARY_TERM)
+                            .getIndexName(clusterAlias)) ||
+            request
             .getIndex()
             .equalsIgnoreCase(
-                Entity.getSearchRepository().getIndexMapping(DOMAIN).getIndexName(clusterAlias))
-        || request
+                    Entity.getSearchRepository().getIndexMapping(DOMAIN).getIndexName(clusterAlias))
+            || request
             .getIndex()
             .equalsIgnoreCase(
-                Entity.getSearchRepository()
-                    .getIndexMapping(DATA_PRODUCT)
-                    .getIndexName(clusterAlias))
-        || request
+                    Entity.getSearchRepository()
+                            .getIndexMapping(DATA_PRODUCT)
+                            .getIndexName(clusterAlias))
+            || request
             .getIndex()
             .equalsIgnoreCase(
-                Entity.getSearchRepository().getIndexMapping(QUERY).getIndexName(clusterAlias))
-        || request
+                    Entity.getSearchRepository().getIndexMapping(QUERY).getIndexName(clusterAlias))
+            || request
             .getIndex()
             .equalsIgnoreCase(
-                Entity.getSearchRepository().getIndexOrAliasName("knowledge_page_search_index"))
-        || request
+                    Entity.getSearchRepository().getIndexOrAliasName("knowledge_page_search_index"))
+            || request
             .getIndex()
             .equalsIgnoreCase(
-                Entity.getSearchRepository()
-                    .getIndexMapping(RAW_COST_ANALYSIS_REPORT_DATA)
-                    .getIndexName(clusterAlias))
-        || request
+                    Entity.getSearchRepository()
+                            .getIndexMapping(RAW_COST_ANALYSIS_REPORT_DATA)
+                            .getIndexName(clusterAlias))
+            || request
             .getIndex()
             .equalsIgnoreCase(
-                Entity.getSearchRepository()
-                    .getIndexMapping(AGGREGATED_COST_ANALYSIS_REPORT_DATA)
-                    .getIndexName(clusterAlias))) {
-      searchSourceBuilder.query(QueryBuilders.boolQuery().must(searchSourceBuilder.query()));
-    } else {
-      searchSourceBuilder.query(
-          QueryBuilders.boolQuery()
-              .must(searchSourceBuilder.query())
-              .must(QueryBuilders.termQuery("deleted", request.getDeleted())));
-    }
-
-    if (!nullOrEmpty(request.getSortFieldParam()) && !request.getIsHierarchy()) {
-      FieldSortBuilder fieldSortBuilder =
-          new FieldSortBuilder(request.getSortFieldParam())
-              .order(SortOrder.fromString(request.getSortOrder()));
-      // Score is an internal ES Field
-      if (!request.getSortFieldParam().equalsIgnoreCase("_score")) {
-        fieldSortBuilder.unmappedType("integer");
-      }
-      searchSourceBuilder.sort(fieldSortBuilder);
-    }
-
-    if (request
-        .getIndex()
-        .equalsIgnoreCase(
-            Entity.getSearchRepository()
-                .getIndexMapping(GLOSSARY_TERM)
-                .getIndexName(clusterAlias))) {
-      searchSourceBuilder.query(QueryBuilders.boolQuery().must(searchSourceBuilder.query()));
-    }
-
-    buildHierarchyQuery(request, searchSourceBuilder, client);
-
-    /* for performance reasons ElasticSearch doesn't provide accurate hits
-    if we enable trackTotalHits parameter it will try to match every result, count and return hits
-    however in most cases for search results an approximate value is good enough.
-    we are displaying total entity counts in landing page and explore page where we need the total count
-    https://github.com/elastic/elasticsearch/issues/33028 */
-    searchSourceBuilder.fetchSource(
-        new FetchSourceContext(
-            request.getFetchSource(),
-            request.getIncludeSourceFields().toArray(String[]::new),
-            new String[] {}));
-
-    if (request.getTrackTotalHits()) {
-      searchSourceBuilder.trackTotalHits(true);
-    } else {
-      searchSourceBuilder.trackTotalHitsUpTo(MAX_RESULT_HITS);
-    }
-
-    searchSourceBuilder.timeout(new TimeValue(30, TimeUnit.SECONDS));
-
-    try {
-
-      SearchResponse searchResponse =
-          client.search(
-              new es.org.elasticsearch.action.search.SearchRequest(request.getIndex())
-                  .source(searchSourceBuilder),
-              RequestOptions.DEFAULT);
-
-      if (!request.getIsHierarchy()) {
-        return Response.status(OK).entity(searchResponse.toString()).build();
-      } else {
-        // Build the nested hierarchy from elastic search response
-        List<?> response = buildSearchHierarchy(request, searchResponse);
-        return Response.status(OK).entity(response).build();
-      }
-
-    } catch (ElasticsearchStatusException e) {
-      if (e.status() == RestStatus.NOT_FOUND) {
-        throw new SearchIndexNotFoundException(
-            String.format("Failed to to find index %s", request.getIndex()));
-      } else {
-        throw new SearchException(String.format("Search failed due to %s", e.getMessage()));
-      }
-    }
+                    Entity.getSearchRepository()
+                            .getIndexMapping(AGGREGATED_COST_ANALYSIS_REPORT_DATA)
+                            .getIndexName(clusterAlias))
   }
 
   @Override
   public Response getDocByID(String indexName, String entityId) throws IOException {
     try {
-      GetRequest request =
-          new GetRequest(Entity.getSearchRepository().getIndexOrAliasName(indexName), entityId);
-      GetResponse response = client.get(request, RequestOptions.DEFAULT);
-
-      if (response.isExists()) {
-        return Response.status(OK).entity(response.toString()).build();
+      GetRequest request = new GetRequest.Builder().index(indexName).id(entityId).build();
+      GetResponse<JsonData> response = client.get(request, JsonData.class);
+      if (response.found()) {
+        return Response.status(Response.Status.OK).entity(response.source()).build();
       }
-
-    } catch (ElasticsearchStatusException e) {
-      if (e.status() == RestStatus.NOT_FOUND) {
+    } catch (ElasticsearchException e) {
+      if (e.status() == NOT_FOUND.getStatusCode()) {
         throw new SearchIndexNotFoundException(
-            String.format("Failed to to find doc with id %s", entityId));
+            String.format("Failed to find doc with id %s", entityId));
       } else {
         throw new SearchException(String.format("Search failed due to %s", e.getMessage()));
       }
     }
-    return getResponse(NOT_FOUND, "Document not found.");
+    return Response.status(Response.Status.NOT_FOUND).entity("Document not found.").build();
   }
 
   private void buildHierarchyQuery(
-      SearchRequest request, SearchSourceBuilder searchSourceBuilder, RestHighLevelClient client)
+      SearchRequestInternal request,
+      es.co.elastic.clients.elasticsearch.core.SearchRequest.Builder searchSourceBuilder,
+      ElasticsearchClient client)
       throws IOException {
 
-    if (!request.getIsHierarchy()) {
+    if (Boolean.FALSE.equals(request.getIsHierarchy())) {
       return;
     }
 
@@ -555,63 +419,109 @@
     String domainIndex =
         Entity.getSearchRepository().getIndexMapping(DOMAIN).getIndexName(clusterAlias);
 
-    BoolQueryBuilder baseQuery =
-        QueryBuilders.boolQuery()
-            .should(searchSourceBuilder.query())
-            .should(QueryBuilders.matchPhraseQuery("fullyQualifiedName", request.getQuery()))
-            .should(QueryBuilders.matchPhraseQuery("name", request.getQuery()))
-            .should(QueryBuilders.matchPhraseQuery("displayName", request.getQuery()));
+    BoolQuery.Builder baseQuery =
+        QueryBuilders.bool()
+            .should(searchSourceBuilder.build().query())
+            .should(
+                QueryBuilders.matchPhrase()
+                    .field("fullyQualifiedName")
+                    .query(request.getQuery())
+                    .build()
+                    ._toQuery())
+            .should(
+                QueryBuilders.matchPhrase()
+                    .field("name")
+                    .query(request.getQuery())
+                    .build()
+                    ._toQuery())
+            .should(
+                QueryBuilders.matchPhrase()
+                    .field("displayName")
+                    .query(request.getQuery())
+                    .build()
+                    ._toQuery());
 
     if (indexName.equalsIgnoreCase(glossaryTermIndex)) {
       baseQuery
-          .should(QueryBuilders.matchPhraseQuery("glossary.fullyQualifiedName", request.getQuery()))
-          .should(QueryBuilders.matchPhraseQuery("glossary.displayName", request.getQuery()))
-          .must(QueryBuilders.matchQuery("status", "Approved"));
+          .should(
+              QueryBuilders.matchPhrase()
+                  .field("glossary.fullyQualifiedName")
+                  .query(request.getQuery())
+                  .build()
+                  ._toQuery())
+          .should(
+              QueryBuilders.matchPhrase()
+                  .field("glossary.displayName")
+                  .query(request.getQuery())
+                  .build()
+                  ._toQuery())
+          .must(q -> q.match(m -> m.field("status").query(FieldValue.of("Approved"))));
     } else if (indexName.equalsIgnoreCase(domainIndex)) {
       baseQuery
-          .should(QueryBuilders.matchPhraseQuery("parent.fullyQualifiedName", request.getQuery()))
-          .should(QueryBuilders.matchPhraseQuery("parent.displayName", request.getQuery()));
+          .should(
+              QueryBuilders.matchPhrase()
+                  .field("parent.fullyQualifiedName")
+                  .query(request.getQuery())
+                  .build()
+                  ._toQuery())
+          .should(
+              QueryBuilders.matchPhrase()
+                  .field("parent.displayName")
+                  .query(request.getQuery())
+                  .build()
+                  ._toQuery());
     }
 
-    baseQuery.minimumShouldMatch(1);
-    searchSourceBuilder.query(baseQuery);
+    baseQuery.minimumShouldMatch("1");
+    searchSourceBuilder.query(baseQuery.build()._toQuery());
 
-    SearchResponse searchResponse =
-        client.search(
-            new es.org.elasticsearch.action.search.SearchRequest(request.getIndex())
-                .source(searchSourceBuilder),
-            RequestOptions.DEFAULT);
+    SearchResponse<JsonData> searchResponse =
+        client.search(searchSourceBuilder.index(request.getIndex()).build(), JsonData.class);
 
-    Terms parentTerms = searchResponse.getAggregations().get("fqnParts_agg");
+    StringTermsAggregate parentTerms = searchResponse.aggregations().get("fqnParts_agg").sterms();
 
     // Build  es query to get parent terms for the user input query , to build correct hierarchy
     // In case of default search , no need to get parent terms they are already present in the
     // response
     if (parentTerms != null
-        && !parentTerms.getBuckets().isEmpty()
+        && parentTerms.buckets().array() != null
+        && !parentTerms.buckets().array().isEmpty()
         && !request.getQuery().equals("*")) {
-      BoolQueryBuilder parentTermQueryBuilder = QueryBuilders.boolQuery();
 
-      parentTerms.getBuckets().stream()
-          .map(Terms.Bucket::getKeyAsString)
+      BoolQuery.Builder parentTermQueryBuilder = new BoolQuery.Builder();
+
+      parentTerms
+          .buckets()
+          .array()
           .forEach(
-              parentTerm ->
+              bucket ->
                   parentTermQueryBuilder.should(
-                      QueryBuilders.matchQuery("fullyQualifiedName", parentTerm)));
+                      q ->
+                          q.match(
+                              m ->
+                                  m.field("fullyQualifiedName")
+                                      .query(bucket.key().stringValue()))));
+
       if (indexName.equalsIgnoreCase(glossaryTermIndex)) {
-        parentTermQueryBuilder
-            .minimumShouldMatch(1)
-            .must(QueryBuilders.matchQuery("status", "Approved"));
-      } else {
-        parentTermQueryBuilder.minimumShouldMatch(1);
+        parentTermQueryBuilder.must(
+            q -> q.match(m -> m.field("status").query(FieldValue.of("Approved"))));
       }
-      searchSourceBuilder.query(parentTermQueryBuilder);
+
+      // Build a new search request with the updated query
+      es.co.elastic.clients.elasticsearch.core.SearchRequest updatedRequest =
+          new es.co.elastic.clients.elasticsearch.core.SearchRequest.Builder()
+              .index(indexName)
+              .query(q -> q.bool(parentTermQueryBuilder.build()))
+              .sort(s -> s.field(f -> f.field("fullyQualifiedName").order(SortOrder.Asc)))
+              .build();
+
+      // Perform the updated search
+      client.search(updatedRequest, os.org.opensearch.client.json.JsonData.class);
     }
-
-    searchSourceBuilder.sort(SortBuilders.fieldSort("fullyQualifiedName").order(SortOrder.ASC));
   }
 
-  public List<?> buildSearchHierarchy(SearchRequest request, SearchResponse searchResponse) {
+  public List<?> buildSearchHierarchy(
+      SearchRequestInternal request, SearchResponse searchResponse) {
     List<?> response = new ArrayList<>();
 
     String indexName = request.getIndex();
@@ -628,14 +538,16 @@
     return response;
   }
 
-  public List<EntityHierarchy> buildGlossaryTermSearchHierarchy(SearchResponse searchResponse) {
+  public List<EntityHierarchy> buildGlossaryTermSearchHierarchy(
+      SearchResponse<JsonData> searchResponse) {
     Map<String, EntityHierarchy> termMap =
         new LinkedHashMap<>(); // termMap represent glossary terms
     Map<String, EntityHierarchy> rootTerms =
         new LinkedHashMap<>(); // rootTerms represent glossaries
 
-    for (var hit : searchResponse.getHits().getHits()) {
-      String jsonSource = hit.getSourceAsString();
+    for (var hit : searchResponse.hits().hits()) {
+      String jsonSource = hit.source();
+              hit.getSourceAsString();
 
       EntityHierarchy term = JsonUtils.readValue(jsonSource, EntityHierarchy.class);
       EntityHierarchy glossaryInfo =
@@ -679,7 +591,7 @@
     return new ArrayList<>(rootTerms.values());
   }
 
-  public List<EntityHierarchy> buildDomainSearchHierarchy(SearchResponse searchResponse) {
+  public List<EntityHierarchy> buildDomainSearchHierarchy(SearchResponse<JsonData> searchResponse) {
     Map<String, EntityHierarchy> entityHierarchyMap =
         Arrays.stream(searchResponse.getHits().getHits())
             .map(hit -> JsonUtils.readValue(hit.getSourceAsString(), EntityHierarchy.class))
@@ -880,7 +792,7 @@
   }
 
   @Override
-  public Response searchWithNLQ(SearchRequest request, SubjectContext subjectContext)
+  public Response searchWithNLQ(SearchRequestInternal request, SubjectContext subjectContext)
       throws IOException {
     LOG.info("Searching with NLQ: {}", request.getQuery());
     if (nlqService != null) {
@@ -912,7 +824,8 @@
     }
   }
 
-  private Response fallbackToBasicSearch(SearchRequest request, SubjectContext subjectContext) {
+  private Response fallbackToBasicSearch(
+      SearchRequestInternal request, SubjectContext subjectContext) {
     try {
       LOG.debug("Falling back to basic query_string search for NLQ: {}", request.getQuery());
 
@@ -962,7 +875,7 @@
   }
 
   @Override
-  public SearchLineageResult searchPlatformLineage(
+  public SearchLineageResult searchPlatformLineage(s
       String index, String queryFilter, boolean deleted) throws IOException {
     return lineageGraphBuilder.getPlatformLineage(index, queryFilter, deleted);
   }
@@ -1443,7 +1356,7 @@
   }
 
   @Override
-  public Response suggest(SearchRequest request) throws IOException {
+  public Response suggest(SearchRequestInternal request) throws IOException {
     String fieldName = request.getFieldName();
     SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();
     CompletionSuggestionBuilder suggestionBuilder =
@@ -2247,7 +2160,7 @@
     }
   }
 
-  public RestHighLevelClient createElasticSearchClient(ElasticSearchConfiguration esConfig) {
+  public ElasticsearchClient createElasticSearchClient(ElasticSearchConfiguration esConfig) {
     if (esConfig != null) {
       try {
         RestClientBuilder restClientBuilder =
@@ -2305,20 +2218,23 @@
     }
   }
 
-  private void getSearchFilter(String filter, SearchSourceBuilder searchSourceBuilder)
+  private void getSearchFilter(
+      String filter,
+      es.co.elastic.clients.elasticsearch.core.SearchRequest.Builder searchSourceBuilder)
       throws IOException {
     if (!filter.isEmpty()) {
       try {
+        Query existingQuery = searchSourceBuilder.build().query();
         XContentParser queryParser = createXContentParser(filter);
         XContentParser sourceParser = createXContentParser(filter);
         QueryBuilder queryFromXContent = SearchSourceBuilder.fromXContent(queryParser).query();
         FetchSourceContext sourceFromXContent =
             SearchSourceBuilder.fromXContent(sourceParser).fetchSource();
-        BoolQueryBuilder boolQuery = QueryBuilders.boolQuery();
-        if (searchSourceBuilder.query() != null) {
-          boolQuery = boolQuery.must(searchSourceBuilder.query());
+        BoolQuery.Builder boolQuery = QueryBuilders.bool();
+        if (existingQuery != null) {
+          boolQuery = boolQuery.must(existingQuery);
         }
-        boolQuery = boolQuery.filter(queryFromXContent);
+        boolQuery = boolQuery.filter(QueryBuilders.bool().must());
         searchSourceBuilder.query(boolQuery);
         searchSourceBuilder.fetchSource(sourceFromXContent);
       } catch (Exception e) {
@@ -2333,46 +2249,37 @@
 
   @Override
   public SearchHealthStatus getSearchHealthStatus() throws IOException {
-    ClusterHealthRequest request = new ClusterHealthRequest();
-    ClusterHealthResponse response = client.cluster().health(request, RequestOptions.DEFAULT);
-    if (response.getStatus().equals(ClusterHealthStatus.GREEN)
-        || response.getStatus().equals(ClusterHealthStatus.YELLOW)) {
+    HealthResponse response = client.cluster().health(); // No request object needed
+    HealthStatus status = response.status();
+
+    if (status == HealthStatus.Green || status == HealthStatus.Yellow) {
       return new SearchHealthStatus(HEALTHY_STATUS);
     } else {
       return new SearchHealthStatus(UNHEALTHY_STATUS);
     }
   }
 
-  private void buildSearchRBACQuery(
-      SubjectContext subjectContext, SearchSourceBuilder searchSourceBuilder) {
+  private void buildSearchRBACQuery(SubjectContext subjectContext, SearchContext context) {
     if (shouldApplyRbacConditions(subjectContext, rbacConditionEvaluator)) {
       OMQueryBuilder rbacQuery = rbacConditionEvaluator.evaluateConditions(subjectContext);
       if (rbacQuery != null) {
-        searchSourceBuilder.query(
-            QueryBuilders.boolQuery()
-                .must(searchSourceBuilder.query())
-                .filter(((ElasticQueryBuilder) rbacQuery).build()));
+        context.getQuery().filter(rbacQuery);
       }
     }
   }
 
-  private static void buildSearchSourceFilter(
-      String queryFilter, SearchSourceBuilder searchSourceBuilder) {
+  private static void buildSearchSourceFilter(String queryFilter, SearchContext context) {
     if (!nullOrEmpty(queryFilter) && !queryFilter.equals("{}")) {
       try {
-        XContentParser filterParser =
-            XContentType.JSON
-                .xContent()
-                .createParser(
-                    EsUtils.esXContentRegistry, LoggingDeprecationHandler.INSTANCE, queryFilter);
-        QueryBuilder filter = SearchSourceBuilder.fromXContent(filterParser).query();
-        BoolQueryBuilder newQuery;
-        if (!nullOrEmpty(searchSourceBuilder.query())) {
-          newQuery = QueryBuilders.boolQuery().must(searchSourceBuilder.query()).filter(filter);
+        BoolQuery.Builder newQuery;
+        BoolQuery.Builder filter = new BoolQuery.Builder().withJson(new StringReader(queryFilter));
+        Query existingQuery = ((ElasticQueryBuilder) context.getQuery()).build();
+        if (!nullOrEmpty(existingQuery)) {
+          newQuery = QueryBuilders.bool().must(existingQuery).filter(filter.build()._toQuery());
         } else {
-          newQuery = QueryBuilders.boolQuery().filter(filter);
+          newQuery = QueryBuilders.bool().filter(filter.build()._toQuery());
         }
-        searchSourceBuilder.query(newQuery);
+        ((ElasticQueryBuilder) context.getQuery()).setQuery(newQuery.build()._toQuery());
       } catch (Exception ex) {
         LOG.warn("Error parsing query_filter from query parameters, ignoring filter", ex);
       }
Index: openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/DashboardIndex.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/DashboardIndex.java b/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/DashboardIndex.java
--- a/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/DashboardIndex.java	(revision d10bcccecad7a11724e8df23cf8c879f9f0673da)
+++ b/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/DashboardIndex.java	(date 1744005110066)
@@ -2,9 +2,13 @@
 
 import static org.openmetadata.common.utils.CommonUtil.listOrEmpty;
 
+import co.elastic.clients.elasticsearch._types.aggregations.Aggregation;
+import co.elastic.clients.elasticsearch.core.SearchRequest;
 import java.util.ArrayList;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 import org.openmetadata.schema.entity.data.Dashboard;
 import org.openmetadata.schema.type.EntityReference;
 import org.openmetadata.service.Entity;
@@ -12,6 +16,18 @@
 import org.openmetadata.service.search.models.SearchSuggest;
 
 public class DashboardIndex implements SearchIndex {
+  public static final Set<String> FIELDS_WITH_WEIGHT = new HashSet<>();
+  public static final Set<String> HIGHLIGHT_FIELDS = new HashSet<>();
+
+  static {
+    Set<String> fields = SearchIndex.getDefaultFields();
+    fields.add("charts.name^2");
+    fields.add("charts.description^1");
+    FIELDS_WITH_WEIGHT.addAll(fields);
+
+    HIGHLIGHT_FIELDS.addAll(Set.of("charts.name", "charts.description"));
+  }
+
   final Dashboard dashboard;
 
   public DashboardIndex(Dashboard dashboard) {
@@ -59,10 +75,58 @@
     return doc;
   }
 
-  public static Map<String, Float> getFields() {
-    Map<String, Float> fields = SearchIndex.getDefaultFields();
-    fields.put("charts.name", 2.0f);
-    fields.put("charts.description", 1.0f);
-    return fields;
+  public static Set<String> getHighLightFields() {
+    return HIGHLIGHT_FIELDS;
+  }
+
+  public static Set<String> getFieldsWithWeights() {
+    return FIELDS_WITH_WEIGHT;
+  }
+
+  public static SearchRequest.Builder addEsEntityAggregation(SearchRequest.Builder requestBuilder) {
+    // add Base Aggregations for ElasticSearch
+    SearchIndex.addBaseElasticSearchAggregation(requestBuilder);
+
+    requestBuilder
+        .aggregations(
+            "dataModels.displayName.keyword",
+            new Aggregation.Builder()
+                .terms(termAgg -> termAgg.field("dataModels.displayName.keyword"))
+                .build())
+        .aggregations(
+            "project.keyword",
+            new Aggregation.Builder().terms(termAgg -> termAgg.field("project.keyword")).build())
+        .aggregations(
+            "charts.displayName.keyword",
+            new Aggregation.Builder()
+                .terms(termAgg -> termAgg.field("charts.displayName.keyword"))
+                .build());
+    return requestBuilder;
+  }
+
+  public static os.org.opensearch.client.opensearch.core.SearchRequest.Builder
+      addOsEntityAggregation(
+          os.org.opensearch.client.opensearch.core.SearchRequest.Builder requestBuilder) {
+
+    // add Base Aggregations for OpenSearch
+    SearchIndex.addBaseOpenSearchAggregation(requestBuilder);
+
+    requestBuilder
+        .aggregations(
+            "dataModels.displayName.keyword",
+            new os.org.opensearch.client.opensearch._types.aggregations.Aggregation.Builder()
+                .terms(termAgg -> termAgg.field("dataModels.displayName.keyword"))
+                .build())
+        .aggregations(
+            "project.keyword",
+            new os.org.opensearch.client.opensearch._types.aggregations.Aggregation.Builder()
+                .terms(termAgg -> termAgg.field("project.keyword"))
+                .build())
+        .aggregations(
+            "charts.displayName.keyword",
+            new os.org.opensearch.client.opensearch._types.aggregations.Aggregation.Builder()
+                .terms(termAgg -> termAgg.field("charts.displayName.keyword"))
+                .build());
+    return requestBuilder;
   }
 }
Index: openmetadata-service/src/main/java/org/openmetadata/service/search/SearchSourceBuilderFactory.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openmetadata-service/src/main/java/org/openmetadata/service/search/SearchSourceBuilderFactory.java b/openmetadata-service/src/main/java/org/openmetadata/service/search/SearchSourceBuilderFactory.java
--- a/openmetadata-service/src/main/java/org/openmetadata/service/search/SearchSourceBuilderFactory.java	(revision d10bcccecad7a11724e8df23cf8c879f9f0673da)
+++ b/openmetadata-service/src/main/java/org/openmetadata/service/search/SearchSourceBuilderFactory.java	(date 1744005110074)
@@ -5,9 +5,9 @@
 import static org.openmetadata.service.search.SearchUtil.isServiceIndex;
 import static org.openmetadata.service.search.SearchUtil.isTimeSeriesIndex;
 
-import java.util.HashMap;
+import java.util.HashSet;
 import java.util.List;
-import java.util.Map;
+import java.util.Set;
 import java.util.regex.Pattern;
 import org.openmetadata.schema.api.search.AssetTypeConfiguration;
 import org.openmetadata.schema.api.search.SearchSettings;
@@ -22,7 +22,7 @@
  * @param <H> The HighlightBuilder type
  * @param <F> The FunctionScoreQueryBuilder type
  */
-public interface SearchSourceBuilderFactory<S, Q, H, F> {
+public interface SearchSourceBuilderFactory<S extends SearchContext, Q, H, F> {
 
   Pattern QUERY_SYNTAX_PATTERN =
       Pattern.compile(
@@ -50,19 +50,19 @@
    * @param size the number of results to return
    * @return a search source builder configured for the specific entity type
    */
-  default S getSearchSourceBuilder(String index, String q, int from, int size) {
+  default S getSearchSourceBuilder(S context, String index, String q, int from, int size) {
     String indexName = Entity.getSearchRepository().getIndexNameWithoutAlias(index);
 
     if (isTimeSeriesIndex(indexName)) {
-      return buildTimeSeriesSearchBuilder(indexName, q, from, size);
+      return buildTimeSeriesSearchBuilder(context, indexName, q, from, size);
     }
 
     if (isServiceIndex(indexName)) {
-      return buildServiceSearchBuilder(q, from, size);
+      return buildServiceSearchBuilder(context, q, from, size);
     }
 
     if (isDataQualityIndex(indexName)) {
-      return buildDataQualitySearchBuilder(indexName, q, from, size);
+      return buildDataQualitySearchBuilder(context, indexName, q, from, size);
     }
 
     if (isDataAssetIndex(indexName)) {
@@ -80,45 +80,47 @@
     };
   }
 
-  S buildServiceSearchBuilder(String query, int from, int size);
+  S buildServiceSearchBuilder(S context, String query, int from, int size);
 
-  S buildDataAssetSearchBuilder(String indexName, String query, int from, int size);
+  S buildDataAssetSearchBuilder(S context, String indexName, String query, int from, int size);
 
-  S buildCommonSearchBuilder(String query, int from, int size);
+  S buildCommonSearchBuilder(S context, String query, int from, int size);
 
-  S buildUserOrTeamSearchBuilder(String query, int from, int size);
+  S buildUserOrTeamSearchBuilder(S context, String query, int from, int size);
 
-  S buildAggregateSearchBuilder(String query, int from, int size);
+  S buildAggregateSearchBuilder(S context, String query, int from, int size);
 
-  default S buildTimeSeriesSearchBuilder(String indexName, String query, int from, int size) {
+  default S buildTimeSeriesSearchBuilder(
+      S context, String indexName, String query, int from, int size) {
     return switch (indexName) {
-      case "test_case_result_search_index" -> buildTestCaseResultSearch(query, from, size);
+      case "test_case_result_search_index" -> buildTestCaseResultSearch(context, query, from, size);
       case "test_case_resolution_status_search_index" -> buildTestCaseResolutionStatusSearch(
-          query, from, size);
+          context, query, from, size);
       case "raw_cost_analysis_report_data_index",
           "aggregated_cost_analysis_report_data_index" -> buildCostAnalysisReportDataSearch(
-          query, from, size);
-      default -> buildAggregateSearchBuilder(query, from, size);
+          context, query, from, size);
+      default -> buildAggregateSearchBuilder(context, query, from, size);
     };
   }
 
-  default S buildDataQualitySearchBuilder(String indexName, String query, int from, int size) {
+  default S buildDataQualitySearchBuilder(
+      S context, String indexName, String query, int from, int size) {
     return switch (indexName) {
       case "test_case_search_index",
           "testCase",
           "test_suite_search_index",
-          "testSuite" -> buildTestCaseSearch(query, from, size);
-      default -> buildAggregateSearchBuilder(query, from, size);
+          "testSuite" -> buildTestCaseSearch(context, query, from, size);
+      default -> buildAggregateSearchBuilder(context, query, from, size);
     };
   }
 
-  S buildTestCaseSearch(String query, int from, int size);
+  S buildTestCaseSearch(S context, String query, int from, int size);
 
-  S buildTestCaseResultSearch(String query, int from, int size);
+  S buildTestCaseResultSearch(S context, String query, int from, int size);
 
-  S buildTestCaseResolutionStatusSearch(String query, int from, int size);
+  S buildTestCaseResolutionStatusSearch(S context, String query, int from, int size);
 
-  S buildCostAnalysisReportDataSearch(String query, int from, int size);
+  S buildCostAnalysisReportDataSearch(S context, String query, int from, int size);
 
   default AssetTypeConfiguration findAssetTypeConfig(
       String indexName, SearchSettings searchSettings) {
@@ -151,8 +153,8 @@
         .orElse(searchSettings.getDefaultConfiguration());
   }
 
-  default Map<String, Float> getAllSearchFieldsFromSettings(SearchSettings searchSettings) {
-    Map<String, Float> fields = new HashMap<>();
+  default List<String> getAllSearchFieldsFromSettings(SearchSettings searchSettings) {
+    Set<String> fields = new HashSet<>();
 
     for (AssetTypeConfiguration config : searchSettings.getAssetTypeConfigurations()) {
       String assetType = config.getAssetType();
@@ -179,7 +181,9 @@
             .getSearchFields()
             .forEach(
                 fieldBoost ->
-                    fields.put(fieldBoost.getField(), fieldBoost.getBoost().floatValue()));
+                    fields.add(
+                        String.format(
+                            "%s^%s", fieldBoost.getField(), fieldBoost.getBoost().floatValue())));
       }
     }
 
@@ -190,10 +194,13 @@
           .getDefaultConfiguration()
           .getSearchFields()
           .forEach(
-              fieldBoost -> fields.put(fieldBoost.getField(), fieldBoost.getBoost().floatValue()));
+              fieldBoost ->
+                  fields.add(
+                      String.format(
+                          "%s^%s", fieldBoost.getField(), fieldBoost.getBoost().floatValue())));
     }
 
-    return fields;
+    return fields.stream().toList();
   }
 
   /**
@@ -203,7 +210,7 @@
    * @param fields map of field names to their boost weights
    * @return a query string query builder
    */
-  Q buildSearchQueryBuilder(String query, Map<String, Float> fields);
+  Q buildQuerySearchQuery(S context, String query, List<String> fields);
 
   /**
    * Build highlights for the specified fields.
Index: openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/TestCaseResultIndex.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/TestCaseResultIndex.java b/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/TestCaseResultIndex.java
--- a/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/TestCaseResultIndex.java	(revision d10bcccecad7a11724e8df23cf8c879f9f0673da)
+++ b/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/TestCaseResultIndex.java	(date 1744005110079)
@@ -1,6 +1,7 @@
 package org.openmetadata.service.search.indexes;
 
-import java.util.HashMap;
+import co.elastic.clients.elasticsearch.core.SearchRequest;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
@@ -16,6 +17,18 @@
 import org.openmetadata.service.util.JsonUtils;
 
 public record TestCaseResultIndex(TestCaseResult testCaseResult) implements SearchIndex {
+  public static final Set<String> FIELDS_WITH_WEIGHT = new HashSet<>();
+  public static final Set<String> HIGHLIGHT_FIELDS = new HashSet<>();
+
+  static {
+    Set<String> fields = new HashSet<>();
+    fields.add("testCase.fullyQualifiedName^10");
+    fields.add("testCase.displayName^15");
+    fields.add("testCase.name^10");
+    fields.add("testCase.description^5");
+    FIELDS_WITH_WEIGHT.addAll(fields);
+  }
+
   private static final Set<String> excludeFields = Set.of("changeDescription", "failedRowsSample");
 
   @Override
@@ -100,12 +113,26 @@
     esDoc.put("table", tableReference);
   }
 
-  public static Map<String, Float> getFields() {
-    Map<String, Float> fields = new HashMap<>();
-    fields.put("testCase.FullyQualifiedName", 10.0f);
-    fields.put("testCase.displayName", 15.0f);
-    fields.put("testCase.name", 10.0f);
-    fields.put("testCase.description", 5.0f);
-    return fields;
+  public static Set<String> getHighLightFields() {
+    return HIGHLIGHT_FIELDS;
+  }
+
+  public static Set<String> getFieldsWithWeights() {
+    return FIELDS_WITH_WEIGHT;
+  }
+
+  public static SearchRequest.Builder addEsEntityAggregation(SearchRequest.Builder requestBuilder) {
+    // add Base Aggregations for ElasticSearch
+    SearchIndex.addBaseElasticSearchAggregation(requestBuilder);
+    return requestBuilder;
+  }
+
+  public static os.org.opensearch.client.opensearch.core.SearchRequest.Builder
+      addOsEntityAggregation(
+          os.org.opensearch.client.opensearch.core.SearchRequest.Builder requestBuilder) {
+
+    // add Base Aggregations for OpenSearch
+    SearchIndex.addBaseOpenSearchAggregation(requestBuilder);
+    return requestBuilder;
   }
 }
Index: openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/ContainerIndex.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/ContainerIndex.java b/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/ContainerIndex.java
--- a/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/ContainerIndex.java	(revision d10bcccecad7a11724e8df23cf8c879f9f0673da)
+++ b/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/ContainerIndex.java	(date 1744005110081)
@@ -1,6 +1,7 @@
 package org.openmetadata.service.search.indexes;
 
 import static org.openmetadata.service.search.EntityBuilderConstant.DATA_MODEL_COLUMNS_NAME_KEYWORD;
+import static org.openmetadata.service.search.EntityBuilderConstant.FIELD_COLUMN_NAMES;
 
 import java.util.ArrayList;
 import java.util.HashSet;
@@ -15,6 +16,25 @@
 import org.openmetadata.service.search.models.SearchSuggest;
 
 public record ContainerIndex(Container container) implements ColumnIndex {
+  public static final Set<String> FIELDS_WITH_WEIGHT = new HashSet<>();
+  public static final Set<String> HIGHLIGHT_FIELDS = new HashSet<>();
+
+  static {
+    Set<String> fields = SearchIndex.getDefaultFields();
+    fields.add("dataModel.columns.name^2");
+    fields.add(String.format("%s^10", DATA_MODEL_COLUMNS_NAME_KEYWORD));
+    fields.add("dataModel.columns.displayName^2");
+    fields.add("dataModel.columns.description^1");
+    fields.add("dataModel.columns.children.name^2");
+    FIELDS_WITH_WEIGHT.addAll(fields);
+
+    HIGHLIGHT_FIELDS.addAll(
+        List.of(
+            "dataModel.columns.name",
+            "dataModel.columns.description",
+            "dataModel.columns.children.name"));
+  }
+
   @Override
   public List<SearchSuggest> getSuggest() {
     List<SearchSuggest> suggest = new ArrayList<>();
@@ -68,13 +88,48 @@
     return doc;
   }
 
-  public static Map<String, Float> getFields() {
-    Map<String, Float> fields = SearchIndex.getDefaultFields();
-    fields.put("dataModel.columns.name", 2.0f);
-    fields.put(DATA_MODEL_COLUMNS_NAME_KEYWORD, 10.0f);
-    fields.put("dataModel.columns.displayName", 2.0f);
-    fields.put("dataModel.columns.description", 1.0f);
-    fields.put("dataModel.columns.children.name", 2.0f);
-    return fields;
+  public static Set<String> getHighLightFields() {
+    return HIGHLIGHT_FIELDS;
+  }
+
+  public static Set<String> getFieldsWithWeights() {
+    return FIELDS_WITH_WEIGHT;
+  }
+
+  public static SearchRequest.Builder addEsEntityAggregation(SearchRequest.Builder requestBuilder) {
+    // add Base Aggregations for ElasticSearch
+    SearchIndex.addBaseElasticSearchAggregation(requestBuilder);
+
+    requestBuilder
+        .aggregations(
+            DATA_MODEL_COLUMNS_NAME_KEYWORD,
+            new Aggregation.Builder()
+                .terms(termAgg -> termAgg.field(DATA_MODEL_COLUMNS_NAME_KEYWORD))
+                .build())
+        .aggregations(
+            FIELD_COLUMN_NAMES,
+            new Aggregation.Builder().terms(termAgg -> termAgg.field(FIELD_COLUMN_NAMES)).build());
+    return requestBuilder;
+  }
+
+  public static os.org.opensearch.client.opensearch.core.SearchRequest.Builder
+      addOsEntityAggregation(
+          os.org.opensearch.client.opensearch.core.SearchRequest.Builder requestBuilder) {
+
+    // add Base Aggregations for OpenSearch
+    SearchIndex.addBaseOpenSearchAggregation(requestBuilder);
+
+    requestBuilder
+        .aggregations(
+            DATA_MODEL_COLUMNS_NAME_KEYWORD,
+            new os.org.opensearch.client.opensearch._types.aggregations.Aggregation.Builder()
+                .terms(termAgg -> termAgg.field(DATA_MODEL_COLUMNS_NAME_KEYWORD))
+                .build())
+        .aggregations(
+            FIELD_COLUMN_NAMES,
+            new os.org.opensearch.client.opensearch._types.aggregations.Aggregation.Builder()
+                .terms(termAgg -> termAgg.field(FIELD_COLUMN_NAMES))
+                .build());
+    return requestBuilder;
   }
 }
Index: openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/SearchEntityIndex.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/SearchEntityIndex.java b/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/SearchEntityIndex.java
--- a/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/SearchEntityIndex.java	(revision d10bcccecad7a11724e8df23cf8c879f9f0673da)
+++ b/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/SearchEntityIndex.java	(date 1744005110092)
@@ -1,8 +1,12 @@
 package org.openmetadata.service.search.indexes;
 
+import co.elastic.clients.elasticsearch._types.aggregations.Aggregation;
+import co.elastic.clients.elasticsearch.core.SearchRequest;
 import java.util.ArrayList;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 import org.openmetadata.service.Entity;
 import org.openmetadata.service.search.ParseTags;
 import org.openmetadata.service.search.models.SearchSuggest;
@@ -10,6 +14,19 @@
 public record SearchEntityIndex(org.openmetadata.schema.entity.data.SearchIndex searchIndex)
     implements SearchIndex {
 
+  public static final Set<String> FIELDS_WITH_WEIGHT = new HashSet<>();
+  public static final Set<String> HIGHLIGHT_FIELDS = new HashSet<>();
+
+  static {
+    Set<String> fields = SearchIndex.getDefaultFields();
+    fields.add("fields.name^7");
+    fields.add("fields.name.keyword^50");
+    fields.add("fields.children.description^1");
+    fields.add("fields.children.name^7");
+    fields.add("fields.children.name.keyword^5");
+    FIELDS_WITH_WEIGHT.addAll(fields);
+  }
+
   @Override
   public List<SearchSuggest> getSuggest() {
     List<SearchSuggest> suggest = new ArrayList<>();
@@ -36,13 +53,36 @@
     return doc;
   }
 
-  public static Map<String, Float> getFields() {
-    Map<String, Float> fields = SearchIndex.getDefaultFields();
-    fields.put("fields.name", 7.0f);
-    fields.put("fields.name.keyword", 50f);
-    fields.put("fields.children.description", 1.0f);
-    fields.put("fields.children.name", 7.0f);
-    fields.put("fields.children.name.keyword", 5.0f);
-    return fields;
+  public static Set<String> getHighLightFields() {
+    return HIGHLIGHT_FIELDS;
+  }
+
+  public static Set<String> getFieldsWithWeights() {
+    return FIELDS_WITH_WEIGHT;
+  }
+
+  public static SearchRequest.Builder addEsEntityAggregation(SearchRequest.Builder requestBuilder) {
+    // add Base Aggregations for Elastic Search
+    SearchIndex.addBaseElasticSearchAggregation(requestBuilder);
+
+    requestBuilder.aggregations(
+        "fields.name.keyword",
+        new Aggregation.Builder().terms(termAgg -> termAgg.field("fields.name.keyword")).build());
+    return requestBuilder;
+  }
+
+  public static os.org.opensearch.client.opensearch.core.SearchRequest.Builder
+      addOsEntityAggregation(
+          os.org.opensearch.client.opensearch.core.SearchRequest.Builder requestBuilder) {
+
+    // add Base Aggregations for OpenSearch
+    SearchIndex.addBaseOpenSearchAggregation(requestBuilder);
+
+    requestBuilder.aggregations(
+        "fields.name.keyword",
+        new os.org.opensearch.client.opensearch._types.aggregations.Aggregation.Builder()
+            .terms(termAgg -> termAgg.field("fields.name.keyword"))
+            .build());
+    return requestBuilder;
   }
 }
Index: openmetadata-service/src/main/java/org/openmetadata/service/search/elasticsearch/queries/ElasticQueryBuilderFactory.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openmetadata-service/src/main/java/org/openmetadata/service/search/elasticsearch/queries/ElasticQueryBuilderFactory.java b/openmetadata-service/src/main/java/org/openmetadata/service/search/elasticsearch/queries/ElasticQueryBuilderFactory.java
--- a/openmetadata-service/src/main/java/org/openmetadata/service/search/elasticsearch/queries/ElasticQueryBuilderFactory.java	(revision d10bcccecad7a11724e8df23cf8c879f9f0673da)
+++ b/openmetadata-service/src/main/java/org/openmetadata/service/search/elasticsearch/queries/ElasticQueryBuilderFactory.java	(date 1744005109925)
@@ -35,4 +35,31 @@
   public OMQueryBuilder existsQuery(String field) {
     return new ElasticQueryBuilder().existsQuery(field);
   }
+
+  @Override
+  public OMQueryBuilder queryStringQuery(
+      String query,
+      List<String> fields,
+      String textQueryType,
+      String operator,
+      String fuzziness,
+      int fuzzinessPrefixLength,
+      double tieBreaker) {
+    return new ElasticQueryBuilder()
+        .queryStringQuery(
+            query, fields, textQueryType, operator, fuzziness, fuzzinessPrefixLength, tieBreaker);
+  }
+
+  @Override
+  public OMQueryBuilder multiMatchQuery(
+      String query,
+      List<String> fields,
+      String operator,
+      String queryType,
+      String fuzziness,
+      int prefixLength,
+      double tieBreaker) {
+    return new ElasticQueryBuilder()
+        .multiMatchQuery(query, fields, queryType, operator, fuzziness, prefixLength, tieBreaker);
+  }
 }
Index: openmetadata-service/src/main/java/org/openmetadata/service/search/index/OpenSearchIndexCrud.java
===================================================================
diff --git a/openmetadata-service/src/main/java/org/openmetadata/service/search/index/OpenSearchIndexCrud.java b/openmetadata-service/src/main/java/org/openmetadata/service/search/index/OpenSearchIndexCrud.java
new file mode 100644
--- /dev/null	(date 1744005110157)
+++ b/openmetadata-service/src/main/java/org/openmetadata/service/search/index/OpenSearchIndexCrud.java	(date 1744005110157)
@@ -0,0 +1,162 @@
+package org.openmetadata.service.search.index;
+
+import static org.openmetadata.common.utils.CommonUtil.nullOrEmpty;
+
+import java.io.StringReader;
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.Set;
+import lombok.extern.slf4j.Slf4j;
+import org.openmetadata.service.search.models.IndexMapping;
+import org.openmetadata.service.util.JsonUtils;
+import os.org.opensearch.client.opensearch.OpenSearchClient;
+import os.org.opensearch.client.opensearch.indices.CreateIndexRequest;
+import os.org.opensearch.client.opensearch.indices.CreateIndexResponse;
+import os.org.opensearch.client.opensearch.indices.DeleteIndexRequest;
+import os.org.opensearch.client.opensearch.indices.DeleteIndexResponse;
+import os.org.opensearch.client.opensearch.indices.ExistsRequest;
+import os.org.opensearch.client.opensearch.indices.PutMappingRequest;
+import os.org.opensearch.client.opensearch.indices.PutMappingResponse;
+import os.org.opensearch.client.opensearch.indices.UpdateAliasesRequest;
+import os.org.opensearch.client.opensearch.indices.update_aliases.Action;
+import os.org.opensearch.client.opensearch.indices.update_aliases.AddAction;
+
+@Slf4j
+public class OpenSearchIndexCrud implements SearchIndexCrud {
+  protected final OpenSearchClient client;
+  protected boolean isClientAvailable = false;
+  private String clusterAlias = "";
+
+  public OpenSearchIndexCrud(OpenSearchClient client, String clusterAlias) {
+    this.client = client;
+    this.isClientAvailable = client != null;
+    this.clusterAlias = nullOrEmpty(clusterAlias) ? "" : clusterAlias;
+  }
+
+  @Override
+  public boolean indexExists(IndexMapping indexMapping) {
+    try {
+      ExistsRequest gRequest =
+          ExistsRequest.of(c -> c.index(indexMapping.getIndexName(clusterAlias)).local(false));
+      return client.indices().exists(gRequest).value();
+    } catch (Exception e) {
+      LOG.error(
+          String.format(
+              "Failed to check if index %s exists due to", indexMapping.getIndexName(clusterAlias)),
+          e);
+      return false;
+    }
+  }
+
+  @Override
+  public void createIndex(IndexMapping indexMapping, String indexMappingContent) {
+    if (Boolean.TRUE.equals(isClientAvailable)) {
+      try {
+        CreateIndexResponse createIndexResponse =
+            client
+                .indices()
+                .create(
+                    CreateIndexRequest.of(
+                        c ->
+                            c.index(indexMapping.getIndexName(clusterAlias))
+                                .withJson(new StringReader(indexMappingContent))));
+        LOG.debug(
+            "{} Created {}",
+            indexMapping.getIndexName(clusterAlias),
+            createIndexResponse.acknowledged());
+        // creating alias for indexes
+        createAliases(indexMapping);
+      } catch (Exception e) {
+        LOG.error(
+            String.format(
+                "Failed to create index for %s due to", indexMapping.getIndexName(clusterAlias)),
+            e);
+      }
+    } else {
+      LOG.error(
+          "Failed to create Open Search index as client is not property configured, Please check your OpenMetadata configuration");
+    }
+  }
+
+  @Override
+  public void addIndexAlias(IndexMapping indexMapping, String... aliasName) {
+    try {
+      Action updateAction =
+          Action.of(
+              action ->
+                  action.add(
+                      AddAction.of(
+                          addAcc ->
+                              addAcc
+                                  .index(indexMapping.getIndexName(clusterAlias))
+                                  .aliases(Arrays.asList(aliasName)))));
+      UpdateAliasesRequest updateAliasesRequest =
+          UpdateAliasesRequest.of(a -> a.actions(updateAction));
+      client.indices().updateAliases(updateAliasesRequest);
+    } catch (Exception e) {
+      LOG.error(
+          String.format(
+              "Failed to create alias for %s due to", indexMapping.getAlias(clusterAlias)),
+          e);
+    }
+  }
+
+  @Override
+  public void createAliases(IndexMapping indexMapping) {
+    try {
+      Set<String> aliases = new HashSet<>(indexMapping.getParentAliases(clusterAlias));
+      aliases.add(indexMapping.getAlias(clusterAlias));
+      Action updateAction =
+          Action.of(
+              action ->
+                  action.add(
+                      AddAction.of(
+                          addAcc ->
+                              addAcc
+                                  .index(indexMapping.getIndexName(clusterAlias))
+                                  .aliases(aliases.stream().toList()))));
+      UpdateAliasesRequest updateAliasesRequest =
+          UpdateAliasesRequest.of(a -> a.actions(updateAction));
+      client.indices().updateAliases(updateAliasesRequest);
+    } catch (Exception e) {
+      LOG.error(
+          String.format(
+              "Failed to create alias for %s due to", indexMapping.getAlias(clusterAlias)),
+          e);
+    }
+  }
+
+  @Override
+  public void updateIndex(IndexMapping indexMapping, String indexMappingContent) {
+    try {
+      String mappingStr = JsonUtils.readTree(indexMappingContent).get("mappings").toString();
+      PutMappingRequest putMappingRequest =
+          PutMappingRequest.of(
+              p ->
+                  p.index(indexMapping.getIndexName(clusterAlias))
+                      .withJson(new StringReader(mappingStr)));
+      PutMappingResponse putMappingResponse = client.indices().putMapping(putMappingRequest);
+      LOG.debug(
+          "{} Updated {}", indexMapping.getIndexMappingFile(), putMappingResponse.acknowledged());
+    } catch (Exception e) {
+      LOG.warn(
+          String.format(
+              "Failed to Update Open Search index %s", indexMapping.getIndexName(clusterAlias)));
+    }
+  }
+
+  @Override
+  public void deleteIndex(IndexMapping indexMapping) {
+    try {
+      DeleteIndexRequest request =
+          DeleteIndexRequest.of(d -> d.index(indexMapping.getIndexName(clusterAlias)));
+      DeleteIndexResponse deleteIndexResponse = client.indices().delete(request);
+      LOG.debug(
+          "{} Deleted {}",
+          indexMapping.getIndexName(clusterAlias),
+          deleteIndexResponse.acknowledged());
+    } catch (Exception e) {
+      LOG.error("Failed to delete Open Search indexes due to", e);
+    }
+  }
+}
Index: openmetadata-service/src/main/java/org/openmetadata/service/search/aggregation/OSAggregation.java
===================================================================
diff --git a/openmetadata-service/src/main/java/org/openmetadata/service/search/aggregation/OSAggregation.java b/openmetadata-service/src/main/java/org/openmetadata/service/search/aggregation/OSAggregation.java
new file mode 100644
--- /dev/null	(date 1744005110012)
+++ b/openmetadata-service/src/main/java/org/openmetadata/service/search/aggregation/OSAggregation.java	(date 1744005110012)
@@ -0,0 +1,50 @@
+package org.openmetadata.service.search.aggregation;
+
+import java.util.HashMap;
+import java.util.Map;
+import os.org.opensearch.client.opensearch._types.aggregations.Aggregation;
+
+public class OSAggregation implements OMAggregation {
+  protected Map<String, Aggregation> aggregations = new HashMap<>();
+
+  @Override
+  public OMAggregation addAggregation(String name, OMAggregation aggregation) {
+    if (name == null || aggregation == null) {
+      throw new IllegalArgumentException("Name and aggregation cannot be null");
+    }
+    if (aggregation instanceof OSAggregation osAggregation) {
+      this.aggregations.put(name, (osAggregation).getRawAggregation(name));
+    }
+    return this;
+  }
+
+  @Override
+  public OMAggregation getAggregation(String name) {
+    Aggregation agg = aggregations.get(name);
+    return agg != null ? new OSAggregation().withAggregation(name, agg) : null;
+  }
+
+  @Override
+  public boolean hasAggregations() {
+    return !aggregations.isEmpty();
+  }
+
+  @Override
+  public int size() {
+    return aggregations.size();
+  }
+
+  @Override
+  public void clear() {
+    aggregations.clear();
+  }
+
+  public Aggregation getRawAggregation(String name) {
+    return aggregations.get(name);
+  }
+
+  private OSAggregation withAggregation(String name, Aggregation aggregation) {
+    this.aggregations.put(name, aggregation);
+    return this;
+  }
+}
Index: openmetadata-service/src/main/java/org/openmetadata/service/search/SearchContext.java
===================================================================
diff --git a/openmetadata-service/src/main/java/org/openmetadata/service/search/SearchContext.java b/openmetadata-service/src/main/java/org/openmetadata/service/search/SearchContext.java
new file mode 100644
--- /dev/null	(date 1744005110154)
+++ b/openmetadata-service/src/main/java/org/openmetadata/service/search/SearchContext.java	(date 1744005110154)
@@ -0,0 +1,124 @@
+package org.openmetadata.service.search;
+
+import static org.openmetadata.common.utils.CommonUtil.nullOrEmpty;
+import static org.openmetadata.service.search.EntityBuilderConstant.MAX_RESULT_HITS;
+
+import es.co.elastic.clients.elasticsearch._types.FieldSort;
+import es.co.elastic.clients.elasticsearch._types.FieldValue;
+import es.co.elastic.clients.elasticsearch._types.SortOptions;
+import es.co.elastic.clients.elasticsearch._types.SortOrder;
+import es.co.elastic.clients.elasticsearch._types.aggregations.Aggregation;
+import es.co.elastic.clients.elasticsearch._types.mapping.FieldType;
+import es.co.elastic.clients.elasticsearch._types.query_dsl.BoolQuery;
+import es.co.elastic.clients.elasticsearch._types.query_dsl.QueryBuilders;
+import es.co.elastic.clients.elasticsearch.core.SearchRequest;
+import es.co.elastic.clients.elasticsearch.core.search.SourceConfig;
+import es.co.elastic.clients.elasticsearch.core.search.SourceFilter;
+import es.co.elastic.clients.elasticsearch.core.search.TrackHits;
+import java.io.StringReader;
+import java.util.HashMap;
+import java.util.Map;
+import lombok.Builder;
+import lombok.Getter;
+import lombok.Setter;
+import lombok.extern.slf4j.Slf4j;
+import org.openmetadata.schema.search.SearchRequestInternal;
+import org.openmetadata.service.search.elasticsearch.queries.ElasticQueryBuilder;
+import org.openmetadata.service.search.highlight.ElasticSearchHighlightBuilder;
+import org.openmetadata.service.search.highlight.OMHighlight;
+import org.openmetadata.service.search.queries.OMQueryBuilder;
+import org.openmetadata.service.search.queries.QueryBuilderFactory;
+
+@Getter
+@Setter
+@Builder
+@Slf4j
+public class SearchContext {
+  private SearchRequestInternal searchRequestInternal;
+  protected QueryBuilderFactory queryBuilder;
+  private OMHighlight highlightBuilder;
+  protected String index;
+  protected OMQueryBuilder query;
+  protected Map<String, Aggregation> aggregations = new HashMap<>();
+  private int from;
+  private int size;
+  private String postFilter;
+  private final SearchRequest.Builder finalRequestBuilder = new SearchRequest.Builder();
+
+  public SearchContext(QueryBuilderFactory queryBuilder, SearchRequestInternal requestInternal) {
+    this.queryBuilder = queryBuilder;
+    this.searchRequestInternal = requestInternal;
+  }
+
+  private void addPostFilter() {
+    if (!nullOrEmpty(postFilter)) {
+      try {
+        BoolQuery filter = QueryBuilders.bool().withJson(new StringReader(postFilter)).build();
+        finalRequestBuilder.postFilter(filter._toQuery());
+      } catch (Exception ex) {
+        LOG.warn("Error parsing post_filter from query parameters, ignoring filter", ex);
+      }
+    }
+  }
+
+  private void addSearchAfter() {
+    if (!nullOrEmpty(searchRequestInternal.getSearchAfter())) {
+      finalRequestBuilder.searchAfter(FieldValue.of(searchRequestInternal.getSearchAfter()));
+    }
+  }
+
+  private void addSortField() {
+    if (!nullOrEmpty(searchRequestInternal.getSortFieldParam())
+        && Boolean.FALSE.equals(searchRequestInternal.getIsHierarchy())) {
+      FieldSort.Builder fieldSortBuilder =
+          new FieldSort.Builder()
+              .order(SortOrder.valueOf(searchRequestInternal.getSortOrder()))
+              .field(searchRequestInternal.getSortFieldParam());
+      // Score is an internal ES Field
+      if (!searchRequestInternal.getSortFieldParam().equalsIgnoreCase("_score")) {
+        fieldSortBuilder.unmappedType(FieldType.Integer);
+      }
+      finalRequestBuilder.sort(new SortOptions.Builder().field(fieldSortBuilder.build()).build());
+    }
+  }
+
+  private void addSource() {
+    SourceFilter.Builder sourceFilter =
+        new SourceFilter.Builder()
+            .includes(searchRequestInternal.getIncludeSourceFields())
+            .excludes(null);
+    SourceConfig.Builder sourceConfig = new SourceConfig.Builder();
+    sourceConfig.fetch(searchRequestInternal.getFetchSource());
+    sourceConfig.filter(sourceFilter.build());
+    finalRequestBuilder.source(sourceConfig.build());
+  }
+
+  private void addTrackTotalHit() {
+     /* for performance reasons ElasticSearch doesn't provide accurate hits
+    if we enable trackTotalHits parameter it will try to match every result, count and return hits
+    however in most cases for search results an approximate value is good enough.
+    we are displaying total entity counts in landing page and explore page where we need the total count
+    https://github.com/elastic/elasticsearch/issues/33028 */
+    TrackHits.Builder trackHitsBuilder = new TrackHits.Builder();
+    if (Boolean.TRUE.equals(searchRequestInternal.getTrackTotalHits())) {
+      trackHitsBuilder.enabled(true);
+    } else {
+      trackHitsBuilder.count(MAX_RESULT_HITS);
+    }
+  }
+
+  public SearchRequest buildSearchRequest() {
+    finalRequestBuilder.query(((ElasticQueryBuilder) query).build());
+    finalRequestBuilder.highlight(
+        ((ElasticSearchHighlightBuilder) highlightBuilder).getHighlight());
+    addPostFilter();
+    addSearchAfter();
+    addSortField();
+    addSource();
+    addTrackTotalHit();
+    finalRequestBuilder.timeout("30s");
+    //NOT sure why we are doing thing here, it was part of doSearch() maybe to search via aliases?
+    finalRequestBuilder.index(searchRequestInternal.getIndex());
+    return finalRequestBuilder.build();
+  }
+}
Index: openmetadata-service/src/main/java/org/openmetadata/service/search/SearchRepository.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openmetadata-service/src/main/java/org/openmetadata/service/search/SearchRepository.java b/openmetadata-service/src/main/java/org/openmetadata/service/search/SearchRepository.java
--- a/openmetadata-service/src/main/java/org/openmetadata/service/search/SearchRepository.java	(revision d10bcccecad7a11724e8df23cf8c879f9f0673da)
+++ b/openmetadata-service/src/main/java/org/openmetadata/service/search/SearchRepository.java	(date 1744005109937)
@@ -85,7 +85,7 @@
 import org.openmetadata.schema.dataInsight.DataInsightChartResult;
 import org.openmetadata.schema.entity.classification.Tag;
 import org.openmetadata.schema.entity.data.QueryCostSearchResult;
-import org.openmetadata.schema.search.SearchRequest;
+import org.openmetadata.schema.search.SearchRequestInternal;
 import org.openmetadata.schema.service.configuration.elasticsearch.ElasticSearchConfiguration;
 import org.openmetadata.schema.service.configuration.elasticsearch.NaturalLanguageSearchConfiguration;
 import org.openmetadata.schema.tests.DataQualityReport;
@@ -256,7 +256,7 @@
   }
 
   public boolean indexExists(IndexMapping indexMapping) {
-    return searchClient.indexExists(indexMapping.getIndexName(clusterAlias));
+    return searchClient.indexExists(indexMapping);
   }
 
   public void createIndex(IndexMapping indexMapping) {
@@ -1026,17 +1026,18 @@
     return scriptTxt.toString();
   }
 
-  public Response search(SearchRequest request, SubjectContext subjectContext) throws IOException {
+  public Response search(SearchRequestInternal request, SubjectContext subjectContext)
+      throws IOException {
     return searchClient.search(request, subjectContext);
   }
 
   public Response previewSearch(
-      SearchRequest request, SubjectContext subjectContext, SearchSettings searchSettings)
+      SearchRequestInternal request, SubjectContext subjectContext, SearchSettings searchSettings)
       throws IOException {
     return searchClient.previewSearch(request, subjectContext, searchSettings);
   }
 
-  public Response searchWithNLQ(SearchRequest request, SubjectContext subjectContext)
+  public Response searchWithNLQ(SearchRequestInternal request, SubjectContext subjectContext)
       throws IOException {
     return searchClient.searchWithNLQ(request, subjectContext);
   }
@@ -1173,7 +1174,7 @@
     return searchClient.genericAggregation(query, index, aggregationMetadata);
   }
 
-  public Response suggest(SearchRequest request) throws IOException {
+  public Response suggest(SearchRequestInternal request) throws IOException {
     return searchClient.suggest(request);
   }
 
@@ -1200,8 +1201,8 @@
               "{\"query\":{\"bool\":{\"must\":[{\"wildcard\":{\"fullyQualifiedName\":\"%s.*\"}}]}}}",
               ReindexingUtil.escapeDoubleQuotes(entityFQN));
 
-      SearchRequest searchRequest =
-          new SearchRequest()
+      SearchRequestInternal searchRequest =
+          new SearchRequestInternal()
               .withQuery("")
               .withSize(size)
               .withIndex(Entity.getSearchRepository().getIndexOrAliasName(indexName))
Index: openmetadata-service/src/main/java/org/openmetadata/service/search/highlight/OMHighlight.java
===================================================================
diff --git a/openmetadata-service/src/main/java/org/openmetadata/service/search/highlight/OMHighlight.java b/openmetadata-service/src/main/java/org/openmetadata/service/search/highlight/OMHighlight.java
new file mode 100644
--- /dev/null	(date 1744005109999)
+++ b/openmetadata-service/src/main/java/org/openmetadata/service/search/highlight/OMHighlight.java	(date 1744005109999)
@@ -0,0 +1,7 @@
+package org.openmetadata.service.search.highlight;
+
+import java.util.List;
+
+public interface OMHighlight {
+  OMHighlight buildHighlights(List<String> fields);
+}
Index: openmetadata-service/src/main/java/org/openmetadata/service/search/aggregation/AggregationBuilder.java
===================================================================
diff --git a/openmetadata-service/src/main/java/org/openmetadata/service/search/aggregation/AggregationBuilder.java b/openmetadata-service/src/main/java/org/openmetadata/service/search/aggregation/AggregationBuilder.java
new file mode 100644
--- /dev/null	(date 1744005109990)
+++ b/openmetadata-service/src/main/java/org/openmetadata/service/search/aggregation/AggregationBuilder.java	(date 1744005109990)
@@ -0,0 +1,34 @@
+package org.openmetadata.service.search.aggregation;
+
+public class AggregationBuilder implements OMAggregation {
+  private final OMAggregation delegate;
+
+  public AggregationBuilder(OMAggregation delegate) {
+    this.delegate = delegate;
+  }
+
+  @Override
+  public OMAggregation addAggregation(String name, OMAggregation aggregation) {
+    return delegate.addAggregation(name, aggregation);
+  }
+
+  @Override
+  public OMAggregation getAggregation(String name) {
+    return delegate.getAggregation(name);
+  }
+
+  @Override
+  public boolean hasAggregations() {
+    return delegate.hasAggregations();
+  }
+
+  @Override
+  public int size() {
+    return delegate.size();
+  }
+
+  @Override
+  public void clear() {
+    delegate.clear();
+  }
+}
Index: openmetadata-service/src/main/java/org/openmetadata/service/search/aggregation/ESAggregation.java
===================================================================
diff --git a/openmetadata-service/src/main/java/org/openmetadata/service/search/aggregation/ESAggregation.java b/openmetadata-service/src/main/java/org/openmetadata/service/search/aggregation/ESAggregation.java
new file mode 100644
--- /dev/null	(date 1744005109994)
+++ b/openmetadata-service/src/main/java/org/openmetadata/service/search/aggregation/ESAggregation.java	(date 1744005109994)
@@ -0,0 +1,48 @@
+package org.openmetadata.service.search.aggregation;
+
+import es.co.elastic.clients.elasticsearch._types.aggregations.Aggregation;
+import java.util.HashMap;
+import java.util.Map;
+
+public class ESAggregation implements OMAggregation {
+  protected Map<String, Aggrega> aggregations = new HashMap<>();
+
+  @Override
+  public OMAggregation addAggregation(String name, AggregationContainer aggregation) {
+    if (name == null || aggregation == null) {
+      throw new IllegalArgumentException("Name and aggregation cannot be null");
+    }
+    this.aggregations.put(name, aggregation);
+    return this;
+  }
+
+  @Override
+  public OMAggregation getAggregation(String name) {
+    Aggregation agg = aggregations.get(name);
+    return agg != null ? new ESAggregation().withAggregation(name, agg) : null;
+  }
+
+  @Override
+  public boolean hasAggregations() {
+    return !aggregations.isEmpty();
+  }
+
+  @Override
+  public int size() {
+    return aggregations.size();
+  }
+
+  @Override
+  public void clear() {
+    aggregations.clear();
+  }
+
+  public Aggregation getRawAggregation(String name) {
+    return aggregations.get(name);
+  }
+
+  private ESAggregation withAggregation(String name, Aggregation aggregation) {
+    this.aggregations.put(name, aggregation);
+    return this;
+  }
+}
Index: openmetadata-service/src/main/java/org/openmetadata/service/search/index/SearchIndexCrud.java
===================================================================
diff --git a/openmetadata-service/src/main/java/org/openmetadata/service/search/index/SearchIndexCrud.java b/openmetadata-service/src/main/java/org/openmetadata/service/search/index/SearchIndexCrud.java
new file mode 100644
--- /dev/null	(date 1744005110180)
+++ b/openmetadata-service/src/main/java/org/openmetadata/service/search/index/SearchIndexCrud.java	(date 1744005110180)
@@ -0,0 +1,17 @@
+package org.openmetadata.service.search.index;
+
+import org.openmetadata.service.search.models.IndexMapping;
+
+public interface SearchIndexCrud {
+  boolean indexExists(IndexMapping indexMapping);
+
+  void createIndex(IndexMapping indexMapping, String indexMappingContent);
+
+  void addIndexAlias(IndexMapping indexMapping, String... aliasName);
+
+  void createAliases(IndexMapping indexMapping);
+
+  void updateIndex(IndexMapping indexMapping, String indexMappingContent);
+
+  void deleteIndex(IndexMapping indexMapping);
+}
Index: openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/APIEndpointIndex.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/APIEndpointIndex.java b/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/APIEndpointIndex.java
--- a/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/APIEndpointIndex.java	(revision d10bcccecad7a11724e8df23cf8c879f9f0673da)
+++ b/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/APIEndpointIndex.java	(date 1744005110096)
@@ -1,5 +1,7 @@
 package org.openmetadata.service.search.indexes;
 
+import static org.openmetadata.service.search.EntityBuilderConstant.ES_MESSAGE_SCHEMA_FIELD;
+
 import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.List;
@@ -17,6 +19,19 @@
 import org.openmetadata.service.util.FullyQualifiedName;
 
 public class APIEndpointIndex implements SearchIndex {
+  public static final Set<String> FIELDS_WITH_WEIGHT = new HashSet<>();
+  public static final Set<String> HIGHLIGHT_FIELDS = new HashSet<>();
+
+  static {
+    Set<String> fields = SearchIndex.getDefaultFields();
+    fields.add(String.format("%s^7", ES_MESSAGE_SCHEMA_FIELD));
+    fields.add("responseSchema.schemaFields.name.keyword^5");
+    fields.add("responseSchema.schemaFields.description^1");
+    fields.add("responseSchema.schemaFields.children.name^7");
+    fields.add("responseSchema.schemaFields.children.keyword^5");
+    FIELDS_WITH_WEIGHT.addAll(fields);
+  }
+
   final Set<String> excludeAPIEndpointFields = Set.of("sampleData");
   final APIEndpoint apiEndpoint;
 
@@ -131,12 +146,11 @@
     }
   }
 
-  public static Map<String, Float> getFields() {
-    Map<String, Float> fields = SearchIndex.getDefaultFields();
-    fields.put("responseSchema.schemaFields.name.keyword", 5.0f);
-    fields.put("responseSchema.schemaFields.description", 1.0f);
-    fields.put("responseSchema.schemaFields.children.name", 7.0f);
-    fields.put("responseSchema.schemaFields.children.keyword", 5.0f);
-    return fields;
+  public static Set<String> getHighLightFields() {
+    return HIGHLIGHT_FIELDS;
+  }
+
+  public static Set<String> getFieldsWithWeights() {
+    return FIELDS_WITH_WEIGHT;
   }
 }
Index: openmetadata-service/src/main/java/org/openmetadata/service/search/highlight/OpenSearchHighlightBuilder.java
===================================================================
diff --git a/openmetadata-service/src/main/java/org/openmetadata/service/search/highlight/OpenSearchHighlightBuilder.java b/openmetadata-service/src/main/java/org/openmetadata/service/search/highlight/OpenSearchHighlightBuilder.java
new file mode 100644
--- /dev/null	(date 1744005110175)
+++ b/openmetadata-service/src/main/java/org/openmetadata/service/search/highlight/OpenSearchHighlightBuilder.java	(date 1744005110175)
@@ -0,0 +1,39 @@
+package org.openmetadata.service.search.highlight;
+
+import static org.openmetadata.service.search.EntityBuilderConstant.POST_TAG;
+import static org.openmetadata.service.search.EntityBuilderConstant.PRE_TAG;
+
+import java.util.List;
+import java.util.Map;
+import java.util.stream.Collectors;
+import lombok.Getter;
+import os.org.opensearch.client.opensearch.core.search.BuiltinHighlighterType;
+import os.org.opensearch.client.opensearch.core.search.Highlight;
+import os.org.opensearch.client.opensearch.core.search.HighlightField;
+import os.org.opensearch.client.opensearch.core.search.HighlighterType;
+
+@Getter
+public class OpenSearchHighlightBuilder implements OMHighlight {
+  private Highlight highlight;
+
+  public OMHighlight buildHighlights(List<String> fields) {
+    Highlight.Builder hb = new Highlight.Builder();
+    hb.preTags(PRE_TAG);
+    hb.postTags(POST_TAG);
+    hb.requireFieldMatch(false);
+    Map<String, HighlightField> highlightFields =
+        fields.stream()
+            .collect(
+                Collectors.toMap(
+                    field -> field,
+                    field ->
+                        HighlightField.of(
+                            hf ->
+                                hf.type(
+                                    HighlighterType.of(
+                                        h -> h.builtin(BuiltinHighlighterType.Unified))))));
+    hb.fields(highlightFields);
+    this.highlight = hb.build();
+    return this;
+  }
+}
Index: openmetadata-service/src/main/java/org/openmetadata/service/search/index/ElasticSearchIndexCrud.java
===================================================================
diff --git a/openmetadata-service/src/main/java/org/openmetadata/service/search/index/ElasticSearchIndexCrud.java b/openmetadata-service/src/main/java/org/openmetadata/service/search/index/ElasticSearchIndexCrud.java
new file mode 100644
--- /dev/null	(date 1744005110178)
+++ b/openmetadata-service/src/main/java/org/openmetadata/service/search/index/ElasticSearchIndexCrud.java	(date 1744005110178)
@@ -0,0 +1,162 @@
+package org.openmetadata.service.search.index;
+
+import static org.openmetadata.common.utils.CommonUtil.nullOrEmpty;
+
+import es.co.elastic.clients.elasticsearch.ElasticsearchClient;
+import es.co.elastic.clients.elasticsearch.indices.CreateIndexRequest;
+import es.co.elastic.clients.elasticsearch.indices.CreateIndexResponse;
+import es.co.elastic.clients.elasticsearch.indices.DeleteIndexRequest;
+import es.co.elastic.clients.elasticsearch.indices.DeleteIndexResponse;
+import es.co.elastic.clients.elasticsearch.indices.ExistsRequest;
+import es.co.elastic.clients.elasticsearch.indices.PutMappingRequest;
+import es.co.elastic.clients.elasticsearch.indices.PutMappingResponse;
+import es.co.elastic.clients.elasticsearch.indices.UpdateAliasesRequest;
+import es.co.elastic.clients.elasticsearch.indices.update_aliases.Action;
+import es.co.elastic.clients.elasticsearch.indices.update_aliases.AddAction;
+import java.io.StringReader;
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.Set;
+import lombok.extern.slf4j.Slf4j;
+import org.openmetadata.service.search.models.IndexMapping;
+import org.openmetadata.service.util.JsonUtils;
+
+@Slf4j
+public class ElasticSearchIndexCrud implements SearchIndexCrud {
+  protected final ElasticsearchClient client;
+  protected boolean isClientAvailable = false;
+  private String clusterAlias = "";
+
+  public ElasticSearchIndexCrud(ElasticsearchClient client, String clusterAlias) {
+    this.client = client;
+    this.isClientAvailable = client != null;
+    this.clusterAlias = nullOrEmpty(clusterAlias) ? "" : clusterAlias;
+  }
+
+  @Override
+  public boolean indexExists(IndexMapping indexMapping) {
+    try {
+      ExistsRequest gRequest =
+          ExistsRequest.of(c -> c.index(indexMapping.getIndexName(clusterAlias)).local(false));
+      return client.indices().exists(gRequest).value();
+    } catch (Exception e) {
+      LOG.error(
+          String.format(
+              "Failed to check if index %s exists due to", indexMapping.getIndexName(clusterAlias)),
+          e);
+      return false;
+    }
+  }
+
+  @Override
+  public void createIndex(IndexMapping indexMapping, String indexMappingContent) {
+    if (Boolean.TRUE.equals(isClientAvailable)) {
+      try {
+        CreateIndexResponse createIndexResponse =
+            client
+                .indices()
+                .create(
+                    CreateIndexRequest.of(
+                        c ->
+                            c.index(indexMapping.getIndexName(clusterAlias))
+                                .withJson(new StringReader(indexMappingContent))));
+        LOG.debug(
+            "{} Created {}",
+            indexMapping.getIndexName(clusterAlias),
+            createIndexResponse.acknowledged());
+        // creating alias for indexes
+        createAliases(indexMapping);
+      } catch (Exception e) {
+        LOG.error(
+            String.format(
+                "Failed to create index for %s due to", indexMapping.getIndexName(clusterAlias)),
+            e);
+      }
+    } else {
+      LOG.error(
+          "Failed to create Elastic Search index as client is not property configured, Please check your OpenMetadata configuration");
+    }
+  }
+
+  @Override
+  public void addIndexAlias(IndexMapping indexMapping, String... aliasName) {
+    try {
+      Action updateAction =
+          Action.of(
+              action ->
+                  action.add(
+                      AddAction.of(
+                          addAcc ->
+                              addAcc
+                                  .index(indexMapping.getIndexName(clusterAlias))
+                                  .aliases(Arrays.asList(aliasName)))));
+      UpdateAliasesRequest updateAliasesRequest =
+          UpdateAliasesRequest.of(a -> a.actions(updateAction));
+      client.indices().updateAliases(updateAliasesRequest);
+    } catch (Exception e) {
+      LOG.error(
+          String.format(
+              "Failed to create alias for %s due to", indexMapping.getAlias(clusterAlias)),
+          e);
+    }
+  }
+
+  @Override
+  public void createAliases(IndexMapping indexMapping) {
+    try {
+      Set<String> aliases = new HashSet<>(indexMapping.getParentAliases(clusterAlias));
+      aliases.add(indexMapping.getAlias(clusterAlias));
+      Action updateAction =
+          Action.of(
+              action ->
+                  action.add(
+                      AddAction.of(
+                          addAcc ->
+                              addAcc
+                                  .index(indexMapping.getIndexName(clusterAlias))
+                                  .aliases(aliases.stream().toList()))));
+      UpdateAliasesRequest updateAliasesRequest =
+          UpdateAliasesRequest.of(a -> a.actions(updateAction));
+      client.indices().updateAliases(updateAliasesRequest);
+    } catch (Exception e) {
+      LOG.error(
+          String.format(
+              "Failed to create alias for %s due to", indexMapping.getAlias(clusterAlias)),
+          e);
+    }
+  }
+
+  @Override
+  public void updateIndex(IndexMapping indexMapping, String indexMappingContent) {
+    try {
+      String mappingStr = JsonUtils.readTree(indexMappingContent).get("mappings").toString();
+      PutMappingRequest putMappingRequest =
+          PutMappingRequest.of(
+              p ->
+                  p.index(indexMapping.getIndexName(clusterAlias))
+                      .withJson(new StringReader(mappingStr)));
+      PutMappingResponse putMappingResponse = client.indices().putMapping(putMappingRequest);
+      LOG.debug(
+          "{} Updated {}", indexMapping.getIndexMappingFile(), putMappingResponse.acknowledged());
+    } catch (Exception e) {
+      LOG.warn(
+          String.format(
+              "Failed to Update Elastic Search index %s", indexMapping.getIndexName(clusterAlias)));
+    }
+  }
+
+  @Override
+  public void deleteIndex(IndexMapping indexMapping) {
+    try {
+      DeleteIndexRequest request =
+          DeleteIndexRequest.of(d -> d.index(indexMapping.getIndexName(clusterAlias)));
+      DeleteIndexResponse deleteIndexResponse = client.indices().delete(request);
+      LOG.debug(
+          "{} Deleted {}",
+          indexMapping.getIndexName(clusterAlias),
+          deleteIndexResponse.acknowledged());
+    } catch (Exception e) {
+      LOG.error("Failed to delete Elastic Search indexes due to", e);
+    }
+  }
+}
Index: openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/TestCaseIndex.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/TestCaseIndex.java b/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/TestCaseIndex.java
--- a/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/TestCaseIndex.java	(revision d10bcccecad7a11724e8df23cf8c879f9f0673da)
+++ b/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/TestCaseIndex.java	(date 1744005110101)
@@ -1,6 +1,8 @@
 package org.openmetadata.service.search.indexes;
 
+import co.elastic.clients.elasticsearch.core.SearchRequest;
 import java.util.ArrayList;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
@@ -16,6 +18,22 @@
 import org.openmetadata.service.search.models.SearchSuggest;
 
 public record TestCaseIndex(TestCase testCase) implements SearchIndex {
+  public static final Set<String> FIELDS_WITH_WEIGHT = new HashSet<>();
+  public static final Set<String> HIGHLIGHT_FIELDS = new HashSet<>();
+
+  static {
+    Set<String> fields = SearchIndex.getDefaultFields();
+    fields.add("testCase.fullyQualifiedName^10");
+    fields.add("testCase.name^10");
+    fields.add("testCase.description^1");
+    fields.add("entityLink^3");
+    fields.add("entityFQN^10");
+
+    FIELDS_WITH_WEIGHT.addAll(fields);
+
+    HIGHLIGHT_FIELDS.addAll(List.of("testSuite.name", "testSuite.description"));
+  }
+
   private static final Set<String> excludeFields = Set.of("changeDescription", "failedRowsSample");
 
   @Override
@@ -71,13 +89,26 @@
     }
   }
 
-  public static Map<String, Float> getFields() {
-    Map<String, Float> fields = SearchIndex.getDefaultFields();
-    fields.put("testSuite.fullyQualifiedName", 10.0f);
-    fields.put("testSuite.name", 10.0f);
-    fields.put("testSuite.description", 1.0f);
-    fields.put("entityLink", 3.0f);
-    fields.put("entityFQN", 10.0f);
-    return fields;
+  public static Set<String> getHighLightFields() {
+    return HIGHLIGHT_FIELDS;
+  }
+
+  public static Set<String> getFieldsWithWeights() {
+    return FIELDS_WITH_WEIGHT;
+  }
+
+  public static SearchRequest.Builder addEsEntityAggregation(SearchRequest.Builder requestBuilder) {
+    // add Base Aggregations for ElasticSearch
+    SearchIndex.addBaseElasticSearchAggregation(requestBuilder);
+    return requestBuilder;
+  }
+
+  public static os.org.opensearch.client.opensearch.core.SearchRequest.Builder
+      addOsEntityAggregation(
+          os.org.opensearch.client.opensearch.core.SearchRequest.Builder requestBuilder) {
+
+    // add Base Aggregations for OpenSearch
+    SearchIndex.addBaseOpenSearchAggregation(requestBuilder);
+    return requestBuilder;
   }
 }
Index: openmetadata-service/src/main/java/org/openmetadata/service/search/highlight/ElasticSearchHighlightBuilder.java
===================================================================
diff --git a/openmetadata-service/src/main/java/org/openmetadata/service/search/highlight/ElasticSearchHighlightBuilder.java b/openmetadata-service/src/main/java/org/openmetadata/service/search/highlight/ElasticSearchHighlightBuilder.java
new file mode 100644
--- /dev/null	(date 1744005110163)
+++ b/openmetadata-service/src/main/java/org/openmetadata/service/search/highlight/ElasticSearchHighlightBuilder.java	(date 1744005110163)
@@ -0,0 +1,34 @@
+package org.openmetadata.service.search.highlight;
+
+import static org.openmetadata.service.search.EntityBuilderConstant.MAX_ANALYZED_OFFSET;
+import static org.openmetadata.service.search.EntityBuilderConstant.POST_TAG;
+import static org.openmetadata.service.search.EntityBuilderConstant.PRE_TAG;
+
+import es.co.elastic.clients.elasticsearch.core.search.Highlight;
+import es.co.elastic.clients.elasticsearch.core.search.HighlightField;
+import java.util.List;
+import java.util.Map;
+import java.util.stream.Collectors;
+import lombok.Getter;
+
+@Getter
+public class ElasticSearchHighlightBuilder implements OMHighlight {
+  private Highlight highlight;
+
+  public OMHighlight buildHighlights(List<String> fields) {
+    Highlight.Builder hb = new Highlight.Builder();
+    hb.preTags(PRE_TAG);
+    hb.postTags(POST_TAG);
+    hb.maxAnalyzedOffset(MAX_ANALYZED_OFFSET);
+    hb.requireFieldMatch(false);
+    Map<String, HighlightField> highlightFields =
+        fields.stream()
+            .collect(
+                Collectors.toMap(
+                    field -> field, field -> HighlightField.of(hf -> hf.type("unified"))));
+    hb.fields(highlightFields);
+
+    this.highlight = hb.build();
+    return this;
+  }
+}
Index: openmetadata-service/src/main/java/org/openmetadata/service/search/aggregation/OMAggregation.java
===================================================================
diff --git a/openmetadata-service/src/main/java/org/openmetadata/service/search/aggregation/OMAggregation.java b/openmetadata-service/src/main/java/org/openmetadata/service/search/aggregation/OMAggregation.java
new file mode 100644
--- /dev/null	(date 1744005110173)
+++ b/openmetadata-service/src/main/java/org/openmetadata/service/search/aggregation/OMAggregation.java	(date 1744005110173)
@@ -0,0 +1,13 @@
+package org.openmetadata.service.search.aggregation;
+
+public interface OMAggregation {
+  OMAggregation addAggregation(String name, AggregationContainer aggregation);
+
+  OMAggregation getAggregation(String name);
+
+  boolean hasAggregations();
+
+  int size();
+
+  void clear();
+}
Index: openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/TableIndex.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/TableIndex.java b/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/TableIndex.java
--- a/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/TableIndex.java	(revision d10bcccecad7a11724e8df23cf8c879f9f0673da)
+++ b/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/TableIndex.java	(date 1744005110107)
@@ -1,5 +1,10 @@
 package org.openmetadata.service.search.indexes;
 
+import static org.openmetadata.service.search.EntityBuilderConstant.COLUMNS_NAME_KEYWORD;
+import static org.openmetadata.service.search.EntityBuilderConstant.FIELD_COLUMN_NAMES;
+
+import co.elastic.clients.elasticsearch._types.aggregations.Aggregation;
+import co.elastic.clients.elasticsearch.core.SearchRequest;
 import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.List;
@@ -17,6 +22,22 @@
 import org.openmetadata.service.search.models.SearchSuggest;
 
 public record TableIndex(Table table) implements ColumnIndex {
+  public static final Set<String> FIELDS_WITH_WEIGHT = new HashSet<>();
+  public static final Set<String> HIGHLIGHT_FIELDS = new HashSet<>();
+
+  static {
+    Set<String> fields = SearchIndex.getDefaultFields();
+    fields.add(String.format("%s^5", COLUMNS_NAME_KEYWORD));
+    fields.add("columns.name^5");
+    fields.add("columns.displayName^5");
+    fields.add("columns.description^2");
+    fields.add("columns.children.name^5");
+    FIELDS_WITH_WEIGHT.addAll(fields);
+
+    HIGHLIGHT_FIELDS.addAll(
+        List.of("columns.name", "columns.description", "columns.children.name"));
+  }
+
   private static final Set<String> excludeFields =
       Set.of(
           "sampleData",
@@ -117,12 +138,76 @@
     return doc;
   }
 
-  public static Map<String, Float> getFields() {
-    Map<String, Float> fields = SearchIndex.getDefaultFields();
-    fields.put("columns.name", 5.0f);
-    fields.put("columns.displayName", 5.0f);
-    fields.put("columns.description", 2.0f);
-    fields.put("columns.children.name", 3.0f);
-    return fields;
+  public static Set<String> getHighLightFields() {
+    return HIGHLIGHT_FIELDS;
+  }
+
+  public static Set<String> getFieldsWithWeights() {
+    return FIELDS_WITH_WEIGHT;
+  }
+
+  public static SearchRequest.Builder addEsEntityAggregation(SearchRequest.Builder requestBuilder) {
+    // add Base Aggregations for ElasticSearch
+    SearchIndex.addBaseElasticSearchAggregation(requestBuilder);
+
+    // Add Aggregations for Table Index
+    requestBuilder
+        .aggregations(
+            "database.displayName.keyword",
+            new Aggregation.Builder()
+                .terms(termAgg -> termAgg.field("database.displayName.keyword"))
+                .build())
+        .aggregations(
+            "databaseSchema.displayName.keyword",
+            new Aggregation.Builder()
+                .terms(termAgg -> termAgg.field("databaseSchema.displayName.keyword"))
+                .build())
+        .aggregations(
+            COLUMNS_NAME_KEYWORD,
+            new Aggregation.Builder().terms(termAgg -> termAgg.field(COLUMNS_NAME_KEYWORD)).build())
+        .aggregations(
+            FIELD_COLUMN_NAMES,
+            new Aggregation.Builder().terms(termAgg -> termAgg.field(FIELD_COLUMN_NAMES)).build())
+        .aggregations(
+            "tableType",
+            new Aggregation.Builder().terms(termAgg -> termAgg.field("tableType")).build());
+    return requestBuilder;
+  }
+
+  public static os.org.opensearch.client.opensearch.core.SearchRequest.Builder
+      addOsEntityAggregation(
+          os.org.opensearch.client.opensearch.core.SearchRequest.Builder requestBuilder) {
+
+    // add Base Aggregations for OpenSearch
+    SearchIndex.addBaseOpenSearchAggregation(requestBuilder);
+
+    // Add Aggregations for Table Index
+    requestBuilder
+        .aggregations(
+            "database.displayName.keyword",
+            new os.org.opensearch.client.opensearch._types.aggregations.Aggregation.Builder()
+                .terms(termAgg -> termAgg.field("database.displayName.keyword"))
+                .build())
+        .aggregations(
+            "databaseSchema.displayName.keyword",
+            new os.org.opensearch.client.opensearch._types.aggregations.Aggregation.Builder()
+                .terms(termAgg -> termAgg.field("databaseSchema.displayName.keyword"))
+                .build())
+        .aggregations(
+            COLUMNS_NAME_KEYWORD,
+            new os.org.opensearch.client.opensearch._types.aggregations.Aggregation.Builder()
+                .terms(termAgg -> termAgg.field(COLUMNS_NAME_KEYWORD))
+                .build())
+        .aggregations(
+            FIELD_COLUMN_NAMES,
+            new os.org.opensearch.client.opensearch._types.aggregations.Aggregation.Builder()
+                .terms(termAgg -> termAgg.field(FIELD_COLUMN_NAMES))
+                .build())
+        .aggregations(
+            "tableType",
+            new os.org.opensearch.client.opensearch._types.aggregations.Aggregation.Builder()
+                .terms(termAgg -> termAgg.field("tableType"))
+                .build());
+    return requestBuilder;
   }
 }
Index: openmetadata-service/src/main/java/org/openmetadata/service/search/nlq/NoOpNLQService.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openmetadata-service/src/main/java/org/openmetadata/service/search/nlq/NoOpNLQService.java b/openmetadata-service/src/main/java/org/openmetadata/service/search/nlq/NoOpNLQService.java
--- a/openmetadata-service/src/main/java/org/openmetadata/service/search/nlq/NoOpNLQService.java	(revision d10bcccecad7a11724e8df23cf8c879f9f0673da)
+++ b/openmetadata-service/src/main/java/org/openmetadata/service/search/nlq/NoOpNLQService.java	(date 1744005110104)
@@ -3,7 +3,7 @@
 import java.io.IOException;
 import lombok.extern.slf4j.Slf4j;
 import org.openmetadata.schema.api.search.NLQConfiguration;
-import org.openmetadata.schema.search.SearchRequest;
+import org.openmetadata.schema.search.SearchRequestInternal;
 
 /**
  * A no-operation implementation of NLQService that returns null/empty responses.
@@ -21,8 +21,8 @@
   }
 
   @Override
-  public String transformNaturalLanguageQuery(SearchRequest request, String additionalContext)
-      throws IOException {
+  public String transformNaturalLanguageQuery(
+      SearchRequestInternal request, String additionalContext) throws IOException {
     return null;
   }
 
Index: openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/PipelineIndex.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/PipelineIndex.java b/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/PipelineIndex.java
--- a/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/PipelineIndex.java	(revision d10bcccecad7a11724e8df23cf8c879f9f0673da)
+++ b/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/PipelineIndex.java	(date 1744005110112)
@@ -1,8 +1,12 @@
 package org.openmetadata.service.search.indexes;
 
+import co.elastic.clients.elasticsearch._types.aggregations.Aggregation;
+import co.elastic.clients.elasticsearch.core.SearchRequest;
 import java.util.ArrayList;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 import org.openmetadata.schema.entity.data.Pipeline;
 import org.openmetadata.schema.type.Task;
 import org.openmetadata.service.Entity;
@@ -10,6 +14,18 @@
 import org.openmetadata.service.search.models.SearchSuggest;
 
 public class PipelineIndex implements SearchIndex {
+  public static final Set<String> FIELDS_WITH_WEIGHT = new HashSet<>();
+  public static final Set<String> HIGHLIGHT_FIELDS = new HashSet<>();
+
+  static {
+    Set<String> fields = SearchIndex.getDefaultFields();
+    fields.add("tasks.name^8");
+    fields.add("tasks.description^1");
+    FIELDS_WITH_WEIGHT.addAll(fields);
+
+    HIGHLIGHT_FIELDS.addAll(List.of("tasks.name", "tasks.description"));
+  }
+
   final Pipeline pipeline;
 
   public PipelineIndex(Pipeline pipeline) {
@@ -56,10 +72,38 @@
     return doc;
   }
 
-  public static Map<String, Float> getFields() {
-    Map<String, Float> fields = SearchIndex.getDefaultFields();
-    fields.put("tasks.name", 8.0f);
-    fields.put("tasks.description", 1.0f);
-    return fields;
+  public static Set<String> getHighLightFields() {
+    return HIGHLIGHT_FIELDS;
+  }
+
+  public static Set<String> getFieldsWithWeights() {
+    return FIELDS_WITH_WEIGHT;
+  }
+
+  public static SearchRequest.Builder addEsEntityAggregation(SearchRequest.Builder requestBuilder) {
+    // add Base Aggregations for ElasticSearch
+    SearchIndex.addBaseElasticSearchAggregation(requestBuilder);
+
+    requestBuilder.aggregations(
+        "tasks.displayName.keyword",
+        new Aggregation.Builder()
+            .terms(termAgg -> termAgg.field("tasks.displayName.keyword"))
+            .build());
+    return requestBuilder;
+  }
+
+  public static os.org.opensearch.client.opensearch.core.SearchRequest.Builder
+      addOsEntityAggregation(
+          os.org.opensearch.client.opensearch.core.SearchRequest.Builder requestBuilder) {
+
+    // add Base Aggregations for OpenSearch
+    SearchIndex.addBaseOpenSearchAggregation(requestBuilder);
+
+    requestBuilder.aggregations(
+        "tasks.displayName.keyword",
+        new os.org.opensearch.client.opensearch._types.aggregations.Aggregation.Builder()
+            .terms(termAgg -> termAgg.field("tasks.displayName.keyword"))
+            .build());
+    return requestBuilder;
   }
 }
Index: openmetadata-service/src/main/java/org/openmetadata/service/search/nlq/NLQService.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openmetadata-service/src/main/java/org/openmetadata/service/search/nlq/NLQService.java b/openmetadata-service/src/main/java/org/openmetadata/service/search/nlq/NLQService.java
--- a/openmetadata-service/src/main/java/org/openmetadata/service/search/nlq/NLQService.java	(revision d10bcccecad7a11724e8df23cf8c879f9f0673da)
+++ b/openmetadata-service/src/main/java/org/openmetadata/service/search/nlq/NLQService.java	(date 1744005110114)
@@ -1,7 +1,7 @@
 package org.openmetadata.service.search.nlq;
 
 import java.io.IOException;
-import org.openmetadata.schema.search.SearchRequest;
+import org.openmetadata.schema.search.SearchRequestInternal;
 
 /**
  * Interface for Natural Language Query (NLQ) processing services.
@@ -20,7 +20,7 @@
    * @return A JSON string representing a valid Elasticsearch/OpenSearch query
    * @throws IOException If the transformation process fails
    */
-  String transformNaturalLanguageQuery(SearchRequest request, String additionalContext)
+  String transformNaturalLanguageQuery(SearchRequestInternal request, String additionalContext)
       throws IOException;
 
   void cacheQuery(String query, String transformedQuery);
Index: conf/openmetadata.yaml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/conf/openmetadata.yaml b/conf/openmetadata.yaml
--- a/conf/openmetadata.yaml	(revision d10bcccecad7a11724e8df23cf8c879f9f0673da)
+++ b/conf/openmetadata.yaml	(date 1744005110127)
@@ -146,12 +146,12 @@
 
 database:
   # the name of the JDBC driver, mysql in our case
-  driverClass: ${DB_DRIVER_CLASS:-com.mysql.cj.jdbc.Driver}
+  driverClass: ${DB_DRIVER_CLASS:-org.postgresql.Driver}
   # the username and password
   user: ${DB_USER:-openmetadata_user}
   password: ${DB_USER_PASSWORD:-openmetadata_password}
   # the JDBC URL; the database is called openmetadata_db
-  url: jdbc:${DB_SCHEME:-mysql}://${DB_HOST:-localhost}:${DB_PORT:-3306}/${OM_DATABASE:-openmetadata_db}?${DB_PARAMS:-allowPublicKeyRetrieval=true&useSSL=false&serverTimezone=UTC}
+  url: jdbc:${DB_SCHEME:-postgresql}://${DB_HOST:-localhost}:${DB_PORT:-5432}/${OM_DATABASE:-openmetadata_db}?${DB_PARAMS:-allowPublicKeyRetrieval=true&useSSL=false&serverTimezone=UTC}
   maxSize: ${DB_CONNECTION_POOL_MAX_SIZE:-50}
   minSize: ${DB_CONNECTION_POOL_MIN_SIZE:-10}
   initialSize: ${DB_CONNECTION_POOL_INITIAL_SIZE:-10}
Index: openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/MlModelIndex.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/MlModelIndex.java b/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/MlModelIndex.java
--- a/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/MlModelIndex.java	(revision d10bcccecad7a11724e8df23cf8c879f9f0673da)
+++ b/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/MlModelIndex.java	(date 1744005110119)
@@ -1,14 +1,29 @@
 package org.openmetadata.service.search.indexes;
 
+import co.elastic.clients.elasticsearch.core.SearchRequest;
 import java.util.ArrayList;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 import org.openmetadata.schema.entity.data.MlModel;
 import org.openmetadata.service.Entity;
 import org.openmetadata.service.search.ParseTags;
 import org.openmetadata.service.search.models.SearchSuggest;
 
 public class MlModelIndex implements SearchIndex {
+  public static final Set<String> FIELDS_WITH_WEIGHT = new HashSet<>();
+  public static final Set<String> HIGHLIGHT_FIELDS = new HashSet<>();
+
+  static {
+    Set<String> fields = SearchIndex.getDefaultFields();
+    fields.add("mlFeatures.name^8");
+    fields.add("mlFeatures.description^1");
+    FIELDS_WITH_WEIGHT.addAll(fields);
+
+    HIGHLIGHT_FIELDS.addAll(List.of("mlFeatures.name", "mlFeatures.description"));
+  }
+
   final MlModel mlModel;
 
   public MlModelIndex(MlModel mlModel) {
@@ -40,10 +55,25 @@
     return doc;
   }
 
-  public static Map<String, Float> getFields() {
-    Map<String, Float> fields = SearchIndex.getDefaultFields();
-    fields.put("mlFeatures.name", 8.0f);
-    fields.put("mlFeatures.description", 1.0f);
-    return fields;
+  public static Set<String> getHighLightFields() {
+    return HIGHLIGHT_FIELDS;
+  }
+
+  public static Set<String> getFieldsWithWeights() {
+    return FIELDS_WITH_WEIGHT;
+  }
+
+  public static SearchRequest.Builder addEsEntityAggregation(SearchRequest.Builder requestBuilder) {
+    // add Base Aggregations for ElasticSearch
+    SearchIndex.addBaseElasticSearchAggregation(requestBuilder);
+    return requestBuilder;
+  }
+
+  public static os.org.opensearch.client.opensearch.core.SearchRequest.Builder
+      addOsEntityAggregation(
+          os.org.opensearch.client.opensearch.core.SearchRequest.Builder requestBuilder) {
+    // add Base Aggregations for OpenSearch
+    SearchIndex.addBaseOpenSearchAggregation(requestBuilder);
+    return requestBuilder;
   }
 }
Index: openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/TopicIndex.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/TopicIndex.java b/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/TopicIndex.java
--- a/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/TopicIndex.java	(revision d10bcccecad7a11724e8df23cf8c879f9f0673da)
+++ b/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/TopicIndex.java	(date 1744005110136)
@@ -1,7 +1,11 @@
 package org.openmetadata.service.search.indexes;
 
 import static org.openmetadata.service.search.EntityBuilderConstant.ES_MESSAGE_SCHEMA_FIELD;
+import static org.openmetadata.service.search.EntityBuilderConstant.ES_MESSAGE_SCHEMA_FIELD_KEYWORD;
+import static org.openmetadata.service.search.EntityBuilderConstant.SCHEMA_FIELD_NAMES;
 
+import co.elastic.clients.elasticsearch._types.aggregations.Aggregation;
+import co.elastic.clients.elasticsearch.core.SearchRequest;
 import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.List;
@@ -19,6 +23,19 @@
 import org.openmetadata.service.util.FullyQualifiedName;
 
 public class TopicIndex implements SearchIndex {
+  public static final Set<String> FIELDS_WITH_WEIGHT = new HashSet<>();
+  public static final Set<String> HIGHLIGHT_FIELDS = new HashSet<>();
+
+  static {
+    Set<String> fields = SearchIndex.getDefaultFields();
+    fields.add(String.format("%s^5", ES_MESSAGE_SCHEMA_FIELD));
+    fields.add("messageSchema.schemaFields.name.keyword^5");
+    fields.add("messageSchema.schemaFields.description^2");
+    fields.add("messageSchema.schemaFields.children.name^5");
+    fields.add("messageSchema.schemaFields.children.keyword^5");
+    FIELDS_WITH_WEIGHT.addAll(fields);
+  }
+
   final Set<String> excludeTopicFields = Set.of("sampleData");
   final Topic topic;
 
@@ -114,13 +131,48 @@
     }
   }
 
-  public static Map<String, Float> getFields() {
-    Map<String, Float> fields = SearchIndex.getDefaultFields();
-    fields.put(ES_MESSAGE_SCHEMA_FIELD, 7.0f);
-    fields.put("messageSchema.schemaFields.name.keyword", 5.0f);
-    fields.put("messageSchema.schemaFields.description", 1.0f);
-    fields.put("messageSchema.schemaFields.children.name", 7.0f);
-    fields.put("messageSchema.schemaFields.children.keyword", 5.0f);
-    return fields;
+  public static Set<String> getHighLightFields() {
+    return HIGHLIGHT_FIELDS;
+  }
+
+  public static Set<String> getFieldsWithWeights() {
+    return FIELDS_WITH_WEIGHT;
+  }
+
+  public static SearchRequest.Builder addEsEntityAggregation(SearchRequest.Builder requestBuilder) {
+    // add Base Aggregations for ElasticSearch
+    SearchIndex.addBaseElasticSearchAggregation(requestBuilder);
+
+    requestBuilder
+        .aggregations(
+            ES_MESSAGE_SCHEMA_FIELD_KEYWORD,
+            new Aggregation.Builder()
+                .terms(termAgg -> termAgg.field(ES_MESSAGE_SCHEMA_FIELD_KEYWORD))
+                .build())
+        .aggregations(
+            SCHEMA_FIELD_NAMES,
+            new Aggregation.Builder().terms(termAgg -> termAgg.field(SCHEMA_FIELD_NAMES)).build());
+    return requestBuilder;
+  }
+
+  public static os.org.opensearch.client.opensearch.core.SearchRequest.Builder
+      addOsEntityAggregation(
+          os.org.opensearch.client.opensearch.core.SearchRequest.Builder requestBuilder) {
+
+    // add Base Aggregations for OpenSearch
+    SearchIndex.addBaseOpenSearchAggregation(requestBuilder);
+
+    requestBuilder
+        .aggregations(
+            ES_MESSAGE_SCHEMA_FIELD_KEYWORD,
+            new os.org.opensearch.client.opensearch._types.aggregations.Aggregation.Builder()
+                .terms(termAgg -> termAgg.field(ES_MESSAGE_SCHEMA_FIELD_KEYWORD))
+                .build())
+        .aggregations(
+            SCHEMA_FIELD_NAMES,
+            new os.org.opensearch.client.opensearch._types.aggregations.Aggregation.Builder()
+                .terms(termAgg -> termAgg.field(SCHEMA_FIELD_NAMES))
+                .build());
+    return requestBuilder;
   }
 }
Index: openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/TestCaseResolutionStatusIndex.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/TestCaseResolutionStatusIndex.java b/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/TestCaseResolutionStatusIndex.java
--- a/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/TestCaseResolutionStatusIndex.java	(revision d10bcccecad7a11724e8df23cf8c879f9f0673da)
+++ b/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/TestCaseResolutionStatusIndex.java	(date 1744005110140)
@@ -1,9 +1,11 @@
 package org.openmetadata.service.search.indexes;
 
+import co.elastic.clients.elasticsearch.core.SearchRequest;
 import java.util.ArrayList;
-import java.util.HashMap;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 import org.openmetadata.schema.tests.TestCase;
 import org.openmetadata.schema.tests.TestSuite;
 import org.openmetadata.schema.tests.type.TestCaseResolutionStatus;
@@ -14,6 +16,19 @@
 
 public record TestCaseResolutionStatusIndex(TestCaseResolutionStatus testCaseResolutionStatus)
     implements SearchIndex {
+  public static final Set<String> FIELDS_WITH_WEIGHT = new HashSet<>();
+  public static final Set<String> HIGHLIGHT_FIELDS = new HashSet<>();
+
+  static {
+    Set<String> fields = new HashSet<>();
+    fields.add("testCaseResolutionStatusType^1");
+    fields.add("testCaseReference.displayName^15");
+    fields.add("testCaseReference.name^10");
+    fields.add("testCaseReference.description^1");
+    fields.add("testCaseResolutionStatusDetails.resolved.testCaseFailureComment^10");
+    FIELDS_WITH_WEIGHT.addAll(fields);
+  }
+
   @Override
   public Map<String, Object> buildSearchIndexDocInternal(Map<String, Object> doc) {
     List<SearchSuggest> suggest = new ArrayList<>();
@@ -68,13 +83,26 @@
     }
   }
 
-  public static Map<String, Float> getFields() {
-    Map<String, Float> fields = new HashMap<>();
-    fields.put("testCaseResolutionStatusType", 1.0f);
-    fields.put("testCaseReference.displayName", 15.0f);
-    fields.put("testCaseReference.name", 10.0f);
-    fields.put("testCaseReference.description", 1.0f);
-    fields.put("testCaseResolutionStatusDetails.resolved.testCaseFailureComment", 10.0f);
-    return fields;
+  public static Set<String> getHighLightFields() {
+    return HIGHLIGHT_FIELDS;
+  }
+
+  public static Set<String> getFieldsWithWeights() {
+    return FIELDS_WITH_WEIGHT;
+  }
+
+  public static SearchRequest.Builder addEsEntityAggregation(SearchRequest.Builder requestBuilder) {
+    // add Base Aggregations for ElasticSearch
+    SearchIndex.addBaseElasticSearchAggregation(requestBuilder);
+    return requestBuilder;
+  }
+
+  public static os.org.opensearch.client.opensearch.core.SearchRequest.Builder
+      addOsEntityAggregation(
+          os.org.opensearch.client.opensearch.core.SearchRequest.Builder requestBuilder) {
+
+    // add Base Aggregations for OpenSearch
+    SearchIndex.addBaseOpenSearchAggregation(requestBuilder);
+    return requestBuilder;
   }
 }
Index: openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/DomainIndex.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/DomainIndex.java b/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/DomainIndex.java
--- a/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/DomainIndex.java	(revision d10bcccecad7a11724e8df23cf8c879f9f0673da)
+++ b/openmetadata-service/src/main/java/org/openmetadata/service/search/indexes/DomainIndex.java	(date 1744005110144)
@@ -1,16 +1,22 @@
 package org.openmetadata.service.search.indexes;
 
 import java.util.ArrayList;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
-import lombok.extern.slf4j.Slf4j;
+import java.util.Set;
 import org.openmetadata.schema.entity.domains.Domain;
 import org.openmetadata.service.Entity;
 import org.openmetadata.service.search.ParseTags;
 import org.openmetadata.service.search.models.SearchSuggest;
 
-@Slf4j
 public record DomainIndex(Domain domain) implements SearchIndex {
+  public static final Set<String> FIELDS_WITH_WEIGHT = new HashSet<>();
+  public static final Set<String> HIGHLIGHT_FIELDS = new HashSet<>();
+
+  static {
+    FIELDS_WITH_WEIGHT.addAll(SearchIndex.getDefaultFields());
+  }
 
   @Override
   public List<SearchSuggest> getSuggest() {
@@ -35,7 +41,26 @@
     return doc;
   }
 
-  public static Map<String, Float> getFields() {
-    return SearchIndex.getDefaultFields();
+  public static Set<String> getHighLightFields() {
+    return HIGHLIGHT_FIELDS;
+  }
+
+  public static Set<String> getFieldsWithWeights() {
+    return FIELDS_WITH_WEIGHT;
+  }
+
+  public static SearchRequest.Builder addEsEntityAggregation(SearchRequest.Builder requestBuilder) {
+    // add Base Aggregations for ElasticSearch
+    SearchIndex.addBaseElasticSearchAggregation(requestBuilder);
+    return requestBuilder;
+  }
+
+  public static os.org.opensearch.client.opensearch.core.SearchRequest.Builder
+      addOsEntityAggregation(
+          os.org.opensearch.client.opensearch.core.SearchRequest.Builder requestBuilder) {
+
+    // add Base Aggregations for OpenSearch
+    SearchIndex.addBaseOpenSearchAggregation(requestBuilder);
+    return requestBuilder;
   }
 }
Index: openmetadata-service/src/main/java/org/openmetadata/service/search/elasticsearch/queries/ElasticQueryBuilder.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openmetadata-service/src/main/java/org/openmetadata/service/search/elasticsearch/queries/ElasticQueryBuilder.java b/openmetadata-service/src/main/java/org/openmetadata/service/search/elasticsearch/queries/ElasticQueryBuilder.java
--- a/openmetadata-service/src/main/java/org/openmetadata/service/search/elasticsearch/queries/ElasticQueryBuilder.java	(revision d10bcccecad7a11724e8df23cf8c879f9f0673da)
+++ b/openmetadata-service/src/main/java/org/openmetadata/service/search/elasticsearch/queries/ElasticQueryBuilder.java	(date 1744005109942)
@@ -1,14 +1,19 @@
 package org.openmetadata.service.search.elasticsearch.queries;
 
-import es.org.elasticsearch.index.query.BoolQueryBuilder;
-import es.org.elasticsearch.index.query.MatchAllQueryBuilder;
-import es.org.elasticsearch.index.query.QueryBuilder;
-import es.org.elasticsearch.index.query.QueryBuilders;
+import es.co.elastic.clients.elasticsearch._types.FieldValue;
+import es.co.elastic.clients.elasticsearch._types.query_dsl.BoolQuery;
+import es.co.elastic.clients.elasticsearch._types.query_dsl.MultiMatchQuery;
+import es.co.elastic.clients.elasticsearch._types.query_dsl.Operator;
+import es.co.elastic.clients.elasticsearch._types.query_dsl.Query;
+import es.co.elastic.clients.elasticsearch._types.query_dsl.QueryBuilders;
+import es.co.elastic.clients.elasticsearch._types.query_dsl.QueryStringQuery;
+import es.co.elastic.clients.elasticsearch._types.query_dsl.TextQueryType;
 import java.util.List;
+import java.util.stream.Collectors;
 import org.openmetadata.service.search.queries.OMQueryBuilder;
 
 public class ElasticQueryBuilder implements OMQueryBuilder {
-  private QueryBuilder query;
+  private Query query;
 
   public ElasticQueryBuilder() {
     // Default constructor
@@ -21,51 +26,51 @@
 
   @Override
   public boolean isMatchNone() {
-    // Check if the query is a bool query with must_not match_all
-    if (query instanceof BoolQueryBuilder boolQuery) {
+    if (query != null && query.isBool()) {
+      BoolQuery boolQuery = query.bool();
       return boolQuery.must().isEmpty()
           && boolQuery.should().isEmpty()
           && boolQuery.mustNot().size() == 1
-          && boolQuery.mustNot().get(0) instanceof MatchAllQueryBuilder;
+          && boolQuery.mustNot().get(0).isMatchAll();
     }
     return false;
   }
 
   @Override
   public boolean isMatchAll() {
-    return query instanceof MatchAllQueryBuilder;
+    return query != null && query.isMatchAll();
   }
 
   @Override
   public OMQueryBuilder must(List<OMQueryBuilder> queries) {
-    BoolQueryBuilder boolQuery = getOrCreateBoolQuery();
-    for (OMQueryBuilder q : queries) {
-      ElasticQueryBuilder eqb = (ElasticQueryBuilder) q;
-      boolQuery.must(eqb.build());
-    }
-    this.query = boolQuery;
+    BoolQuery.Builder boolQuery = getOrCreateBoolQuery();
+    boolQuery.must(convertQueries(queries));
+    this.query = boolQuery.build()._toQuery();
+    return this;
+  }
+
+  @Override
+  public OMQueryBuilder must(List<OMQueryBuilder> queries, List<OMQueryBuilder> filters) {
+    BoolQuery.Builder boolQuery = getOrCreateBoolQuery();
+    boolQuery.must(convertQueries(queries));
+    boolQuery.filter(convertQueries(filters));
+    this.query = boolQuery.build()._toQuery();
     return this;
   }
 
   @Override
   public OMQueryBuilder should(List<OMQueryBuilder> queries) {
-    BoolQueryBuilder boolQuery = getOrCreateBoolQuery();
-    for (OMQueryBuilder q : queries) {
-      ElasticQueryBuilder eqb = (ElasticQueryBuilder) q;
-      boolQuery.should(eqb.build());
-    }
-    this.query = boolQuery;
+    BoolQuery.Builder boolQuery = getOrCreateBoolQuery();
+    boolQuery.should(convertQueries(queries));
+    this.query = boolQuery.build()._toQuery();
     return this;
   }
 
   @Override
   public OMQueryBuilder mustNot(List<OMQueryBuilder> queries) {
-    BoolQueryBuilder boolQuery = getOrCreateBoolQuery();
-    for (OMQueryBuilder q : queries) {
-      ElasticQueryBuilder eqb = (ElasticQueryBuilder) q;
-      boolQuery.mustNot(eqb.build());
-    }
-    this.query = boolQuery;
+    BoolQuery.Builder boolQuery = getOrCreateBoolQuery();
+    boolQuery.mustNot(convertQueries(queries));
+    this.query = boolQuery.build()._toQuery();
     return this;
   }
 
@@ -74,14 +79,29 @@
     return must(List.of(query));
   }
 
+  @Override
+  public OMQueryBuilder must(OMQueryBuilder query, OMQueryBuilder filter) {
+    return must(List.of(query), List.of(filter));
+  }
+
   @Override
   public OMQueryBuilder should(OMQueryBuilder query) {
     return should(List.of(query));
   }
 
+  @Override
+  public OMQueryBuilder filter(OMQueryBuilder filter) {
+    BoolQuery.Builder boolQuery = getOrCreateBoolQuery();
+    boolQuery.must(this.query);
+    boolQuery.filter(convertQueries(List.of(filter)));
+    this.query = boolQuery.build()._toQuery();
+    return this;
+  }
+
   @Override
   public boolean hasClauses() {
-    if (query instanceof BoolQueryBuilder boolQuery) {
+    if (query != null && query.isBool()) {
+      BoolQuery boolQuery = query.bool();
       return !boolQuery.must().isEmpty()
           || !boolQuery.should().isEmpty()
           || !boolQuery.mustNot().isEmpty();
@@ -89,56 +109,110 @@
     return query != null;
   }
 
-  public QueryBuilder build() {
+  public Query build() {
     return query;
   }
 
-  public ElasticQueryBuilder setQuery(QueryBuilder query) {
+  public ElasticQueryBuilder setQuery(Query query) {
     this.query = query;
     return this;
   }
 
-  // Helper methods
-
   public ElasticQueryBuilder matchNoneQuery() {
-    this.query = QueryBuilders.boolQuery().mustNot(QueryBuilders.matchAllQuery());
+    this.query = QueryBuilders.matchNone().build()._toQuery();
     return this;
   }
 
   public ElasticQueryBuilder matchAllQuery() {
-    this.query = QueryBuilders.matchAllQuery();
+    this.query = QueryBuilders.matchAll().build()._toQuery();
     return this;
   }
 
   public ElasticQueryBuilder boolQuery() {
-    this.query = QueryBuilders.boolQuery();
+    this.query = QueryBuilders.bool().build()._toQuery();
     return this;
   }
 
   public ElasticQueryBuilder termQuery(String field, String value) {
-    this.query = QueryBuilders.termQuery(field, value);
+    this.query = QueryBuilders.term(t -> t.field(field).value(value)).term()._toQuery();
     return this;
   }
 
   public ElasticQueryBuilder termsQuery(String field, List<String> values) {
-    this.query = QueryBuilders.termsQuery(field, values);
+    List<FieldValue> fieldValues = values.stream().map(FieldValue::of).toList();
+    this.query =
+        QueryBuilders.terms(t -> t.field(field).terms(terms -> terms.value(fieldValues)))
+            .terms()
+            ._toQuery();
     return this;
   }
 
   public ElasticQueryBuilder existsQuery(String field) {
-    this.query = QueryBuilders.existsQuery(field);
+    this.query = QueryBuilders.exists(e -> e.field(field)).exists()._toQuery();
     return this;
   }
 
-  private BoolQueryBuilder getOrCreateBoolQuery() {
-    if (query instanceof BoolQueryBuilder) {
-      return (BoolQueryBuilder) query;
+  private BoolQuery.Builder getOrCreateBoolQuery() {
+    if (query != null && query.isBool()) {
+      return new BoolQuery.Builder().must(query.bool()._toQuery());
     } else {
-      BoolQueryBuilder boolQuery = QueryBuilders.boolQuery();
+      BoolQuery.Builder boolQuery = QueryBuilders.bool();
       if (query != null) {
         boolQuery.must(query);
       }
       return boolQuery;
     }
   }
+
+  @Override
+  public ElasticQueryBuilder queryStringQuery(
+      String query,
+      List<String> fields,
+      String textQueryType,
+      String operator,
+      String fuzziness,
+      int fuzzyPrefixLength,
+      double tieBreaker) {
+    this.query =
+        new QueryStringQuery.Builder()
+            .query(query)
+            .fields(fields)
+            .type(TextQueryType.valueOf(textQueryType))
+            .defaultOperator(Operator.valueOf(operator))
+            .fuzziness(fuzziness)
+            .fuzzyPrefixLength(fuzzyPrefixLength)
+            .tieBreaker(tieBreaker)
+            .build()
+            ._toQuery();
+    return this;
+  }
+
+  @Override
+  public OMQueryBuilder multiMatchQuery(
+      String query,
+      List<String> fields,
+      String queryType,
+      String operator,
+      String fuzziness,
+      int prefixLength,
+      double tieBreaker) {
+    this.query =
+        new MultiMatchQuery.Builder()
+            .query(query)
+            .fields(fields)
+            .type(TextQueryType.valueOf(queryType))
+            .fuzziness(fuzziness)
+            .prefixLength(prefixLength)
+            .operator(Operator.valueOf(operator))
+            .tieBreaker(tieBreaker)
+            .build()
+            ._toQuery();
+    return this;
+  }
+
+  private List<Query> convertQueries(List<OMQueryBuilder> queries) {
+    return queries.stream()
+        .map(q -> ((ElasticQueryBuilder) q).build())
+        .collect(Collectors.toList());
+  }
 }
Index: openmetadata-service/src/main/java/org/openmetadata/service/search/queries/OMQueryBuilder.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openmetadata-service/src/main/java/org/openmetadata/service/search/queries/OMQueryBuilder.java b/openmetadata-service/src/main/java/org/openmetadata/service/search/queries/OMQueryBuilder.java
--- a/openmetadata-service/src/main/java/org/openmetadata/service/search/queries/OMQueryBuilder.java	(revision d10bcccecad7a11724e8df23cf8c879f9f0673da)
+++ b/openmetadata-service/src/main/java/org/openmetadata/service/search/queries/OMQueryBuilder.java	(date 1744005110147)
@@ -12,13 +12,37 @@
 
   OMQueryBuilder must(List<OMQueryBuilder> queries);
 
+  OMQueryBuilder must(List<OMQueryBuilder> queries, List<OMQueryBuilder> filters);
+
   OMQueryBuilder should(List<OMQueryBuilder> queries);
 
   OMQueryBuilder mustNot(List<OMQueryBuilder> queries);
 
   OMQueryBuilder must(OMQueryBuilder query);
 
+  OMQueryBuilder must(OMQueryBuilder query, OMQueryBuilder filter);
+
   OMQueryBuilder should(OMQueryBuilder query);
 
+  OMQueryBuilder filter(OMQueryBuilder query);
+
+  OMQueryBuilder queryStringQuery(
+      String query,
+      List<String> fields,
+      String textQueryType,
+      String operator,
+      String fuzziness,
+      int fuzzinessPrefixLength,
+      double tieBreaker);
+
+  OMQueryBuilder multiMatchQuery(
+      String query,
+      List<String> fields,
+      String queryType,
+      String operator,
+      String fuzziness,
+      int prefixLength,
+      double tieBreaker);
+
   boolean hasClauses();
 }
Index: openmetadata-service/src/main/java/org/openmetadata/service/search/queries/QueryBuilderFactory.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openmetadata-service/src/main/java/org/openmetadata/service/search/queries/QueryBuilderFactory.java b/openmetadata-service/src/main/java/org/openmetadata/service/search/queries/QueryBuilderFactory.java
--- a/openmetadata-service/src/main/java/org/openmetadata/service/search/queries/QueryBuilderFactory.java	(revision d10bcccecad7a11724e8df23cf8c879f9f0673da)
+++ b/openmetadata-service/src/main/java/org/openmetadata/service/search/queries/QueryBuilderFactory.java	(date 1744005109949)
@@ -15,4 +15,22 @@
   OMQueryBuilder termsQuery(String field, List<String> values);
 
   OMQueryBuilder existsQuery(String field);
+
+  OMQueryBuilder queryStringQuery(
+      String query,
+      List<String> fields,
+      String textQueryType,
+      String operator,
+      String fuzziness,
+      int fuzzinessPrefixLength,
+      double tieBreaker);
+
+  OMQueryBuilder multiMatchQuery(
+      String query,
+      List<String> fields,
+      String operator,
+      String queryType,
+      String fuzziness,
+      int prefixLength,
+      double tieBreaker);
 }
Index: openmetadata-service/src/main/java/org/openmetadata/service/jdbi3/SystemRepository.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openmetadata-service/src/main/java/org/openmetadata/service/jdbi3/SystemRepository.java b/openmetadata-service/src/main/java/org/openmetadata/service/jdbi3/SystemRepository.java
--- a/openmetadata-service/src/main/java/org/openmetadata/service/jdbi3/SystemRepository.java	(revision d10bcccecad7a11724e8df23cf8c879f9f0673da)
+++ b/openmetadata-service/src/main/java/org/openmetadata/service/jdbi3/SystemRepository.java	(date 1744005110151)
@@ -484,7 +484,7 @@
     if (Boolean.TRUE.equals(searchRepository.getSearchClient().isClientAvailable())
         && searchRepository
             .getSearchClient()
-            .indexExists(Entity.getSearchRepository().getIndexOrAliasName(INDEX_NAME))) {
+            .indexExists(Entity.getSearchRepository().getIndexMapping(INDEX_NAME))) {
       return new StepValidation()
           .withDescription(ValidationStepDescription.SEARCH.key)
           .withPassed(Boolean.TRUE)
Index: openmetadata-spec/src/main/resources/json/schema/search/searchRequest.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openmetadata-spec/src/main/resources/json/schema/search/searchRequest.json b/openmetadata-spec/src/main/resources/json/schema/search/searchRequest.json
--- a/openmetadata-spec/src/main/resources/json/schema/search/searchRequest.json	(revision d10bcccecad7a11724e8df23cf8c879f9f0673da)
+++ b/openmetadata-spec/src/main/resources/json/schema/search/searchRequest.json	(date 1744005110168)
@@ -3,7 +3,7 @@
   "$schema": "http://json-schema.org/draft-07/schema#",
   "title": "SearchRequest",
   "description": "Search Request to find entities from Elastic Search based on different parameters.",
-  "javaType": "org.openmetadata.schema.search.SearchRequest",
+  "javaType": "org.openmetadata.schema.search.SearchRequestInternal",
   "type": "object",
   "properties": {
     "query": {
Index: openmetadata-service/src/main/java/org/openmetadata/service/workflows/searchIndex/ReindexingUtil.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openmetadata-service/src/main/java/org/openmetadata/service/workflows/searchIndex/ReindexingUtil.java b/openmetadata-service/src/main/java/org/openmetadata/service/workflows/searchIndex/ReindexingUtil.java
--- a/openmetadata-service/src/main/java/org/openmetadata/service/workflows/searchIndex/ReindexingUtil.java	(revision d10bcccecad7a11724e8df23cf8c879f9f0673da)
+++ b/openmetadata-service/src/main/java/org/openmetadata/service/workflows/searchIndex/ReindexingUtil.java	(date 1744005110171)
@@ -27,7 +27,7 @@
 import lombok.SneakyThrows;
 import lombok.extern.slf4j.Slf4j;
 import org.openmetadata.common.utils.CommonUtil;
-import org.openmetadata.schema.search.SearchRequest;
+import org.openmetadata.schema.search.SearchRequestInternal;
 import org.openmetadata.schema.system.EntityError;
 import org.openmetadata.schema.system.Stats;
 import org.openmetadata.schema.system.StepStats;
@@ -147,8 +147,8 @@
   public static List<EntityReference> findReferenceInElasticSearchAcrossAllIndexes(
       String matchingKey, String sourceFqn, int from) {
     String key = "_source";
-    SearchRequest searchRequest =
-        new SearchRequest()
+    SearchRequestInternal searchRequest =
+        new SearchRequestInternal()
             .withQuery(String.format("(%s:\"%s\")", matchingKey, sourceFqn))
             .withSize(100)
             .withIndex(Entity.getSearchRepository().getIndexOrAliasName(GLOBAL_SEARCH_ALIAS))
Index: openmetadata-service/src/main/java/org/openmetadata/service/jdbi3/GlossaryTermRepository.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openmetadata-service/src/main/java/org/openmetadata/service/jdbi3/GlossaryTermRepository.java b/openmetadata-service/src/main/java/org/openmetadata/service/jdbi3/GlossaryTermRepository.java
--- a/openmetadata-service/src/main/java/org/openmetadata/service/jdbi3/GlossaryTermRepository.java	(revision d10bcccecad7a11724e8df23cf8c879f9f0673da)
+++ b/openmetadata-service/src/main/java/org/openmetadata/service/jdbi3/GlossaryTermRepository.java	(date 1744005110189)
@@ -72,7 +72,7 @@
 import org.openmetadata.schema.entity.data.GlossaryTerm.Status;
 import org.openmetadata.schema.entity.feed.Thread;
 import org.openmetadata.schema.entity.teams.Team;
-import org.openmetadata.schema.search.SearchRequest;
+import org.openmetadata.schema.search.SearchRequestInternal;
 import org.openmetadata.schema.type.ApiStatus;
 import org.openmetadata.schema.type.EntityReference;
 import org.openmetadata.schema.type.Include;
@@ -490,8 +490,8 @@
   protected Map<String, EntityReference> getGlossaryUsageFromES(String glossaryFqn, int size) {
     try {
       String key = "_source";
-      SearchRequest searchRequest =
-          new SearchRequest()
+      SearchRequestInternal searchRequest =
+          new SearchRequestInternal()
               .withQuery(
                   String.format(
                       "** AND (tags.tagFQN:\"%s\")",
