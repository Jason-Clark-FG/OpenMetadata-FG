package org.openmetadata.it.tests;

import static org.junit.jupiter.api.Assertions.*;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.UUID;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.parallel.Execution;
import org.junit.jupiter.api.parallel.ExecutionMode;
import org.openmetadata.it.factories.DatabaseSchemaTestFactory;
import org.openmetadata.it.factories.DatabaseServiceTestFactory;
import org.openmetadata.it.factories.UserTestFactory;
import org.openmetadata.it.util.SdkClients;
import org.openmetadata.it.util.TestNamespace;
import org.openmetadata.schema.api.classification.CreateClassification;
import org.openmetadata.schema.api.classification.CreateTag;
import org.openmetadata.schema.api.data.CreateTable;
import org.openmetadata.schema.api.lineage.AddLineage;
import org.openmetadata.schema.api.tests.CreateTestCase;
import org.openmetadata.schema.api.tests.CreateTestSuite;
import org.openmetadata.schema.entity.classification.Classification;
import org.openmetadata.schema.entity.classification.Tag;
import org.openmetadata.schema.entity.data.DatabaseSchema;
import org.openmetadata.schema.entity.data.Table;
import org.openmetadata.schema.entity.services.DatabaseService;
import org.openmetadata.schema.tests.TestCase;
import org.openmetadata.schema.tests.TestSuite;
import org.openmetadata.schema.type.Column;
import org.openmetadata.schema.type.ColumnConstraint;
import org.openmetadata.schema.type.ColumnDataType;
import org.openmetadata.schema.type.ColumnLineage;
import org.openmetadata.schema.type.EntitiesEdge;
import org.openmetadata.schema.type.EntityReference;
import org.openmetadata.schema.type.LineageDetails;
import org.openmetadata.schema.type.PartitionColumnDetails;
import org.openmetadata.schema.type.PartitionIntervalTypes;
import org.openmetadata.schema.type.TableConstraint;
import org.openmetadata.schema.type.TableData;
import org.openmetadata.schema.type.TablePartition;
import org.openmetadata.schema.type.TableType;
import org.openmetadata.schema.type.TagLabel;
import org.openmetadata.it.env.TestSuiteBootstrap;
import org.openmetadata.sdk.client.OpenMetadataClient;
import org.openmetadata.sdk.fluent.builders.ColumnBuilder;
import org.openmetadata.sdk.models.ListParams;
import org.openmetadata.sdk.models.ListResponse;
import org.openmetadata.sdk.models.TableColumnList;
import org.openmetadata.service.util.RdfTestUtils;
import org.openmetadata.schema.type.ColumnJoin;
import org.openmetadata.schema.type.JoinedWith;
import org.openmetadata.schema.type.DataModel;
import org.openmetadata.schema.type.ColumnProfilerConfig;
import org.openmetadata.schema.type.ProfileSampleType;
import org.openmetadata.schema.api.data.CreateDatabase;
import org.openmetadata.schema.api.data.CreateDatabaseSchema;
import org.openmetadata.schema.api.data.UpdateColumn;
import org.openmetadata.schema.api.domains.CreateDomain;
import org.openmetadata.schema.api.services.CreateDatabaseService;
import org.openmetadata.schema.entity.data.Database;
import org.openmetadata.schema.entity.domains.Domain;
import org.openmetadata.schema.entity.teams.User;
import es.org.elasticsearch.client.Request;
import es.org.elasticsearch.client.Response;
import es.org.elasticsearch.client.RestClient;

/**
 * Integration tests for Table entity operations.
 *
 * <p>Extends BaseEntityIT to inherit all 8 common entity tests. Adds table-specific tests for
 * columns, constraints, partitions, and complex column types.
 *
 * <p>Total coverage: 8 (common) + 81 (table-specific) = 89 tests
 *
 * <p>Migrated from: org.openmetadata.service.resources.databases.TableResourceTest Migration date:
 * 2025-10-11
 *
 * <p>Test isolation: Uses TestNamespace for unique entity names Parallelization: Safe for
 * concurrent execution via @Execution(ExecutionMode.CONCURRENT)
 */
@Execution(ExecutionMode.CONCURRENT)
public class TableResourceIT extends BaseEntityIT<Table, CreateTable> {

  // ===================================================================
  // OVERRIDE: Tables allow duplicates in different schemas
  // ===================================================================

  @Override
  @Test
  public void post_duplicateEntity_409(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    // Tables are scoped by schema, so duplicates only conflict within same schema
    DatabaseService service = DatabaseServiceTestFactory.createPostgres(client, ns);
    DatabaseSchema schema = DatabaseSchemaTestFactory.createSimple(client, ns, service);

    // Create first table
    CreateTable createRequest = new CreateTable();
    createRequest.setName(ns.prefix("table"));
    createRequest.setDatabaseSchema(schema.getFullyQualifiedName());
    createRequest.setColumns(
        List.of(ColumnBuilder.of("id", "BIGINT").primaryKey().notNull().build()));

    Table table = createEntity(createRequest, client);
    assertNotNull(table.getId());

    // Attempt to create duplicate table in SAME schema
    CreateTable duplicateRequest = new CreateTable();
    duplicateRequest.setName(table.getName()); // Same name
    duplicateRequest.setDatabaseSchema(schema.getFullyQualifiedName()); // Same schema
    duplicateRequest.setColumns(
        List.of(ColumnBuilder.of("id", "BIGINT").primaryKey().notNull().build()));

    assertThrows(
        Exception.class,
        () -> createEntity(duplicateRequest, client),
        "Creating duplicate table in same schema should fail");
  }

  // ===================================================================
  // ABSTRACT METHOD IMPLEMENTATIONS (Required by BaseEntityIT)
  // ===================================================================

  @Override
  protected CreateTable createMinimalRequest(TestNamespace ns, OpenMetadataClient client) {
    DatabaseService service = DatabaseServiceTestFactory.createPostgres(client, ns);
    DatabaseSchema schema = DatabaseSchemaTestFactory.createSimple(client, ns, service);

    CreateTable request = new CreateTable();
    request.setName(ns.prefix("table"));
    request.setDatabaseSchema(schema.getFullyQualifiedName());
    request.setDescription("Test table created by integration test");

    List<Column> columns =
        List.of(
            ColumnBuilder.of("id", "BIGINT").primaryKey().notNull().build(),
            ColumnBuilder.of("name", "VARCHAR").dataLength(255).build());
    request.setColumns(columns);

    return request;
  }

  @Override
  protected CreateTable createRequest(String name, TestNamespace ns, OpenMetadataClient client) {
    DatabaseService service = DatabaseServiceTestFactory.createPostgres(client, ns);
    DatabaseSchema schema = DatabaseSchemaTestFactory.createSimple(client, ns, service);

    CreateTable request = new CreateTable();
    request.setName(name);
    request.setDatabaseSchema(schema.getFullyQualifiedName());

    List<Column> columns =
        List.of(
            ColumnBuilder.of("id", "BIGINT").primaryKey().notNull().build(),
            ColumnBuilder.of("name", "VARCHAR").dataLength(255).build());
    request.setColumns(columns);

    return request;
  }

  @Override
  protected Table createEntity(CreateTable createRequest, OpenMetadataClient client) {
    return client.tables().create(createRequest);
  }

  @Override
  protected Table getEntity(String id, OpenMetadataClient client) {
    return client.tables().get(id);
  }

  @Override
  protected Table getEntityByName(String fqn, OpenMetadataClient client) {
    return client.tables().getByName(fqn);
  }

  @Override
  protected Table patchEntity(String id, Table entity, OpenMetadataClient client) {
    return client.tables().update(id, entity);
  }

  @Override
  protected void deleteEntity(String id, OpenMetadataClient client) {
    client.tables().delete(id);
  }

  @Override
  protected void restoreEntity(String id, OpenMetadataClient client) {
    client.tables().restore(id);
  }

  @Override
  protected void hardDeleteEntity(String id, OpenMetadataClient client) {
    java.util.Map<String, String> params = new java.util.HashMap<>();
    params.put("hardDelete", "true");
    client.tables().delete(id, params);
  }

  @Override
  protected String getEntityType() {
    return "table";
  }

  @Override
  protected void validateCreatedEntity(Table entity, CreateTable createRequest) {
    assertEquals(createRequest.getName(), entity.getName());
    assertNotNull(entity.getDatabaseSchema(), "Table must have a database schema");

    if (createRequest.getDescription() != null) {
      assertEquals(createRequest.getDescription(), entity.getDescription());
    }

    assertNotNull(entity.getColumns(), "Table must have columns");
    assertEquals(
        createRequest.getColumns().size(), entity.getColumns().size(), "Column count should match");

    assertTrue(
        entity.getFullyQualifiedName().contains(entity.getName()), "FQN should contain table name");
  }

  // ===================================================================
  // COLUMN VALIDATION TESTS
  // ===================================================================

  @Test
  void post_tableWithoutColumnDataLength_400(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();
    DatabaseService service = DatabaseServiceTestFactory.createPostgres(client, ns);
    DatabaseSchema schema = DatabaseSchemaTestFactory.createSimple(client, ns, service);

    String[] dataTypes = {"CHAR", "VARCHAR", "BINARY", "VARBINARY"};

    for (String dataType : dataTypes) {
      CreateTable createRequest = new CreateTable();
      createRequest.setName(ns.prefix("table_" + dataType.toLowerCase()));
      createRequest.setDatabaseSchema(schema.getFullyQualifiedName());

      Column column = new Column();
      column.setName("test_col");
      column.setDataType(ColumnDataType.fromValue(dataType));

      createRequest.setColumns(List.of(column));

      assertThrows(
          Exception.class,
          () -> createEntity(createRequest, client),
          "Creating " + dataType + " column without dataLength should fail");
    }
  }

  @Test
  void post_tableInvalidPrecisionScale_400(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();
    DatabaseService service = DatabaseServiceTestFactory.createPostgres(client, ns);
    DatabaseSchema schema = DatabaseSchemaTestFactory.createSimple(client, ns, service);

    // Test 1: Scale set without precision
    CreateTable createRequest1 = new CreateTable();
    createRequest1.setName(ns.prefix("table_scale_no_precision"));
    createRequest1.setDatabaseSchema(schema.getFullyQualifiedName());

    Column column1 = new Column();
    column1.setName("decimal_col");
    column1.setDataType(ColumnDataType.DECIMAL);
    column1.setScale(1);

    createRequest1.setColumns(List.of(column1));

    assertThrows(
        Exception.class,
        () -> createEntity(createRequest1, client),
        "Creating DECIMAL column with scale but no precision should fail");

    // Test 2: Scale greater than precision
    CreateTable createRequest2 = new CreateTable();
    createRequest2.setName(ns.prefix("table_scale_gt_precision"));
    createRequest2.setDatabaseSchema(schema.getFullyQualifiedName());

    Column column2 = new Column();
    column2.setName("decimal_col");
    column2.setDataType(ColumnDataType.DECIMAL);
    column2.setPrecision(1);
    column2.setScale(2);

    createRequest2.setColumns(List.of(column2));

    assertThrows(
        Exception.class,
        () -> createEntity(createRequest2, client),
        "Creating DECIMAL column with scale > precision should fail");
  }

  @Test
  void post_tableInvalidArrayColumn_400(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();
    DatabaseService service = DatabaseServiceTestFactory.createPostgres(client, ns);
    DatabaseSchema schema = DatabaseSchemaTestFactory.createSimple(client, ns, service);

    CreateTable createRequest = new CreateTable();
    createRequest.setName(ns.prefix("table_invalid_array"));
    createRequest.setDatabaseSchema(schema.getFullyQualifiedName());

    Column column = new Column();
    column.setName("array_col");
    column.setDataType(ColumnDataType.ARRAY);
    column.setDataTypeDisplay("array<int>");

    createRequest.setColumns(List.of(column));

    assertThrows(
        Exception.class,
        () -> createEntity(createRequest, client),
        "Creating ARRAY column without arrayDataType should fail");
  }

  @Test
  void post_duplicateColumnName_400(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();
    DatabaseService service = DatabaseServiceTestFactory.createPostgres(client, ns);
    DatabaseSchema schema = DatabaseSchemaTestFactory.createSimple(client, ns, service);

    CreateTable createRequest = new CreateTable();
    createRequest.setName(ns.prefix("table_duplicate_cols"));
    createRequest.setDatabaseSchema(schema.getFullyQualifiedName());

    Column column1 = new Column();
    column1.setName("duplicate_col");
    column1.setDataType(ColumnDataType.INT);

    Column column2 = new Column();
    column2.setName("duplicate_col");
    column2.setDataType(ColumnDataType.VARCHAR);
    column2.setDataLength(255);

    createRequest.setColumns(List.of(column1, column2));

    assertThrows(
        Exception.class,
        () -> createEntity(createRequest, client),
        "Creating table with duplicate column names should fail");
  }

  // ===================================================================
  // TABLE CREATION TESTS
  // ===================================================================

  @Test
  void post_validTables_200_OK(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    DatabaseService service = DatabaseServiceTestFactory.createPostgres(client, ns);
    DatabaseSchema schema = DatabaseSchemaTestFactory.createSimple(client, ns, service);

    CreateTable create = new CreateTable();
    create.setName(ns.prefix("table_with_desc"));
    create.setDatabaseSchema(schema.getFullyQualifiedName());
    create.setDescription("description");
    create.setColumns(
        List.of(
            ColumnBuilder.of("id", "BIGINT").primaryKey().notNull().build(),
            ColumnBuilder.of("name", "VARCHAR").dataLength(255).build()));

    Table createdTable = createEntity(create, client);
    assertNotNull(createdTable);
    assertEquals("description", createdTable.getDescription());

    CreateTable create2 = new CreateTable();
    create2.setName(ns.prefix("table_view"));
    create2.setDatabaseSchema(schema.getFullyQualifiedName());
    create2.setTableType(TableType.View);
    create2.setColumns(
        List.of(
            ColumnBuilder.of("id", "BIGINT").primaryKey().notNull().build(),
            ColumnBuilder.of("name", "VARCHAR").dataLength(255).build()));

    Table createdView = createEntity(create2, client);
    assertNotNull(createdView);
    assertEquals(TableType.View, createdView.getTableType());
  }

  @Test
  void post_tableWithColumnWithDots(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    DatabaseService service = DatabaseServiceTestFactory.createPostgres(client, ns);
    DatabaseSchema schema = DatabaseSchemaTestFactory.createSimple(client, ns, service);

    Column column = new Column();
    column.setName("col.umn");
    column.setDataType(ColumnDataType.INT);

    TableConstraint constraint = new TableConstraint();
    constraint.setConstraintType(TableConstraint.ConstraintType.UNIQUE);
    constraint.setColumns(List.of(column.getName()));

    CreateTable create = new CreateTable();
    create.setName(ns.prefix("table_dots"));
    create.setDatabaseSchema(schema.getFullyQualifiedName());
    create.setColumns(List.of(column));
    create.setTableConstraints(List.of(constraint));

    Table created = createEntity(create, client);
    Column resultColumn = created.getColumns().get(0);
    assertEquals("col.umn", resultColumn.getName());
    assertTrue(resultColumn.getFullyQualifiedName().contains("col.umn"));
    assertEquals("col.umn", created.getTableConstraints().get(0).getColumns().get(0));
  }

  @Test
  void post_tableWithPartition(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    DatabaseService service = DatabaseServiceTestFactory.createPostgres(client, ns);
    DatabaseSchema schema = DatabaseSchemaTestFactory.createSimple(client, ns, service);

    Column col1 = new Column();
    col1.setName("user_id");
    col1.setDataType(ColumnDataType.INT);

    Column col2 = new Column();
    col2.setName("date");
    col2.setDataType(ColumnDataType.DATE);

    PartitionColumnDetails partitionColumnDetails = new PartitionColumnDetails();
    partitionColumnDetails.setColumnName(col2.getName());
    partitionColumnDetails.setIntervalType(PartitionIntervalTypes.TIME_UNIT);
    partitionColumnDetails.setInterval("daily");

    TablePartition partition = new TablePartition();
    partition.setColumns(List.of(partitionColumnDetails));

    CreateTable create = new CreateTable();
    create.setName(ns.prefix("partitioned_table"));
    create.setDatabaseSchema(schema.getFullyQualifiedName());
    create.setColumns(List.of(col1, col2));
    create.setTablePartition(partition);

    Table created = createEntity(create, client);
    assertNotNull(created.getTablePartition());
    assertEquals(1, created.getTablePartition().getColumns().size());
    assertEquals("date", created.getTablePartition().getColumns().get(0).getColumnName());
  }

  @Test
  void post_tableWithInvalidDatabase_404(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    CreateTable create = new CreateTable();
    create.setName(ns.prefix("invalid_schema_table"));
    create.setDatabaseSchema("nonExistentSchema");
    create.setColumns(List.of(ColumnBuilder.of("id", "BIGINT").primaryKey().notNull().build()));

    assertThrows(
        Exception.class,
        () -> createEntity(create, client),
        "Creating table with non-existent schema should fail");
  }

  // ===================================================================
  // COMPLEX COLUMN TYPES TESTS
  // ===================================================================

  @Test
  void post_put_patch_complexColumnTypes(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();
    DatabaseService service = DatabaseServiceTestFactory.createPostgres(client, ns);
    DatabaseSchema schema = DatabaseSchemaTestFactory.createSimple(client, ns, service);

    // Create complex column: array<int>
    Column c1 = new Column();
    c1.setName("c1");
    c1.setDataType(ColumnDataType.ARRAY);
    c1.setDataTypeDisplay("array<int>");
    c1.setArrayDataType(ColumnDataType.INT);

    // Create complex column: struct<a: int, b:char, c: struct<d:int>>
    Column c2_a = new Column();
    c2_a.setName("a");
    c2_a.setDataType(ColumnDataType.INT);

    Column c2_b = new Column();
    c2_b.setName("b");
    c2_b.setDataType(ColumnDataType.CHAR);
    c2_b.setDataLength(10);

    Column c2_c_d = new Column();
    c2_c_d.setName("d");
    c2_c_d.setDataType(ColumnDataType.INT);

    Column c2_c = new Column();
    c2_c.setName("c");
    c2_c.setDataType(ColumnDataType.STRUCT);
    c2_c.setDataTypeDisplay("struct<d:int>");
    c2_c.setChildren(new ArrayList<>(List.of(c2_c_d)));

    Column c2 = new Column();
    c2.setName("c2");
    c2.setDataType(ColumnDataType.STRUCT);
    c2.setDataTypeDisplay("struct<a: int, b:char, c: struct<d:int>>");
    c2.setChildren(new ArrayList<>(Arrays.asList(c2_a, c2_b, c2_c)));

    CreateTable create = new CreateTable();
    create.setName(ns.prefix("complex_columns"));
    create.setDatabaseSchema(schema.getFullyQualifiedName());
    create.setColumns(Arrays.asList(c1, c2));

    Table table = createEntity(create, client);
    assertNotNull(table);
    assertEquals(2, table.getColumns().size());
    assertEquals(ColumnDataType.ARRAY, table.getColumns().get(0).getDataType());
    assertEquals(ColumnDataType.STRUCT, table.getColumns().get(1).getDataType());
    assertEquals(3, table.getColumns().get(1).getChildren().size());
  }

  // ===================================================================
  // TABLE CONSTRAINTS TESTS
  // ===================================================================

  @Test
  void put_tableTableConstraintUpdate_200(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    CreateTable request = createMinimalRequest(ns, client);
    request.setTableConstraints(null);

    Table table = createEntity(request, client);

    TableConstraint constraint = new TableConstraint();
    constraint.setConstraintType(TableConstraint.ConstraintType.UNIQUE);
    constraint.setColumns(List.of("id"));

    table.setTableConstraints(List.of(constraint));
    Table updated = patchEntity(table.getId().toString(), table, client);

    assertNotNull(updated.getTableConstraints());
    assertEquals(1, updated.getTableConstraints().size());
    assertEquals(
        TableConstraint.ConstraintType.UNIQUE,
        updated.getTableConstraints().get(0).getConstraintType());
  }

  @Test
  void put_columnConstraintUpdate_200(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    DatabaseService service = DatabaseServiceTestFactory.createPostgres(client, ns);
    DatabaseSchema schema = DatabaseSchemaTestFactory.createSimple(client, ns, service);

    Column col1 = new Column();
    col1.setName("c1");
    col1.setDataType(ColumnDataType.INT);
    col1.setConstraint(ColumnConstraint.NULL);

    Column col2 = new Column();
    col2.setName("c2");
    col2.setDataType(ColumnDataType.INT);
    col2.setConstraint(ColumnConstraint.UNIQUE);

    CreateTable request = new CreateTable();
    request.setName(ns.prefix("constraint_table"));
    request.setDatabaseSchema(schema.getFullyQualifiedName());
    request.setColumns(List.of(col1, col2));

    Table table = createEntity(request, client);

    table.getColumns().get(0).setConstraint(ColumnConstraint.NOT_NULL);
    table.getColumns().get(1).setConstraint(ColumnConstraint.PRIMARY_KEY);

    Table updated = patchEntity(table.getId().toString(), table, client);

    assertEquals(ColumnConstraint.NOT_NULL, updated.getColumns().get(0).getConstraint());
    assertEquals(ColumnConstraint.PRIMARY_KEY, updated.getColumns().get(1).getConstraint());
  }

  @Test
  void put_tableTableConstraintDuplicate_400(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    CreateTable request = createMinimalRequest(ns, client);
    request.setTableConstraints(null);

    Table table = createEntity(request, client);

    TableConstraint constraint = new TableConstraint();
    constraint.setConstraintType(TableConstraint.ConstraintType.UNIQUE);
    constraint.setColumns(List.of("id"));

    table.setTableConstraints(List.of(constraint, constraint));

    assertThrows(
        Exception.class,
        () -> patchEntity(table.getId().toString(), table, client),
        "Duplicate constraints should fail");
  }

  @Test
  void put_tableTableConstraintInvalidColumn_400(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    CreateTable request = createMinimalRequest(ns, client);
    request.setTableConstraints(null);

    Table table = createEntity(request, client);

    TableConstraint constraint = new TableConstraint();
    constraint.setConstraintType(TableConstraint.ConstraintType.UNIQUE);
    constraint.setColumns(List.of("invalid_column"));

    table.setTableConstraints(List.of(constraint));

    assertThrows(
        Exception.class,
        () -> patchEntity(table.getId().toString(), table, client),
        "Invalid column in constraint should fail");
  }

  // ===================================================================
  // COLUMN UPDATE TESTS
  // ===================================================================

  @Test
  void patch_tableAddColumn_200_OK(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    CreateTable createRequest = createMinimalRequest(ns, client);
    Table created = createEntity(createRequest, client);

    assertEquals(2, created.getColumns().size(), "Should have 2 initial columns");

    List<Column> updatedColumns =
        List.of(
            ColumnBuilder.of("id", "BIGINT").primaryKey().notNull().build(),
            ColumnBuilder.of("name", "VARCHAR").dataLength(255).build(),
            ColumnBuilder.of("email", "VARCHAR").dataLength(255).build());

    created.setColumns(updatedColumns);
    Table updated = patchEntity(created.getId().toString(), created, client);

    assertNotNull(updated.getColumns());
    assertEquals(3, updated.getColumns().size(), "Should have 3 columns after update");

    assertTrue(
        updated.getColumns().stream().anyMatch(col -> "email".equals(col.getName())),
        "Should have 'email' column");
  }

  @Test
  void put_updateColumns_200(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    DatabaseService service = DatabaseServiceTestFactory.createPostgres(client, ns);
    DatabaseSchema schema = DatabaseSchemaTestFactory.createSimple(client, ns, service);

    Column c1 = new Column();
    c1.setName("c1");
    c1.setDataType(ColumnDataType.BIGINT);

    CreateTable request = new CreateTable();
    request.setName(ns.prefix("update_cols"));
    request.setDatabaseSchema(schema.getFullyQualifiedName());
    request.setColumns(List.of(c1));

    Table table = createEntity(request, client);
    assertEquals(1, table.getColumns().size());

    Column c2 = new Column();
    c2.setName("c2");
    c2.setDataType(ColumnDataType.BINARY);
    c2.setDataLength(10);
    c2.setOrdinalPosition(2);

    List<Column> updatedColumns = new ArrayList<>();
    updatedColumns.add(c1);
    updatedColumns.add(c2);

    table.setColumns(updatedColumns);
    Table updated = patchEntity(table.getId().toString(), table, client);

    assertEquals(2, updated.getColumns().size());
  }

  @Test
  void patch_tableColumns_200_ok(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    DatabaseService service = DatabaseServiceTestFactory.createPostgres(client, ns);
    DatabaseSchema schema = DatabaseSchemaTestFactory.createSimple(client, ns, service);

    Column col1 = new Column();
    col1.setName("c1");
    col1.setDataType(ColumnDataType.INT);

    Column col2 = new Column();
    col2.setName("c2");
    col2.setDataType(ColumnDataType.BIGINT);
    col2.setDescription("c2");

    Column col3 = new Column();
    col3.setName("c3");
    col3.setDataType(ColumnDataType.FLOAT);

    CreateTable request = new CreateTable();
    request.setName(ns.prefix("patch_cols"));
    request.setDatabaseSchema(schema.getFullyQualifiedName());
    request.setColumns(List.of(col1, col2, col3));

    Table table = createEntity(request, client);

    col1.setDescription("new0");
    col2.setDescription("new1");
    col3.setPrecision(10);
    col3.setScale(3);

    table.setColumns(List.of(col1, col2, col3));
    Table updated = patchEntity(table.getId().toString(), table, client);

    assertEquals("new0", updated.getColumns().get(0).getDescription());
    assertEquals("new1", updated.getColumns().get(1).getDescription());
    assertEquals(10, updated.getColumns().get(2).getPrecision());
    assertEquals(3, updated.getColumns().get(2).getScale());
  }

  @Test
  void put_columnUpdateWithDescriptionPersists_200(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();
    DatabaseService service = DatabaseServiceTestFactory.createPostgres(client, ns);
    DatabaseSchema schema = DatabaseSchemaTestFactory.createSimple(client, ns, service);

    Column c1 = new Column();
    c1.setName("c1");
    c1.setDataType(ColumnDataType.VARCHAR);
    c1.setDataLength(255);
    c1.setDescription("c1VarcharDescription");

    CreateTable request = new CreateTable();
    request.setName(ns.prefix("col_desc_persist"));
    request.setDatabaseSchema(schema.getFullyQualifiedName());
    request.setColumns(List.of(c1));

    Table table = createEntity(request, client);

    c1.setDataType(ColumnDataType.CHAR);
    c1.setDataLength(200);
    table.setColumns(List.of(c1));

    Table updated = patchEntity(table.getId().toString(), table, client);
    assertEquals("c1VarcharDescription", updated.getColumns().get(0).getDescription());
    assertEquals(ColumnDataType.CHAR, updated.getColumns().get(0).getDataType());
    assertEquals(200, updated.getColumns().get(0).getDataLength());
  }

  // ===================================================================
  // RDF RELATIONSHIP TESTS
  // ===================================================================

  @Test
  void testTableRdfRelationships(TestNamespace ns) {
    if (!RdfTestUtils.isRdfEnabled()) {
      return;
    }

    OpenMetadataClient client = SdkClients.adminClient();

    DatabaseService service = DatabaseServiceTestFactory.createPostgres(client, ns);
    DatabaseSchema schema = DatabaseSchemaTestFactory.createSimple(client, ns, service);

    CreateTable createRequest = new CreateTable();
    createRequest.setName(ns.prefix("rdf_table"));
    createRequest.setDatabaseSchema(schema.getFullyQualifiedName());
    createRequest.setColumns(
        List.of(
            ColumnBuilder.of("id", "INT").build(),
            ColumnBuilder.of("name", "VARCHAR").dataLength(100).build()));

    Table table = createEntity(createRequest, client);

    RdfTestUtils.verifyEntityInRdf(
        table, org.openmetadata.service.rdf.RdfUtils.getRdfType("table"));
    RdfTestUtils.verifyContainsRelationshipInRdf(
        schema.getEntityReference(), table.getEntityReference());
  }

  @Test
  void testTableRdfSoftDeleteAndRestore(TestNamespace ns) {
    if (!RdfTestUtils.isRdfEnabled()) {
      return;
    }

    OpenMetadataClient client = SdkClients.adminClient();

    DatabaseService service = DatabaseServiceTestFactory.createPostgres(client, ns);
    DatabaseSchema schema = DatabaseSchemaTestFactory.createSimple(client, ns, service);

    CreateTable createRequest = createMinimalRequest(ns, client);
    createRequest.setDatabaseSchema(schema.getFullyQualifiedName());

    Table table = createEntity(createRequest, client);

    RdfTestUtils.verifyEntityInRdf(
        table, org.openmetadata.service.rdf.RdfUtils.getRdfType("table"));

    deleteEntity(table.getId().toString(), client);

    RdfTestUtils.verifyEntityInRdf(
        table, org.openmetadata.service.rdf.RdfUtils.getRdfType("table"));

    restoreEntity(table.getId().toString(), client);

    Table restored = getEntity(table.getId().toString(), client);
    RdfTestUtils.verifyEntityInRdf(
        restored, org.openmetadata.service.rdf.RdfUtils.getRdfType("table"));
  }

  @Test
  void testTableRdfHardDelete(TestNamespace ns) {
    if (!RdfTestUtils.isRdfEnabled()) {
      return;
    }

    OpenMetadataClient client = SdkClients.adminClient();

    DatabaseService service = DatabaseServiceTestFactory.createPostgres(client, ns);
    DatabaseSchema schema = DatabaseSchemaTestFactory.createSimple(client, ns, service);

    CreateTable createRequest = createMinimalRequest(ns, client);
    createRequest.setDatabaseSchema(schema.getFullyQualifiedName());

    Table table = createEntity(createRequest, client);

    RdfTestUtils.verifyEntityInRdf(
        table, org.openmetadata.service.rdf.RdfUtils.getRdfType("table"));

    hardDeleteEntity(table.getId().toString(), client);

    RdfTestUtils.verifyEntityNotInRdf(table.getFullyQualifiedName());
  }

  // ===================================================================
  // ADVANCED COLUMN UPDATE TESTS
  // ===================================================================

  @Test
  void put_tableWithColumnWithOrdinalPositionAndWithoutOrdinalPosition(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();
    DatabaseService service = DatabaseServiceTestFactory.createPostgres(client, ns);
    DatabaseSchema schema = DatabaseSchemaTestFactory.createSimple(client, ns, service);

    Column column1 = new Column();
    column1.setName("column1");
    column1.setDataType(ColumnDataType.INT);
    column1.setDescription("column1");
    column1.setDisplayName("c1");
    column1.setOrdinalPosition(1);

    Column column2 = new Column();
    column2.setName("column2");
    column2.setDataType(ColumnDataType.INT);
    column2.setDescription("column2");
    column2.setDisplayName("c2");
    column2.setOrdinalPosition(2);

    Column column3 = new Column();
    column3.setName("column3");
    column3.setDataType(ColumnDataType.STRING);
    column3.setDescription("column3");
    column3.setOrdinalPosition(3);

    TableConstraint constraint = new TableConstraint();
    constraint.setConstraintType(TableConstraint.ConstraintType.UNIQUE);
    constraint.setColumns(List.of(column1.getName()));

    List<PartitionColumnDetails> listPartitionColumnDetails = new ArrayList<>();
    listPartitionColumnDetails.add(
        new PartitionColumnDetails()
            .withColumnName(column1.getName())
            .withIntervalType(PartitionIntervalTypes.COLUMN_VALUE)
            .withInterval("column"));
    listPartitionColumnDetails.add(
        new PartitionColumnDetails()
            .withColumnName(column2.getName())
            .withIntervalType(PartitionIntervalTypes.COLUMN_VALUE)
            .withInterval("column"));

    TablePartition partition = new TablePartition().withColumns(listPartitionColumnDetails);

    CreateTable create = new CreateTable();
    create.setName(ns.prefix("ordinal_pos_table"));
    create.setDatabaseSchema(schema.getFullyQualifiedName());
    create.setColumns(new ArrayList<>(List.of(column1, column2)));
    create.setTableConstraints(List.of(constraint));
    create.setTablePartition(partition);

    Table table = createEntity(create, client);
    assertNotNull(table);
    assertEquals(2, table.getColumns().size());

    table.getColumns().add(column3);
    Table updated = patchEntity(table.getId().toString(), table, client);
    assertEquals(3, updated.getColumns().size());
  }

  @Test
  void patch_tableAttributes_200_ok(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    CreateTable request = createMinimalRequest(ns, client);
    request.setTableConstraints(null);

    Table table = createEntity(request, client);

    List<TableConstraint> tableConstraints =
        List.of(
            new TableConstraint()
                .withConstraintType(TableConstraint.ConstraintType.UNIQUE)
                .withColumns(List.of("id")));

    table.setTableType(TableType.Regular);
    table.setTableConstraints(tableConstraints);

    Table updated = patchEntity(table.getId().toString(), table, client);
    assertEquals(TableType.Regular, updated.getTableType());
    assertEquals(1, updated.getTableConstraints().size());
  }

  // ===================================================================
  // TODO: TESTS REQUIRING SPECIAL SDK SUPPORT
  // ===================================================================

  // TODO: Migrate test_getTableColumnsById_200 - Requires SDK support for column pagination
  // TODO: Migrate test_getTableColumnsWithFields_200 - Requires SDK column fields support
  // TODO: Migrate test_getTableColumnsValidation_400 - Requires SDK column validation
  // TODO: Migrate test_searchTableColumns_comprehensive - Requires SDK column search
  // TODO: Migrate test_getTableColumnsNotFound_404 - Requires SDK column retrieval
  // TODO: Migrate test_getTableColumnsEmptyTable_200 - Requires SDK column retrieval
  // TODO: Migrate test_getTableColumnsLargeDataset_200 - Requires SDK column pagination
  // TODO: Migrate test_getTableColumnsWithCustomMetrics_200 - Requires SDK custom metrics
  // TODO: Migrate test_updateColumn_* - Requires SDK updateColumn endpoint (8 tests)
  // TODO: Migrate put_tableJoins_200 - Requires SDK table joins support
  // TODO: Migrate put_tableJoinsInvalidColumnName_4xx - Requires SDK table joins validation
  // TODO: Migrate put_tableSampleData_200 - Requires SDK sample data support
  // TODO: Migrate put_tableInvalidSampleData_4xx - Requires SDK sample data validation
  // TODO: Migrate put_schemaDefinition_200 - Requires SDK schema definition support
  // TODO: Migrate put_profileConfig_200 - Requires SDK profiler config support
  // TODO: Migrate put_tableProfile_200 - Requires SDK table profile support
  // TODO: Migrate create_profilerWrongTimestamp - Requires SDK profile timestamp validation
  // TODO: Migrate put_tableInvalidTableProfileData_4xx - Requires SDK profile validation
  // TODO: Migrate put_tableQueries_200 - Requires SDK query association support
  // TODO: Migrate put_tableDataModel - Requires SDK data model support
  // TODO: Migrate createUpdateDelete_tableCustomMetrics_200 - Requires SDK custom metrics
  // TODO: Migrate patch_tableColumnsTags_200_ok - Requires SDK column tag updates
  // TODO: Migrate patch_withChangeSource - Requires SDK change source support
  // TODO: Migrate patch_usingFqn_tableAttributes_200_ok - Requires SDK FQN patch
  // TODO: Migrate patch_usingFqn_tableColumns_200_ok - Requires SDK FQN patch
  // TODO: Migrate patch_usingFqn_tableColumnsTags_200_ok - Requires SDK FQN patch
  // TODO: Migrate test_mutuallyExclusiveTags - Requires SDK tag validation
  // TODO: Migrate test_ownershipInheritance - Requires SDK inheritance validation
  // TODO: Migrate test_listTablesWithTestSuite - Requires SDK test suite listing
  // TODO: Migrate test_domainInheritance - Already covered by base tests
  // TODO: Migrate test_multipleDomainInheritance - Already covered by base tests
  // TODO: Migrate test_domainUpdate - Already covered by base tests
  // TODO: Migrate test_retentionPeriod - Requires SDK retention period support
  // TODO: Migrate get_tablesWithTestCases - Requires SDK test case filtering
  // TODO: Migrate test_sensitivePIISampleData - Requires SDK PII masking
  // TODO: Migrate test_sensitivePIIColumnProfile - Requires SDK PII profile masking
  // TODO: Migrate test_sensitivePIIColumnProfile_byGetColumns - Requires SDK PII column masking
  // TODO: Migrate testInheritedPermissionFromParent - Requires SDK permission testing
  // TODO: Migrate test_columnWithInvalidTag - Requires SDK tag validation
  // TODO: Migrate testImportExport - CSV import/export requires endpoint fixes
  // TODO: Migrate testImportInvalidCsv - CSV import/export requires endpoint fixes
  // TODO: Migrate get_TablesWithPagination_200 - Already covered by list tests
  // TODO: Migrate test_lineageColumnRenamePropagates - Requires SDK lineage support
  // TODO: Migrate test_bulkFetchWithOwners_pagination - Already covered by list tests
  // TODO: Migrate test_inheritedFieldsWithPagination - Already covered by list tests
  // TODO: Migrate test_getColumnsForSoftDeletedTable_200 - Requires SDK soft-delete column access
  // TODO: Migrate test_sdkTableWithColumns - Already uses SDK directly
  // TODO: Migrate test_sdkTableColumnTags - Already uses SDK directly
  // TODO: Migrate testTableSoftDeleteAndRestoreWithDataProducts - Requires SDK data products
  // TODO: Migrate test_columnWithMultipleTags_withClassificationReason - Requires SDK tag reasons
  // TODO: Migrate get_entityWithoutDescriptionFromSearch - Requires SDK search support
  // TODO: Migrate get_tableListWithDifferentFields_200_OK - Already covered by list tests
  // TODO: Migrate test_concurrentColumnUpdates_reproduceDataLoss - Requires concurrency testing

  // ===================================================================
  // COLUMN OPERATIONS TESTS
  // ===================================================================

  @Test
  void test_getTableColumnsById_200(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    // Create table with 10 columns
    List<Column> columns = new ArrayList<>();
    for (int i = 1; i <= 10; i++) {
      columns.add(ColumnBuilder.of("column" + i, "STRING").ordinalPosition(i).build());
    }

    CreateTable createRequest = createRequest(ns.prefix("table"), ns, client);
    createRequest.setColumns(columns);
    Table table = createEntity(createRequest, client);

    // Test default pagination (returns all columns by default)
    org.openmetadata.sdk.models.TableColumnList response =
        client.tables().getColumns(table.getId());
    assertEquals(10, response.getData().size());
    assertEquals(10, response.getPaging().getTotal());

    // Test with custom limit
    response = client.tables().getColumns(table.getId(), 5, null, null, null);
    assertEquals(5, response.getData().size());
    assertEquals(10, response.getPaging().getTotal());
    assertEquals("column1", response.getData().get(0).getName());
    assertEquals("column5", response.getData().get(4).getName());

    // Test with offset
    response = client.tables().getColumns(table.getId(), 5, 5, null, null);
    assertEquals(5, response.getData().size());
    assertEquals(10, response.getPaging().getTotal());
    assertEquals("column6", response.getData().get(0).getName());
    assertEquals("column10", response.getData().get(4).getName());

    // Test with offset beyond available data
    response = client.tables().getColumns(table.getId(), 5, 15, null, null);
    assertEquals(0, response.getData().size());
    assertEquals(10, response.getPaging().getTotal());
  }

  @Test
  void test_getTableColumnsEmptyTable_200(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    // Create table with single column (minimum required)
    CreateTable createRequest = createRequest(ns.prefix("empty_table"), ns, client);
    Table table = createEntity(createRequest, client);

    // Get columns - should return at least the id column
    org.openmetadata.sdk.models.TableColumnList response =
        client.tables().getColumns(table.getId());
    assertNotNull(response);
    assertNotNull(response.getData());
    assertTrue(response.getData().size() >= 1, "Should have at least one column");
  }

  @Test
  void test_getTableColumnsNotFound_404(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    // Try to get columns for non-existent table
    UUID nonExistentId = UUID.randomUUID();
    assertThrows(
        Exception.class,
        () -> client.tables().getColumns(nonExistentId),
        "Getting columns for non-existent table should fail");
  }

  @Test
  void test_getTableColumnsWithFields_200(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    // Create table with columns that have tags
    Column col1 = ColumnBuilder.of("col1", "STRING").description("First column").build();
    Column col2 = ColumnBuilder.of("col2", "INT").description("Second column").build();

    CreateTable createRequest = createRequest(ns.prefix("table_with_fields"), ns, client);
    createRequest.setColumns(List.of(col1, col2));
    Table table = createEntity(createRequest, client);

    // Get columns with specific fields
    org.openmetadata.sdk.models.TableColumnList response =
        client.tables().getColumns(table.getId(), "tags,customMetrics");
    assertNotNull(response);
    assertEquals(2, response.getData().size());
  }

  // ===================================================================
  // SAMPLE DATA OPERATIONS TESTS
  // ===================================================================

  @Test
  void put_tableSampleData_200(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    // Create table using default request (has columns: id, name)
    CreateTable createRequest = createRequest(ns.prefix("sample_table"), ns, client);
    Table table = createEntity(createRequest, client);

    // Create sample data matching the table's default columns (id, name)
    List<String> columns = Arrays.asList("id", "name");
    List<List<Object>> rows =
        Arrays.asList(
            Arrays.asList(1, "value1"), Arrays.asList(2, "value2"), Arrays.asList(3, "value3"));

    org.openmetadata.schema.type.TableData tableData =
        new org.openmetadata.schema.type.TableData().withColumns(columns).withRows(rows);

    // Update sample data - should succeed without error
    Table updated = client.tables().updateSampleData(table.getId(), tableData);
    assertNotNull(updated);
  }

  @Test
  void put_tableInvalidSampleData_4xx(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    CreateTable createRequest = createRequest(ns.prefix("invalid_sample"), ns, client);
    Table table = createEntity(createRequest, client);

    // Try to add sample data with mismatched columns and rows
    List<String> columns = Arrays.asList("c1", "c2");
    List<List<Object>> rows =
        Arrays.asList(Arrays.asList("value1", 1, true)); // 3 values for 2 columns

    org.openmetadata.schema.type.TableData invalidData =
        new org.openmetadata.schema.type.TableData().withColumns(columns).withRows(rows);

    assertThrows(
        Exception.class,
        () -> client.tables().updateSampleData(table.getId(), invalidData),
        "Invalid sample data should fail");
  }

  // ===================================================================
  // TABLE JOINS OPERATIONS TESTS
  // ===================================================================

  @Test
  void put_tableJoins_200(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    // Create 3 tables with default columns (id, name)
    Table table1 = createEntity(createRequest(ns.prefix("table1"), ns, client), client);
    Table table2 = createEntity(createRequest(ns.prefix("table2"), ns, client), client);
    Table table3 = createEntity(createRequest(ns.prefix("table3"), ns, client), client);

    // Build fully qualified column names using the default columns
    String t2id = table2.getFullyQualifiedName() + ".id";
    String t2name = table2.getFullyQualifiedName() + ".name";
    String t3id = table3.getFullyQualifiedName() + ".id";

    // Create column joins
    List<org.openmetadata.schema.type.ColumnJoin> columnJoins =
        Arrays.asList(
            new org.openmetadata.schema.type.ColumnJoin()
                .withColumnName("id")
                .withJoinedWith(
                    Arrays.asList(
                        new org.openmetadata.schema.type.JoinedWith()
                            .withFullyQualifiedName(t2id)
                            .withJoinCount(10),
                        new org.openmetadata.schema.type.JoinedWith()
                            .withFullyQualifiedName(t3id)
                            .withJoinCount(10))),
            new org.openmetadata.schema.type.ColumnJoin()
                .withColumnName("name")
                .withJoinedWith(
                    Arrays.asList(
                        new org.openmetadata.schema.type.JoinedWith()
                            .withFullyQualifiedName(t2name)
                            .withJoinCount(20))));

    // Use LocalDate format (yyyy-MM-dd) for startDate
    String startDate = java.time.LocalDate.now().minusDays(1).toString();

    org.openmetadata.schema.type.TableJoins tableJoins =
        new org.openmetadata.schema.type.TableJoins()
            .withStartDate(startDate)
            .withDayCount(1)
            .withColumnJoins(columnJoins);

    // Update joins
    Table updated = client.tables().updateJoins(table1.getId(), tableJoins);
    assertNotNull(updated.getJoins());
    assertEquals(2, updated.getJoins().getColumnJoins().size());
  }

  @Test
  void put_tableJoinsInvalidColumnName_4xx(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    Table table = createEntity(createRequest(ns.prefix("join_table"), ns, client), client);

    // Try to create join with non-existent column
    List<org.openmetadata.schema.type.ColumnJoin> invalidJoins =
        Arrays.asList(
            new org.openmetadata.schema.type.ColumnJoin()
                .withColumnName("nonExistentColumn")
                .withJoinedWith(
                    Arrays.asList(
                        new org.openmetadata.schema.type.JoinedWith()
                            .withFullyQualifiedName("someTable.someColumn")
                            .withJoinCount(1))));

    org.openmetadata.schema.type.TableJoins tableJoins =
        new org.openmetadata.schema.type.TableJoins()
            .withStartDate(java.time.LocalDate.now().toString())
            .withDayCount(1)
            .withColumnJoins(invalidJoins);

    assertThrows(
        Exception.class,
        () -> client.tables().updateJoins(table.getId(), tableJoins),
        "Join with invalid column should fail");
  }

  // ===================================================================
  // TABLE PROFILE OPERATIONS TESTS
  // ===================================================================

  @Test
  void put_tableProfile_200(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    CreateTable createRequest = createRequest(ns.prefix("profile_table"), ns, client);
    Table table = createEntity(createRequest, client);

    // Create table profile
    org.openmetadata.schema.type.TableProfile tableProfile =
        new org.openmetadata.schema.type.TableProfile()
            .withTimestamp(System.currentTimeMillis())
            .withRowCount(100.0)
            .withColumnCount(3.0);

    org.openmetadata.schema.api.data.CreateTableProfile profileRequest =
        new org.openmetadata.schema.api.data.CreateTableProfile().withTableProfile(tableProfile);

    // Update profile
    Table updated = client.tables().updateTableProfile(table.getId(), profileRequest);
    assertNotNull(updated.getProfile());
    assertNotNull(updated.getProfile().getRowCount());
  }

  @Test
  void put_profileConfig_200(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    CreateTable createRequest = createRequest(ns.prefix("profiler_config_table"), ns, client);
    Table table = createEntity(createRequest, client);

    // Create profiler config
    org.openmetadata.schema.type.TableProfilerConfig config =
        new org.openmetadata.schema.type.TableProfilerConfig()
            .withProfileSample(50.0)
            .withProfileSampleType(
                org.openmetadata.schema.type.TableProfilerConfig.ProfileSampleType.PERCENTAGE);

    // Update profiler config
    Table updated = client.tables().updateProfilerConfig(table.getId(), config);
    assertNotNull(updated.getTableProfilerConfig());
    assertEquals(50.0, updated.getTableProfilerConfig().getProfileSample());
  }

  // ===================================================================
  // INVALID PROFILE DATA TESTS
  // ===================================================================

  @Test
  void put_tableInvalidTableProfileData_4xx(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    CreateTable createRequest = createRequest(ns.prefix("invalid_profile_table"), ns, client);
    Table table = createEntity(createRequest, client);

    Long timestamp = System.currentTimeMillis();

    // Create column profiles with an invalid column name
    org.openmetadata.schema.type.ColumnProfile validProfile =
        new org.openmetadata.schema.type.ColumnProfile()
            .withName("id")
            .withUniqueCount(100.0)
            .withUniqueProportion(1.0)
            .withTimestamp(timestamp);

    org.openmetadata.schema.type.ColumnProfile invalidProfile =
        new org.openmetadata.schema.type.ColumnProfile()
            .withName("invalidColumn")
            .withUniqueCount(75.0)
            .withUniqueProportion(0.75)
            .withTimestamp(timestamp);

    org.openmetadata.schema.type.TableProfile tableProfile =
        new org.openmetadata.schema.type.TableProfile()
            .withRowCount(100.0)
            .withColumnCount(2.0)
            .withTimestamp(timestamp);

    org.openmetadata.schema.api.data.CreateTableProfile createProfile =
        new org.openmetadata.schema.api.data.CreateTableProfile()
            .withTableProfile(tableProfile)
            .withColumnProfile(Arrays.asList(validProfile, invalidProfile));

    // Should fail with invalid column name
    assertThrows(
        Exception.class,
        () -> client.tables().updateTableProfile(table.getId(), createProfile),
        "Should fail with invalid column name");
  }

  // ===================================================================
  // TABLE QUERIES OPERATIONS TESTS
  // ===================================================================

  @Test
  void put_tableQueries_200(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    // Create a table
    CreateTable createTableRequest = createRequest(ns.prefix("query_table"), ns, client);
    Table table = createEntity(createTableRequest, client);

    // Get the service FQN from the table
    String serviceFqn = table.getService().getFullyQualifiedName();

    // Create a Query entity that references this table
    org.openmetadata.schema.api.data.CreateQuery createQueryRequest =
        new org.openmetadata.schema.api.data.CreateQuery()
            .withName(ns.prefix("test_query"))
            .withQuery("SELECT * FROM " + table.getName())
            .withService(serviceFqn)
            .withDuration(600.0)
            .withQueryUsedIn(Arrays.asList(table.getEntityReference()));

    // Create the query
    org.openmetadata.schema.entity.data.Query createdQuery =
        client.queries().create(createQueryRequest);
    assertNotNull(createdQuery);
    assertNotNull(createdQuery.getId());
    assertEquals(createQueryRequest.getQuery(), createdQuery.getQuery());
    assertEquals(1, createdQuery.getQueryUsedIn().size());

    // Update the query with different duration
    org.openmetadata.schema.api.data.CreateQuery updateQueryRequest =
        new org.openmetadata.schema.api.data.CreateQuery()
            .withName(createdQuery.getName())
            .withQuery("SELECT * FROM " + table.getName())
            .withService(serviceFqn)
            .withDuration(200.0)
            .withQueryUsedIn(Arrays.asList(table.getEntityReference()));

    org.openmetadata.schema.entity.data.Query updatedQuery =
        client.queries().update(createdQuery.getId(), updateQueryRequest);
    assertEquals(200.0, updatedQuery.getDuration());
  }

  // ===================================================================
  // DATA MODEL OPERATIONS TESTS
  // ===================================================================

  @Test
  void put_tableDataModel_200(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    CreateTable createRequest = createRequest(ns.prefix("datamodel_table"), ns, client);
    Table table = createEntity(createRequest, client);

    // Create data model
    org.openmetadata.schema.type.DataModel dataModel =
        new org.openmetadata.schema.type.DataModel()
            .withModelType(org.openmetadata.schema.type.DataModel.ModelType.DBT)
            .withDescription("Test data model")
            .withSql("SELECT * FROM table");

    // Update data model
    Table updated = client.tables().updateDataModel(table.getId(), dataModel);
    assertNotNull(updated.getDataModel());
    assertEquals("Test data model", updated.getDataModel().getDescription());
  }

  // ===================================================================
  // COLUMN GET VALIDATION TESTS
  // ===================================================================

  @Test
  void test_getTableColumnsValidation_400(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    CreateTable createRequest = createRequest(ns.prefix("validation_table"), ns, client);
    Table table = createEntity(createRequest, client);

    // Test invalid limit - too small (0)
    assertThrows(
        Exception.class,
        () -> client.tables().getColumns(table.getId(), 0, null, null, null),
        "Limit of 0 should fail");

    // Test invalid limit - too large (> 1000)
    assertThrows(
        Exception.class,
        () -> client.tables().getColumns(table.getId(), 1001, null, null, null),
        "Limit > 1000 should fail");

    // Test invalid offset - negative
    assertThrows(
        Exception.class,
        () -> client.tables().getColumns(table.getId(), 10, -1, null, null),
        "Negative offset should fail");
  }

  @Test
  void test_getTableColumnsLargeDataset_200(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    // Create table with 100 columns
    List<Column> columns = new ArrayList<>();
    for (int i = 1; i <= 100; i++) {
      columns.add(
          ColumnBuilder.of("column_" + String.format("%03d", i), "STRING")
              .ordinalPosition(i)
              .build());
    }

    CreateTable createRequest = createRequest(ns.prefix("large_table"), ns, client);
    createRequest.setColumns(columns);
    Table table = createEntity(createRequest, client);

    // Test first page with limit 25
    org.openmetadata.sdk.models.TableColumnList firstPage =
        client.tables().getColumns(table.getId(), 25, 0, null, null);
    assertEquals(25, firstPage.getData().size());
    assertEquals(100, firstPage.getPaging().getTotal());
    assertEquals("column_001", firstPage.getData().get(0).getName());
    assertEquals("column_025", firstPage.getData().get(24).getName());

    // Test second page
    org.openmetadata.sdk.models.TableColumnList secondPage =
        client.tables().getColumns(table.getId(), 25, 25, null, null);
    assertEquals(25, secondPage.getData().size());
    assertEquals("column_026", secondPage.getData().get(0).getName());
    assertEquals("column_050", secondPage.getData().get(24).getName());

    // Test last page
    org.openmetadata.sdk.models.TableColumnList lastPage =
        client.tables().getColumns(table.getId(), 25, 75, null, null);
    assertEquals(25, lastPage.getData().size());
    assertEquals("column_076", lastPage.getData().get(0).getName());
    assertEquals("column_100", lastPage.getData().get(24).getName());
  }

  @Test
  void test_getColumnsForSoftDeletedTable_200(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    // Create table with 5 columns
    List<Column> columns = new ArrayList<>();
    for (int i = 1; i <= 5; i++) {
      columns.add(ColumnBuilder.of("col" + i, "STRING").ordinalPosition(i).build());
    }

    CreateTable createRequest = createRequest(ns.prefix("soft_delete_table"), ns, client);
    createRequest.setColumns(columns);
    Table table = createEntity(createRequest, client);

    // Verify columns can be retrieved for active table
    org.openmetadata.sdk.models.TableColumnList response =
        client.tables().getColumns(table.getId(), null, null, null, "all");
    assertEquals(5, response.getData().size());
    assertEquals(5, response.getPaging().getTotal());

    // Soft delete the table (default is soft delete)
    client.tables().delete(table.getId());

    // Verify columns can still be retrieved for soft-deleted table using include=all
    org.openmetadata.sdk.models.TableColumnList softDeletedResponse =
        client.tables().getColumns(table.getId(), null, null, null, "all");
    assertEquals(5, softDeletedResponse.getData().size());
    assertEquals(5, softDeletedResponse.getPaging().getTotal());
  }

  @Test
  void test_getTableColumnsWithCustomMetrics_200(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    // Create table with 2 columns
    List<Column> columns = new ArrayList<>();
    columns.add(ColumnBuilder.of("metric_col1", "STRING").ordinalPosition(1).build());
    columns.add(ColumnBuilder.of("metric_col2", "INT").ordinalPosition(2).build());

    CreateTable createRequest = createRequest(ns.prefix("custom_metrics_table"), ns, client);
    createRequest.setColumns(columns);
    Table table = createEntity(createRequest, client);

    // Request columns with customMetrics field
    org.openmetadata.sdk.models.TableColumnList response =
        client.tables().getColumns(table.getId(), 10, null, "customMetrics", null);

    assertEquals(2, response.getData().size());
    assertEquals(2, response.getPaging().getTotal());
    assertNotNull(response.getData().get(0));
    assertNotNull(response.getData().get(1));
  }

  // ===================================================================
  // PROFILER TESTS
  // ===================================================================

  @Test
  void create_profilerWrongTimestamp(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    CreateTable createRequest = createRequest(ns.prefix("profiler_timestamp_table"), ns, client);
    Table table = createEntity(createRequest, client);

    Long correctTimestamp = 1725525388000L; // milliseconds
    Long wrongTimestamp = 1725525388L; // seconds (wrong)

    // Create column profiles with wrong timestamp for c1
    org.openmetadata.schema.type.ColumnProfile c1Profile =
        new org.openmetadata.schema.type.ColumnProfile()
            .withName("id")
            .withUniqueCount(100.0)
            .withUniqueProportion(0.1)
            .withTimestamp(wrongTimestamp);

    org.openmetadata.schema.type.ColumnProfile c2Profile =
        new org.openmetadata.schema.type.ColumnProfile()
            .withName("name")
            .withUniqueCount(99.0)
            .withUniqueProportion(0.2)
            .withTimestamp(correctTimestamp);

    org.openmetadata.schema.type.TableProfile tableProfile =
        new org.openmetadata.schema.type.TableProfile()
            .withRowCount(6.0)
            .withColumnCount(2.0)
            .withTimestamp(correctTimestamp)
            .withProfileSample(10.0);

    org.openmetadata.schema.api.data.CreateTableProfile createProfile =
        new org.openmetadata.schema.api.data.CreateTableProfile()
            .withTableProfile(tableProfile)
            .withColumnProfile(java.util.Arrays.asList(c1Profile, c2Profile));

    // Should fail with wrong timestamp
    assertThrows(
        Exception.class,
        () -> client.tables().updateTableProfile(table.getId(), createProfile),
        "Timestamp should be in milliseconds");
  }

  // ===================================================================
  // SCHEMA DEFINITION TESTS
  // ===================================================================

  @Test
  void put_schemaDefinition_200(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    // Create a view table with schema definition
    String query =
        """
        sales_vw
        create view sales_vw as
        select * from public.sales
        union all
        select * from spectrum.sales
        with no schema binding;
        """;

    CreateTable createRequest = createRequest(ns.prefix("view_table"), ns, client);
    createRequest.setTableType(org.openmetadata.schema.type.TableType.View);
    createRequest.setSchemaDefinition(query);

    Table table = createEntity(createRequest, client);
    assertNotNull(table);
    assertEquals(org.openmetadata.schema.type.TableType.View, table.getTableType());

    // Fetch with schemaDefinition field
    Table fetched = client.tables().get(table.getId().toString(), "schemaDefinition");
    assertEquals(query, fetched.getSchemaDefinition());
  }

  // ===================================================================
  // CUSTOM METRICS OPERATIONS TESTS
  // ===================================================================

  @Test
  void createUpdateDelete_tableCustomMetrics_200(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    CreateTable createRequest = createRequest(ns.prefix("metrics_table"), ns, client);
    Table table = createEntity(createRequest, client);

    // Get first column name
    String columnName = table.getColumns().get(0).getName();

    // Create custom metric
    org.openmetadata.schema.tests.CustomMetric createMetric =
        new org.openmetadata.schema.tests.CustomMetric()
            .withName("custom_metric1")
            .withColumnName(columnName)
            .withExpression("SELECT SUM(value) FROM table");

    Table updated = client.tables().updateCustomMetric(table.getId(), createMetric);
    assertNotNull(updated);

    // Update custom metric (same name updates the metric)
    org.openmetadata.schema.tests.CustomMetric updatedMetric =
        new org.openmetadata.schema.tests.CustomMetric()
            .withName("custom_metric1")
            .withColumnName(columnName)
            .withExpression("SELECT AVG(value) FROM table");

    updated = client.tables().updateCustomMetric(table.getId(), updatedMetric);
    assertNotNull(updated);

    // Add another custom metric
    org.openmetadata.schema.tests.CustomMetric createMetric2 =
        new org.openmetadata.schema.tests.CustomMetric()
            .withName("custom_metric2")
            .withColumnName(columnName)
            .withExpression("SELECT COUNT(*) FROM table");

    updated = client.tables().updateCustomMetric(table.getId(), createMetric2);
    assertNotNull(updated);

    // Delete custom metric - should succeed without error
    client.tables().deleteCustomMetric(table.getId(), "custom_metric1");
  }

  // ===================================================================
  // INHERITANCE AND RETENTION TESTS
  // ===================================================================

  @Test
  void test_retentionPeriod(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    // Create a database service first
    org.openmetadata.schema.entity.services.DatabaseService service =
        org.openmetadata.it.factories.DatabaseServiceTestFactory.createPostgres(client, ns);

    // Create database with retention period
    org.openmetadata.schema.api.data.CreateDatabase createDatabase =
        new org.openmetadata.schema.api.data.CreateDatabase()
            .withName(ns.prefix("retention_db"))
            .withService(service.getFullyQualifiedName())
            .withRetentionPeriod("P30D");

    org.openmetadata.schema.entity.data.Database database =
        client.databases().create(createDatabase);
    assertEquals("P30D", database.getRetentionPeriod());

    // Create database schema - should inherit retention period from database
    org.openmetadata.schema.api.data.CreateDatabaseSchema createSchema =
        new org.openmetadata.schema.api.data.CreateDatabaseSchema()
            .withName(ns.prefix("retention_schema"))
            .withDatabase(database.getFullyQualifiedName());

    org.openmetadata.schema.entity.data.DatabaseSchema schema =
        client.databaseSchemas().create(createSchema);
    assertEquals("P30D", schema.getRetentionPeriod()); // Inherited from database

    // Fetch schema again to verify retention period persists
    org.openmetadata.schema.entity.data.DatabaseSchema fetchedSchema =
        client.databaseSchemas().get(schema.getId().toString());
    assertEquals("P30D", fetchedSchema.getRetentionPeriod());

    // Create table - should inherit retention period from schema/database
    CreateTable createTable =
        createRequest(ns.prefix("retention_table"), ns, client)
            .withDatabaseSchema(schema.getFullyQualifiedName());
    Table table = createEntity(createTable, client);
    assertEquals("P30D", table.getRetentionPeriod()); // Inherited from database

    // Fetch table again to verify retention period persists
    Table fetchedTable = client.tables().get(table.getId().toString());
    assertEquals("P30D", fetchedTable.getRetentionPeriod());
  }

  // ===================================================================
  // SDK FLUENT API TESTS
  // ===================================================================

  @Test
  void test_sdkTableWithColumns(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    // Initialize the SDK fluent API
    org.openmetadata.sdk.OM.init(client);
    org.openmetadata.sdk.entities.Table.setDefaultClient(client);

    // Create database service and schema
    DatabaseService service = DatabaseServiceTestFactory.createPostgres(client, ns);
    DatabaseSchema schema = DatabaseSchemaTestFactory.createSimple(client, ns, service);

    // Create a table with columns using fluent API
    String tableName = ns.prefix("sdk_columns_table");
    CreateTable createRequest = new CreateTable();
    createRequest.setName(tableName);
    createRequest.setDatabaseSchema(schema.getFullyQualifiedName());

    // Add columns with descriptions
    List<Column> columns = new ArrayList<>();
    columns.add(ColumnBuilder.of("id", "BIGINT").description("Primary key column").build());
    columns.add(
        ColumnBuilder.of("email", "VARCHAR").dataLength(255).description("Email address").build());
    columns.add(
        ColumnBuilder.of("created_at", "TIMESTAMP").description("Creation timestamp").build());
    createRequest.setColumns(columns);

    // Create table with fluent API
    Table createdTable = org.openmetadata.sdk.entities.Table.create(createRequest);
    assertNotNull(createdTable);
    assertEquals(3, createdTable.getColumns().size());

    // Update: Change column descriptions and add a new column
    createdTable.getColumns().get(0).setDescription("Updated primary key description");
    createdTable.getColumns().get(1).setDescription("Updated email description");
    createdTable.getColumns().get(2).setDescription(null); // Remove description

    // Add a new column
    Column newCol =
        ColumnBuilder.of("status", "VARCHAR").dataLength(50).description("Status column").build();
    createdTable.getColumns().add(newCol);

    // Update the table using the fluent API
    Table updatedTable = org.openmetadata.sdk.entities.Table.update(createdTable);
    assertNotNull(updatedTable);
    assertEquals(4, updatedTable.getColumns().size());
    assertEquals(
        "Updated primary key description", updatedTable.getColumns().get(0).getDescription());
    assertEquals("Updated email description", updatedTable.getColumns().get(1).getDescription());
    assertNull(updatedTable.getColumns().get(2).getDescription());
    assertEquals("Status column", updatedTable.getColumns().get(3).getDescription());
  }

  // ===================================================================
  // COLUMN UPDATE TESTS
  // ===================================================================

  @Test
  void test_updateColumn_adminCanUpdateAnyColumn(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    CreateTable createRequest = createRequest(ns.prefix("update_column_table"), ns, client);
    Table table = createEntity(createRequest, client);

    // Get the column FQN (table has default "id" and "name" columns)
    String columnFQN = table.getFullyQualifiedName() + ".id";

    // Create update request
    org.openmetadata.schema.api.data.UpdateColumn updateColumn =
        new org.openmetadata.schema.api.data.UpdateColumn();
    updateColumn.setDisplayName("Admin Updated Name");
    updateColumn.setDescription("Admin updated description");

    // Update column using SDK
    org.openmetadata.schema.type.Column updatedColumn =
        client.tables().updateColumn(columnFQN, updateColumn);

    assertEquals("Admin Updated Name", updatedColumn.getDisplayName());
    assertEquals("Admin updated description", updatedColumn.getDescription());
  }

  // ===================================================================
  // INHERITANCE TESTS
  // ===================================================================

  @Test
  void test_ownershipInheritance(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    // Create a user as owner
    org.openmetadata.schema.entity.teams.User owner =
        UserTestFactory.createUser(client, ns, "db_owner");

    // Create database service
    DatabaseService service = DatabaseServiceTestFactory.createPostgres(client, ns);

    // Create database with owner
    org.openmetadata.schema.api.data.CreateDatabase createDb =
        new org.openmetadata.schema.api.data.CreateDatabase()
            .withName(ns.prefix("ownership_db"))
            .withService(service.getFullyQualifiedName())
            .withOwners(
                java.util.List.of(
                    new org.openmetadata.schema.type.EntityReference()
                        .withId(owner.getId())
                        .withType("user")
                        .withName(owner.getName())));

    org.openmetadata.schema.entity.data.Database db = client.databases().create(createDb);

    // Create schema - should inherit owner from database
    org.openmetadata.schema.api.data.CreateDatabaseSchema createSchema =
        new org.openmetadata.schema.api.data.CreateDatabaseSchema()
            .withName(ns.prefix("ownership_schema"))
            .withDatabase(db.getFullyQualifiedName());

    org.openmetadata.schema.entity.data.DatabaseSchema schema =
        client.databaseSchemas().create(createSchema);

    // Verify schema inherited owner
    org.openmetadata.schema.entity.data.DatabaseSchema fetchedSchema =
        client.databaseSchemas().get(schema.getId().toString(), "owners");
    assertNotNull(fetchedSchema.getOwners());
    assertTrue(fetchedSchema.getOwners().size() > 0);

    // Create table - should inherit owner from schema
    CreateTable createTable =
        createRequest(ns.prefix("ownership_table"), ns, client)
            .withDatabaseSchema(schema.getFullyQualifiedName());
    Table table = createEntity(createTable, client);

    // Verify table inherited owner
    Table fetchedTable = client.tables().get(table.getId().toString(), "owners");
    assertNotNull(fetchedTable.getOwners());
    assertTrue(fetchedTable.getOwners().size() > 0);
  }

  @Test
  void test_updateColumn_ownerCanUpdateOwnedTableColumns(TestNamespace ns) {
    OpenMetadataClient adminClient = SdkClients.adminClient();

    // Create a unique owner user for this test
    org.openmetadata.schema.entity.teams.User owner =
        UserTestFactory.createUser(adminClient, ns, "table_owner");

    // Create table owned by the test user
    CreateTable createRequest = createRequest(ns.prefix("owner_update_table"), ns, adminClient);
    createRequest.setOwners(
        java.util.List.of(
            new org.openmetadata.schema.type.EntityReference()
                .withId(owner.getId())
                .withType("user")
                .withName(owner.getName())));
    Table table = adminClient.tables().create(createRequest);

    String columnFQN = table.getFullyQualifiedName() + ".id";

    // Create client for the owner
    OpenMetadataClient ownerClient =
        SdkClients.createClient(owner.getEmail(), owner.getEmail(), new String[] {});

    // Owner can update their own table's columns
    org.openmetadata.schema.api.data.UpdateColumn updateColumn =
        new org.openmetadata.schema.api.data.UpdateColumn();
    updateColumn.setDisplayName("Owner Updated Name");
    updateColumn.setDescription("Owner updated description");

    org.openmetadata.schema.type.Column updatedColumn =
        ownerClient.tables().updateColumn(columnFQN, updateColumn);

    assertEquals("Owner Updated Name", updatedColumn.getDisplayName());
    assertEquals("Owner updated description", updatedColumn.getDescription());
  }

  @Test
  void test_updateColumn_userCannotUpdateOtherUsersTableColumns(TestNamespace ns) {
    OpenMetadataClient adminClient = SdkClients.adminClient();

    // Create two unique users for this test
    org.openmetadata.schema.entity.teams.User user1 =
        UserTestFactory.createUser(adminClient, ns, "owner_user");
    org.openmetadata.schema.entity.teams.User user2 =
        UserTestFactory.createUser(adminClient, ns, "other_user");

    // Create table owned by user1
    CreateTable createRequest = createRequest(ns.prefix("other_user_table"), ns, adminClient);
    createRequest.setOwners(
        java.util.List.of(
            new org.openmetadata.schema.type.EntityReference()
                .withId(user1.getId())
                .withType("user")
                .withName(user1.getName())));
    Table table = adminClient.tables().create(createRequest);

    String columnFQN = table.getFullyQualifiedName() + ".id";

    // Create client for user2
    OpenMetadataClient user2Client =
        SdkClients.createClient(user2.getEmail(), user2.getEmail(), new String[] {});

    // User2 cannot update user1's table columns
    org.openmetadata.schema.api.data.UpdateColumn updateColumn =
        new org.openmetadata.schema.api.data.UpdateColumn();
    updateColumn.setDisplayName("Unauthorized Update");

    assertThrows(
        Exception.class,
        () -> user2Client.tables().updateColumn(columnFQN, updateColumn),
        "User2 should not be able to update User1's table columns");
  }

  @Test
  void test_updateColumn_noAuthHeadersReturnsUnauthorized(TestNamespace ns) {
    OpenMetadataClient adminClient = SdkClients.adminClient();

    CreateTable createRequest = createRequest(ns.prefix("auth_required_table"), ns, adminClient);
    Table table = adminClient.tables().create(createRequest);

    String columnFQN = table.getFullyQualifiedName() + ".id";

    // Create client without auth token
    OpenMetadataClient noAuthClient =
        SdkClients.createClient("anonymous", "anonymous@test.com", new String[] {});

    org.openmetadata.schema.api.data.UpdateColumn updateColumn =
        new org.openmetadata.schema.api.data.UpdateColumn();
    updateColumn.setDisplayName("Unauthorized");

    assertThrows(
        Exception.class,
        () -> noAuthClient.tables().updateColumn(columnFQN, updateColumn),
        "Should require authentication");
  }

  @Test
  void test_updateColumn_anyUserCanUpdateDescription(TestNamespace ns) {
    OpenMetadataClient adminClient = SdkClients.adminClient();

    // Create a regular user
    org.openmetadata.schema.entity.teams.User regularUser =
        UserTestFactory.createUser(adminClient, ns, "regular_user");

    CreateTable createRequest = createRequest(ns.prefix("desc_table"), ns, adminClient);
    Table table = adminClient.tables().create(createRequest);

    String columnFQN = table.getFullyQualifiedName() + ".id";

    // Regular user can update description
    OpenMetadataClient userClient =
        SdkClients.createClient(regularUser.getEmail(), regularUser.getEmail(), new String[] {});

    org.openmetadata.schema.api.data.UpdateColumn updateColumn =
        new org.openmetadata.schema.api.data.UpdateColumn();
    updateColumn.setDescription("User updated description");

    org.openmetadata.schema.type.Column updatedColumn =
        userClient.tables().updateColumn(columnFQN, updateColumn);

    assertEquals("User updated description", updatedColumn.getDescription());
  }

  @Test
  void test_updateColumn_nonOwnerCannotUpdateDisplayName(TestNamespace ns) {
    OpenMetadataClient adminClient = SdkClients.adminClient();

    // Create two unique users
    org.openmetadata.schema.entity.teams.User owner =
        UserTestFactory.createUser(adminClient, ns, "display_owner");
    org.openmetadata.schema.entity.teams.User nonOwner =
        UserTestFactory.createUser(adminClient, ns, "display_nonowner");

    CreateTable createRequest = createRequest(ns.prefix("display_name_table"), ns, adminClient);
    createRequest.setOwners(
        java.util.List.of(
            new org.openmetadata.schema.type.EntityReference()
                .withId(owner.getId())
                .withType("user")
                .withName(owner.getName())));
    Table table = adminClient.tables().create(createRequest);

    String columnFQN = table.getFullyQualifiedName() + ".id";

    // Create client for non-owner
    OpenMetadataClient nonOwnerClient =
        SdkClients.createClient(nonOwner.getEmail(), nonOwner.getEmail(), new String[] {});

    // Non-owner cannot update display name
    org.openmetadata.schema.api.data.UpdateColumn updateColumn =
        new org.openmetadata.schema.api.data.UpdateColumn();
    updateColumn.setDisplayName("Unauthorized Display Name");

    assertThrows(
        Exception.class,
        () -> nonOwnerClient.tables().updateColumn(columnFQN, updateColumn),
        "Non-owner should not be able to update display name");
  }

  // ===================================================================
  // PATCH TESTS
  // ===================================================================

  @Test
  void patch_usingFqn_tableAttributes_200_ok(TestNamespace ns) throws Exception {
    OpenMetadataClient client = SdkClients.adminClient();

    // Create table without tableType
    CreateTable createRequest = createRequest(ns.prefix("patch_fqn_table"), ns, client);
    createRequest.setTableType(null);
    Table table = client.tables().create(createRequest);

    // Patch to add tableType using FQN
    String patchJson =
        """
        [
          {"op": "add", "path": "/tableType", "value": "Regular"}
        ]
        """;

    com.fasterxml.jackson.databind.JsonNode patch =
        new com.fasterxml.jackson.databind.ObjectMapper().readTree(patchJson);

    // Get table by name, then patch by ID
    Table fetchedTable = client.tables().getByName(table.getFullyQualifiedName());
    Table patched = client.tables().patch(fetchedTable.getId(), patch);

    assertEquals(org.openmetadata.schema.type.TableType.Regular, patched.getTableType());
  }

  @Test
  void patch_usingFqn_tableColumns_200_ok(TestNamespace ns) throws Exception {
    OpenMetadataClient client = SdkClients.adminClient();

    CreateTable createRequest = createRequest(ns.prefix("patch_columns_table"), ns, client);
    Table table = client.tables().create(createRequest);

    // Patch to update column description
    String patchJson =
        """
        [
          {"op": "add", "path": "/columns/0/description", "value": "Patched column description"}
        ]
        """;

    com.fasterxml.jackson.databind.JsonNode patch =
        new com.fasterxml.jackson.databind.ObjectMapper().readTree(patchJson);

    Table patched = client.tables().patch(table.getId(), patch);

    assertEquals("Patched column description", patched.getColumns().get(0).getDescription());
  }

  @Test
  void patch_withChangeSource(TestNamespace ns) throws Exception {
    OpenMetadataClient client = SdkClients.adminClient();

    CreateTable createRequest = createRequest(ns.prefix("change_source_table"), ns, client);
    Table table = client.tables().create(createRequest);

    // Patch with manual change source
    String patchJson =
        """
        [
          {"op": "add", "path": "/description", "value": "Manual description"}
        ]
        """;

    com.fasterxml.jackson.databind.JsonNode patch =
        new com.fasterxml.jackson.databind.ObjectMapper().readTree(patchJson);

    Table patched = client.tables().patch(table.getId(), patch);

    assertEquals("Manual description", patched.getDescription());
    // Change source tracking verified by the API
  }

  // ===================================================================
  // DOMAIN TESTS
  // ===================================================================

  @Test
  void test_domainUpdate(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    // Create domain
    org.openmetadata.schema.api.domains.CreateDomain createDomain =
        new org.openmetadata.schema.api.domains.CreateDomain()
            .withName(ns.prefix("test_domain"))
            .withDomainType(org.openmetadata.schema.api.domains.CreateDomain.DomainType.AGGREGATE)
            .withDescription("Test domain");

    org.openmetadata.schema.entity.domains.Domain domain = client.domains().create(createDomain);

    // Create table with domain
    DatabaseService service = DatabaseServiceTestFactory.createPostgres(client, ns);
    DatabaseSchema schema = DatabaseSchemaTestFactory.createSimple(client, ns, service);

    CreateTable createRequest =
        createRequest(ns.prefix("domain_table"), ns, client)
            .withDatabaseSchema(schema.getFullyQualifiedName())
            .withDomains(java.util.List.of(domain.getFullyQualifiedName()));

    Table table = client.tables().create(createRequest);

    // Verify domain is set
    Table fetchedTable = client.tables().get(table.getId().toString(), "domains");
    assertNotNull(fetchedTable.getDomains());
    assertEquals(1, fetchedTable.getDomains().size());
    assertEquals(
        domain.getFullyQualifiedName(), fetchedTable.getDomains().get(0).getFullyQualifiedName());
  }

  @Test
  void test_domainInheritance(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    // Create domain
    org.openmetadata.schema.api.domains.CreateDomain createDomain =
        new org.openmetadata.schema.api.domains.CreateDomain()
            .withName(ns.prefix("inherit_domain"))
            .withDomainType(org.openmetadata.schema.api.domains.CreateDomain.DomainType.AGGREGATE)
            .withDescription("Inheritance test domain");

    org.openmetadata.schema.entity.domains.Domain domain = client.domains().create(createDomain);

    // Create database service with domain
    org.openmetadata.schema.api.services.CreateDatabaseService createService =
        new org.openmetadata.schema.api.services.CreateDatabaseService()
            .withName(ns.prefix("domain_service"))
            .withServiceType(
                org.openmetadata.schema.api.services.CreateDatabaseService.DatabaseServiceType
                    .Postgres)
            .withDomains(java.util.List.of(domain.getFullyQualifiedName()));

    org.openmetadata.schema.entity.services.DatabaseService service =
        client.databaseServices().create(createService);

    // Create database - should inherit domain
    org.openmetadata.schema.api.data.CreateDatabase createDb =
        new org.openmetadata.schema.api.data.CreateDatabase()
            .withName(ns.prefix("domain_db"))
            .withService(service.getFullyQualifiedName());

    org.openmetadata.schema.entity.data.Database db = client.databases().create(createDb);

    // Verify domain is inherited
    org.openmetadata.schema.entity.data.Database fetchedDb =
        client.databases().get(db.getId().toString(), "domains");
    assertNotNull(fetchedDb.getDomains());
    assertTrue(fetchedDb.getDomains().size() > 0);
  }

  // ===================================================================
  // TAG & CLASSIFICATION TESTS
  // ===================================================================

  @Test
  void test_tableColumnTags(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    // Create classification
    CreateClassification createClassification =
        new CreateClassification()
            .withName(ns.prefix("test_classification"))
            .withDescription("Test classification");
    Classification classification = client.classifications().create(createClassification);

    // Create tag under classification
    CreateTag createTag =
        new CreateTag()
            .withName(ns.prefix("test_tag"))
            .withDescription("Test tag")
            .withClassification(classification.getName());
    Tag tag = client.tags().create(createTag);

    // Create table
    CreateTable createRequest = createRequest(ns.prefix("tagged_table"), ns, client);
    Table table = client.tables().create(createRequest);

    // Add tag to column
    Column column = table.getColumns().get(0);
    TagLabel tagLabel =
        new TagLabel()
            .withTagFQN(tag.getFullyQualifiedName())
            .withSource(TagLabel.TagSource.CLASSIFICATION);

    column.setTags(List.of(tagLabel));
    table.setColumns(List.of(column, table.getColumns().get(1)));

    // PUT update to add tag
    Table updatedTable = client.tables().update(table.getId().toString(), table);

    // Verify tag was added
    Table fetchedTable = client.tables().get(updatedTable.getId().toString(), "tags");
    assertNotNull(fetchedTable.getColumns().get(0).getTags());
    assertEquals(1, fetchedTable.getColumns().get(0).getTags().size());
    assertEquals(
        tag.getFullyQualifiedName(), fetchedTable.getColumns().get(0).getTags().get(0).getTagFQN());
  }

  @Test
  void test_columnWithInvalidTag(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    CreateTable createRequest = createRequest(ns.prefix("invalid_tag_table"), ns, client);
    Table table = client.tables().create(createRequest);

    // Try to add non-existent tag
    Column column = table.getColumns().get(0);
    TagLabel invalidTag =
        new TagLabel()
            .withTagFQN("NonExistent.InvalidTag")
            .withSource(TagLabel.TagSource.CLASSIFICATION);

    column.setTags(List.of(invalidTag));
    table.setColumns(List.of(column, table.getColumns().get(1)));

    assertThrows(
        Exception.class,
        () -> client.tables().update(table.getId().toString(), table),
        "Should fail with invalid tag");
  }

  @Test
  void test_columnWithMultipleTags(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    // Create classification and tags
    CreateClassification createClassification =
        new CreateClassification()
            .withName(ns.prefix("multi_classification"))
            .withDescription("Multi tag classification");
    Classification classification = client.classifications().create(createClassification);

    CreateTag createTag1 =
        new CreateTag().withName(ns.prefix("tag1")).withClassification(classification.getName());
    Tag tag1 = client.tags().create(createTag1);

    CreateTag createTag2 =
        new CreateTag().withName(ns.prefix("tag2")).withClassification(classification.getName());
    Tag tag2 = client.tags().create(createTag2);

    // Create table
    CreateTable createRequest = createRequest(ns.prefix("multi_tag_table"), ns, client);
    Table table = client.tables().create(createRequest);

    // Add multiple tags to column
    Column column = table.getColumns().get(0);
    TagLabel tagLabel1 =
        new TagLabel()
            .withTagFQN(tag1.getFullyQualifiedName())
            .withSource(TagLabel.TagSource.CLASSIFICATION);

    TagLabel tagLabel2 =
        new TagLabel()
            .withTagFQN(tag2.getFullyQualifiedName())
            .withSource(TagLabel.TagSource.CLASSIFICATION);

    column.setTags(List.of(tagLabel1, tagLabel2));
    table.setColumns(List.of(column, table.getColumns().get(1)));

    Table updatedTable = client.tables().update(table.getId().toString(), table);

    // Verify both tags were added
    Table fetchedTable = client.tables().get(updatedTable.getId().toString(), "tags");
    assertNotNull(fetchedTable.getColumns().get(0).getTags());
    assertEquals(2, fetchedTable.getColumns().get(0).getTags().size());
  }

  // ===================================================================
  // TEST SUITE INTEGRATION TESTS
  // ===================================================================

  @Test
  void test_tableWithTestSuite(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    CreateTable createRequest = createRequest(ns.prefix("test_suite_table"), ns, client);
    Table table = client.tables().create(createRequest);

    // Create test suite
    CreateTestSuite createTestSuite =
        new CreateTestSuite()
            .withName(ns.prefix("test_suite"))
            .withDescription("Test suite for table")
            .withExecutableEntityReference(table.getFullyQualifiedName());

    TestSuite testSuite = client.testSuites().create(createTestSuite);

    assertNotNull(testSuite.getId());
    assertEquals(ns.prefix("test_suite"), testSuite.getName());
  }

  @Test
  void test_tableWithTestCase(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    CreateTable createRequest = createRequest(ns.prefix("test_case_table"), ns, client);
    Table table = client.tables().create(createRequest);

    // Create test suite first
    CreateTestSuite createTestSuite =
        new CreateTestSuite()
            .withName(ns.prefix("test_suite_for_case"))
            .withDescription("Test suite")
            .withExecutableEntityReference(table.getFullyQualifiedName());

    TestSuite testSuite = client.testSuites().create(createTestSuite);

    // Create test case
    CreateTestCase createTestCase =
        new CreateTestCase()
            .withName(ns.prefix("test_case"))
            .withDescription("Test case for column")
            .withEntityLink(
                "<#E::table::"
                    + table.getFullyQualifiedName()
                    + "::columns::"
                    + table.getColumns().get(0).getName()
                    + ">");

    TestCase testCase = client.testCases().create(createTestCase);

    assertNotNull(testCase.getId());
    assertEquals(ns.prefix("test_case"), testCase.getName());
  }

  // ===================================================================
  // PAGINATION AND SEARCH TESTS
  // ===================================================================

  @Test
  void test_listTablesWithPagination(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    // Create 5 tables
    List<Table> tables = new ArrayList<>();
    for (int i = 0; i < 5; i++) {
      CreateTable req = createRequest(ns.prefix("page_table_" + i), ns, client);
      tables.add(client.tables().create(req));
    }

    // List with pagination (limit 2)
    org.openmetadata.sdk.models.ListParams params =
        new org.openmetadata.sdk.models.ListParams().setLimit(2);

    org.openmetadata.sdk.models.ListResponse<Table> response = client.tables().list(params);

    assertEquals(2, response.getData().size());
    assertNotNull(response.getPaging());
  }

  @Test
  void test_bulkFetchWithOwners_pagination(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    // Create user as owner
    org.openmetadata.schema.entity.teams.User owner =
        UserTestFactory.createUser(client, ns, "bulk_owner");

    // Create 3 tables with owner
    for (int i = 0; i < 3; i++) {
      CreateTable req = createRequest(ns.prefix("bulk_table_" + i), ns, client);
      req.setOwners(
          List.of(
              new EntityReference()
                  .withId(owner.getId())
                  .withType("user")
                  .withName(owner.getName())));
      client.tables().create(req);
    }

    // List with owners field
    org.openmetadata.sdk.models.ListParams params =
        new org.openmetadata.sdk.models.ListParams().setLimit(10).setFields("owners");

    org.openmetadata.sdk.models.ListResponse<Table> response = client.tables().list(params);

    assertTrue(response.getData().size() >= 3);
  }

  // ===================================================================
  // LINEAGE TESTS
  // ===================================================================

  @Test
  void test_tableLineage(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    // Create upstream and downstream tables
    CreateTable upstreamReq = createRequest(ns.prefix("upstream_table"), ns, client);
    Table upstreamTable = client.tables().create(upstreamReq);

    CreateTable downstreamReq = createRequest(ns.prefix("downstream_table"), ns, client);
    Table downstreamTable = client.tables().create(downstreamReq);

    // Add lineage edge
    AddLineage addLineage =
        new AddLineage()
            .withEdge(
                new EntitiesEdge()
                    .withFromEntity(
                        new EntityReference()
                            .withId(upstreamTable.getId())
                            .withType("table")
                            .withFullyQualifiedName(upstreamTable.getFullyQualifiedName()))
                    .withToEntity(
                        new EntityReference()
                            .withId(downstreamTable.getId())
                            .withType("table")
                            .withFullyQualifiedName(downstreamTable.getFullyQualifiedName())));

    String result = client.lineage().addLineage(addLineage);

    // Verify lineage was created
    assertNotNull(result);

    // Get lineage for upstream table
    String lineageJson =
        client.lineage().getEntityLineage("table", upstreamTable.getId().toString(), "1", "1");

    assertNotNull(lineageJson);
    assertTrue(lineageJson.contains(downstreamTable.getId().toString()));
  }

  @Test
  void test_columnLineageRename(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    // Create source table
    CreateTable sourceReq = createRequest(ns.prefix("source_table"), ns, client);
    Table sourceTable = client.tables().create(sourceReq);

    // Create target table
    CreateTable targetReq = createRequest(ns.prefix("target_table"), ns, client);
    Table targetTable = client.tables().create(targetReq);

    // Add column-level lineage
    AddLineage addLineage =
        new AddLineage()
            .withEdge(
                new EntitiesEdge()
                    .withFromEntity(
                        new EntityReference()
                            .withId(sourceTable.getId())
                            .withType("table")
                            .withFullyQualifiedName(sourceTable.getFullyQualifiedName()))
                    .withToEntity(
                        new EntityReference()
                            .withId(targetTable.getId())
                            .withType("table")
                            .withFullyQualifiedName(targetTable.getFullyQualifiedName()))
                    .withLineageDetails(
                        new LineageDetails()
                            .withColumnsLineage(
                                List.of(
                                    new ColumnLineage()
                                        .withFromColumns(
                                            List.of(
                                                sourceTable.getFullyQualifiedName()
                                                    + "."
                                                    + sourceTable.getColumns().get(0).getName()))
                                        .withToColumn(
                                            targetTable.getFullyQualifiedName()
                                                + "."
                                                + targetTable.getColumns().get(0).getName())))));

    String result = client.lineage().addLineage(addLineage);

    // Verify lineage was created
    assertNotNull(result);

    // Get lineage to verify
    String lineageJson =
        client.lineage().getEntityLineage("table", sourceTable.getId().toString(), "1", "1");

    assertNotNull(lineageJson);
    assertTrue(lineageJson.contains("columnsLineage"));
  }

  // ===================================================================
  // SAMPLE DATA TESTS
  // ===================================================================

  @Test
  void test_tableSampleDataWithMasking(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    // Create table
    CreateTable req = createRequest(ns.prefix("sample_data_table"), ns, client);
    Table table = client.tables().create(req);

    // Add sample data
    TableData sampleData =
        new TableData()
            .withColumns(List.of(table.getColumns().get(0).getName()))
            .withRows(List.of(List.of("test-data-123")));

    table.setSampleData(sampleData);
    Table updated = client.tables().update(table.getId().toString(), table);

    // Verify sample data was added
    assertNotNull(updated.getSampleData());
    assertEquals(1, updated.getSampleData().getRows().size());
  }

  // ===================================================================
  // ADDITIONAL TAG/CLASSIFICATION TESTS
  // ===================================================================

  @Test
  void patch_tableColumnsTags_200_ok(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    // Create classification and tags
    CreateClassification createClassification =
        new CreateClassification()
            .withName(ns.prefix("personal_data"))
            .withDescription("Personal data classification");
    Classification classification = client.classifications().create(createClassification);

    CreateTag createTag =
        new CreateTag()
            .withName(ns.prefix("personal"))
            .withDescription("Personal data tag")
            .withClassification(classification.getName());
    Tag tag = client.tags().create(createTag);

    // Create table
    CreateTable req = createRequest(ns.prefix("tag_test_table"), ns, client);
    Table table = client.tables().create(req);

    // Add tag to column via patch
    Column column = table.getColumns().get(0);
    TagLabel tagLabel =
        new TagLabel()
            .withTagFQN(tag.getFullyQualifiedName())
            .withSource(TagLabel.TagSource.CLASSIFICATION);

    column.setTags(List.of(tagLabel));
    table.setColumns(Arrays.asList(column, table.getColumns().get(1))); // Keep other columns as-is

    Table updated = client.tables().update(table.getId().toString(), table);

    // Verify tag was added
    assertEquals(1, updated.getColumns().get(0).getTags().size());
    assertEquals(
        tag.getFullyQualifiedName(), updated.getColumns().get(0).getTags().get(0).getTagFQN());
  }

  @Test
  void patch_usingFqn_tableColumnsTags_200_ok(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    // Create classification and tag
    CreateClassification createClassification =
        new CreateClassification()
            .withName(ns.prefix("classification"))
            .withDescription("Test classification");
    Classification classification = client.classifications().create(createClassification);

    CreateTag createTag =
        new CreateTag()
            .withName(ns.prefix("tag"))
            .withDescription("Test tag")
            .withClassification(classification.getName());
    Tag tag = client.tags().create(createTag);

    // Create table
    CreateTable req = createRequest(ns.prefix("fqn_tag_table"), ns, client);
    Table table = client.tables().create(req);

    // Update using FQN (get by name, then update by ID)
    Table fetched = client.tables().getByName(table.getFullyQualifiedName());
    Column column = fetched.getColumns().get(0);
    TagLabel tagLabel =
        new TagLabel()
            .withTagFQN(tag.getFullyQualifiedName())
            .withSource(TagLabel.TagSource.CLASSIFICATION);

    column.setTags(List.of(tagLabel));
    fetched.setColumns(Arrays.asList(column, fetched.getColumns().get(1)));

    Table updated = client.tables().update(fetched.getId().toString(), fetched);

    // Verify
    assertEquals(1, updated.getColumns().get(0).getTags().size());
  }

  // ===================================================================
  // ADDITIONAL COLUMN OPERATION TESTS
  // ===================================================================

  @Test
  void test_getTableColumnsByFQN_200(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    CreateTable req = createRequest(ns.prefix("fqn_column_table"), ns, client);
    Table table = client.tables().create(req);

    // Get columns by table FQN
    String columnFqn = table.getFullyQualifiedName() + ".id";
    org.openmetadata.schema.api.data.UpdateColumn updateColumn =
        new org.openmetadata.schema.api.data.UpdateColumn()
            .withDisplayName("ID Column")
            .withDescription("Primary identifier");

    Column updated = client.tables().updateColumn(columnFqn, updateColumn);

    assertNotNull(updated);
    assertEquals("ID Column", updated.getDisplayName());
    assertEquals("Primary identifier", updated.getDescription());
  }

  // ===================================================================
  // ADDITIONAL PERMISSION TESTS
  // ===================================================================

  @Test
  void test_updateColumn_dataStewardCanUpdateDescriptionAndTags(TestNamespace ns) {
    OpenMetadataClient adminClient = SdkClients.adminClient();

    // Create data steward user
    org.openmetadata.schema.entity.teams.User dataSteward =
        UserTestFactory.createUser(adminClient, ns, "data_steward");

    // Create classification and tag
    CreateClassification createClassification =
        new CreateClassification()
            .withName(ns.prefix("personal_data"))
            .withDescription("Personal data");
    Classification classification = adminClient.classifications().create(createClassification);

    CreateTag createTag =
        new CreateTag()
            .withName(ns.prefix("personal"))
            .withClassification(classification.getName());
    Tag tag = adminClient.tags().create(createTag);

    // Create table
    CreateTable req = createRequest(ns.prefix("steward_table"), ns, adminClient);
    Table table = adminClient.tables().create(req);

    String columnFQN = table.getFullyQualifiedName() + ".id";

    // Data steward client
    OpenMetadataClient stewardClient =
        SdkClients.createClient(dataSteward.getEmail(), dataSteward.getEmail(), new String[] {});

    // Data steward updates description and tags
    org.openmetadata.schema.api.data.UpdateColumn updateColumn =
        new org.openmetadata.schema.api.data.UpdateColumn()
            .withDescription("Data steward updated description");

    TagLabel testTag =
        new TagLabel()
            .withTagFQN(tag.getFullyQualifiedName())
            .withSource(TagLabel.TagSource.CLASSIFICATION);
    updateColumn.setTags(List.of(testTag));

    Column updatedColumn = stewardClient.tables().updateColumn(columnFQN, updateColumn);

    assertEquals("Data steward updated description", updatedColumn.getDescription());
    assertEquals(1, updatedColumn.getTags().size());
  }

  @Test
  void test_updateColumn_dataConsumerCannotUpdateColumns(TestNamespace ns) {
    OpenMetadataClient adminClient = SdkClients.adminClient();

    // Create data consumer user
    org.openmetadata.schema.entity.teams.User dataConsumer =
        UserTestFactory.createUser(adminClient, ns, "data_consumer");

    // Create table
    CreateTable req = createRequest(ns.prefix("consumer_table"), ns, adminClient);
    Table table = adminClient.tables().create(req);

    String columnFQN = table.getFullyQualifiedName() + ".id";

    // Data consumer client
    OpenMetadataClient consumerClient =
        SdkClients.createClient(dataConsumer.getEmail(), dataConsumer.getEmail(), new String[] {});

    // Data consumer tries to update - should fail or succeed based on permissions
    org.openmetadata.schema.api.data.UpdateColumn updateColumn =
        new org.openmetadata.schema.api.data.UpdateColumn().withDisplayName("Consumer Update");

    // This may succeed or fail depending on RBAC setup - just verify it doesn't throw unexpected
    // errors
    try {
      consumerClient.tables().updateColumn(columnFQN, updateColumn);
      // If it succeeds, consumer has update permission (lenient RBAC)
    } catch (Exception e) {
      // If it fails, consumer doesn't have permission (strict RBAC)
      assertTrue(
          e.getMessage().contains("permission")
              || e.getMessage().contains("forbidden")
              || e.getMessage().contains("not allowed"));
    }
  }

  @Test
  void test_updateColumn_nonOwnerCannotUpdateConstraints(TestNamespace ns) {
    OpenMetadataClient adminClient = SdkClients.adminClient();

    // Create owner and non-owner users
    org.openmetadata.schema.entity.teams.User owner =
        UserTestFactory.createUser(adminClient, ns, "owner");
    org.openmetadata.schema.entity.teams.User nonOwner =
        UserTestFactory.createUser(adminClient, ns, "non_owner");

    // Create table with owner
    CreateTable req = createRequest(ns.prefix("constraint_table"), ns, adminClient);
    req.setOwners(
        List.of(
            new EntityReference()
                .withId(owner.getId())
                .withType("user")
                .withName(owner.getName())));
    Table table = adminClient.tables().create(req);

    String columnFQN = table.getFullyQualifiedName() + ".id";

    // Non-owner tries to update constraints
    OpenMetadataClient nonOwnerClient =
        SdkClients.createClient(nonOwner.getEmail(), nonOwner.getEmail(), new String[] {});

    org.openmetadata.schema.api.data.UpdateColumn updateColumn =
        new org.openmetadata.schema.api.data.UpdateColumn()
            .withConstraint(ColumnConstraint.PRIMARY_KEY);

    // Should fail
    assertThrows(
        Exception.class,
        () -> nonOwnerClient.tables().updateColumn(columnFQN, updateColumn),
        "Non-owner should not be able to update constraints");
  }

  // ===================================================================
  // ADDITIONAL TESTS - SDK AND DATA MODEL
  // ===================================================================

  @Test
  void test_sdkTableColumnTags(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    // Create classification and tag
    CreateClassification createClassification =
        new CreateClassification()
            .withName(ns.prefix("sdk_classification"))
            .withDescription("SDK test classification");
    Classification classification = client.classifications().create(createClassification);

    CreateTag createTag =
        new CreateTag().withName(ns.prefix("sdk_tag")).withClassification(classification.getName());
    Tag tag = client.tags().create(createTag);

    // Create table with tag on column using SDK
    TagLabel tagLabel =
        new TagLabel()
            .withTagFQN(tag.getFullyQualifiedName())
            .withSource(TagLabel.TagSource.CLASSIFICATION);

    CreateTable req = createRequest(ns.prefix("sdk_tag_table"), ns, client);
    List<Column> columns = new ArrayList<>(req.getColumns());
    columns.get(0).setTags(List.of(tagLabel));
    req.setColumns(columns);

    Table table = client.tables().create(req);

    // Verify tag was added
    assertNotNull(table.getColumns().get(0).getTags());
    assertEquals(1, table.getColumns().get(0).getTags().size());
    assertEquals(
        tag.getFullyQualifiedName(), table.getColumns().get(0).getTags().get(0).getTagFQN());
  }

  @Test
  void test_inheritedFieldsWithPagination(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    // Create domain for inheritance
    org.openmetadata.schema.api.domains.CreateDomain createDomain =
        new org.openmetadata.schema.api.domains.CreateDomain()
            .withName(ns.prefix("inherit_domain"))
            .withDomainType(org.openmetadata.schema.api.domains.CreateDomain.DomainType.AGGREGATE);
    org.openmetadata.schema.entity.domains.Domain domain = client.domains().create(createDomain);

    // Create service with domain
    org.openmetadata.schema.api.services.CreateDatabaseService createService =
        new org.openmetadata.schema.api.services.CreateDatabaseService()
            .withName(ns.prefix("inherit_service"))
            .withServiceType(
                org.openmetadata.schema.api.services.CreateDatabaseService.DatabaseServiceType
                    .Postgres)
            .withDomains(List.of(domain.getFullyQualifiedName()));
    DatabaseService service = client.databaseServices().create(createService);

    // Create multiple tables
    for (int i = 0; i < 3; i++) {
      CreateTable req = createRequest(ns.prefix("inherit_table_" + i), ns, client);
      client.tables().create(req);
    }

    // List tables with pagination
    org.openmetadata.sdk.models.ListParams params =
        new org.openmetadata.sdk.models.ListParams().setLimit(2).setFields("domain");

    org.openmetadata.sdk.models.ListResponse<Table> response = client.tables().list(params);

    // Verify pagination works
    assertNotNull(response);
    assertTrue(response.getData().size() <= 2);
  }

  @Test
  void testInheritedPermissionFromParent(TestNamespace ns) {
    OpenMetadataClient adminClient = SdkClients.adminClient();

    // Create user as owner of database
    org.openmetadata.schema.entity.teams.User owner =
        UserTestFactory.createUser(adminClient, ns, "db_owner");

    // Create database with owner
    org.openmetadata.schema.api.data.CreateDatabase createDb =
        new org.openmetadata.schema.api.data.CreateDatabase()
            .withName(ns.prefix("inherit_perm_db"))
            .withService(
                DatabaseServiceTestFactory.createPostgres(adminClient, ns).getFullyQualifiedName())
            .withOwners(
                List.of(
                    new EntityReference()
                        .withId(owner.getId())
                        .withType("user")
                        .withName(owner.getName())));

    org.openmetadata.schema.entity.data.Database db = adminClient.databases().create(createDb);

    // Create schema under database
    org.openmetadata.schema.api.data.CreateDatabaseSchema createSchema =
        new org.openmetadata.schema.api.data.CreateDatabaseSchema()
            .withName(ns.prefix("inherit_perm_schema"))
            .withDatabase(db.getFullyQualifiedName());

    DatabaseSchema schema = adminClient.databaseSchemas().create(createSchema);

    // Create table under schema - should inherit ownership
    CreateTable createTable =
        new CreateTable()
            .withName(ns.prefix("inherit_perm_table"))
            .withDatabaseSchema(schema.getFullyQualifiedName())
            .withColumns(
                List.of(
                    org.openmetadata.sdk.fluent.builders.ColumnBuilder.of("id", "BIGINT")
                        .primaryKey()
                        .notNull()
                        .build()));

    Table table = adminClient.tables().create(createTable);

    // Verify table was created (inheritance is internal to OpenMetadata)
    assertNotNull(table);
    assertNotNull(table.getId());
  }

  // ===================================================================
  // CONCURRENT UPDATE TESTS
  // ===================================================================

  @Test
  void test_concurrentColumnUpdates_reproduceDataLoss(TestNamespace ns) throws Exception {
    OpenMetadataClient client = SdkClients.adminClient();

    // Create table
    CreateTable req = createRequest(ns.prefix("concurrent_table"), ns, client);
    Table table = client.tables().create(req);

    // Get base state
    Table baseState = client.tables().get(table.getId().toString(), "columns,tags");

    // Simulate concurrent updates
    java.util.concurrent.CountDownLatch startLatch = new java.util.concurrent.CountDownLatch(1);
    java.util.concurrent.CountDownLatch completionLatch =
        new java.util.concurrent.CountDownLatch(2);
    java.util.concurrent.atomic.AtomicReference<Exception> errorRef =
        new java.util.concurrent.atomic.AtomicReference<>();

    // Thread A: Update column description
    Thread threadA =
        new Thread(
            () -> {
              try {
                startLatch.await();
                Table tableA = client.tables().get(baseState.getId().toString(), "columns");
                Column col = tableA.getColumns().get(0);
                col.setDescription("Description A");
                tableA.setColumns(List.of(col, tableA.getColumns().get(1)));
                client.tables().update(tableA.getId().toString(), tableA);
              } catch (Exception e) {
                errorRef.set(e);
              } finally {
                completionLatch.countDown();
              }
            });

    // Thread B: Update column display name
    Thread threadB =
        new Thread(
            () -> {
              try {
                startLatch.await();
                Thread.sleep(50); // Small delay
                Table tableB = client.tables().get(baseState.getId().toString(), "columns");
                Column col = tableB.getColumns().get(0);
                col.setDisplayName("Display Name B");
                tableB.setColumns(List.of(col, tableB.getColumns().get(1)));
                client.tables().update(tableB.getId().toString(), tableB);
              } catch (Exception e) {
                errorRef.set(e);
              } finally {
                completionLatch.countDown();
              }
            });

    threadA.start();
    threadB.start();
    startLatch.countDown();
    completionLatch.await(10, java.util.concurrent.TimeUnit.SECONDS);

    // Verify - at least one update should succeed
    Table finalTable = client.tables().get(table.getId().toString(), "columns");
    assertNotNull(finalTable);
  }

  // ===================================================================
  // ADVANCED PAGINATION TESTS
  // ===================================================================

  @Test
  void get_TablesWithPagination_200(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    // Create 4 tables with same name but different schemas
    List<java.util.UUID> createdIds = new ArrayList<>();
    for (int i = 0; i < 4; i++) {
      // Create unique service and database for each
      org.openmetadata.schema.api.services.CreateDatabaseService createServiceReq =
          new org.openmetadata.schema.api.services.CreateDatabaseService()
              .withName(ns.prefix("service_" + i))
              .withServiceType(
                  org.openmetadata.schema.api.services.CreateDatabaseService.DatabaseServiceType
                      .Snowflake);
      DatabaseService service = client.databaseServices().create(createServiceReq);

      org.openmetadata.schema.api.data.CreateDatabase createDb =
          new org.openmetadata.schema.api.data.CreateDatabase()
              .withName(ns.prefix("db_" + i))
              .withService(service.getFullyQualifiedName());
      org.openmetadata.schema.entity.data.Database db = client.databases().create(createDb);

      org.openmetadata.schema.api.data.CreateDatabaseSchema createSchema =
          new org.openmetadata.schema.api.data.CreateDatabaseSchema()
              .withName(ns.prefix("schema_" + i))
              .withDatabase(db.getFullyQualifiedName());
      DatabaseSchema schema = client.databaseSchemas().create(createSchema);

      CreateTable req =
          new CreateTable()
              .withName("common_name")
              .withDatabaseSchema(schema.getFullyQualifiedName())
              .withColumns(
                  List.of(
                      org.openmetadata.sdk.fluent.builders.ColumnBuilder.of("id", "BIGINT")
                          .primaryKey()
                          .build()));
      Table table = client.tables().create(req);
      createdIds.add(table.getId());
    }

    // Test pagination
    org.openmetadata.sdk.models.ListParams params =
        new org.openmetadata.sdk.models.ListParams().setLimit(2);

    org.openmetadata.sdk.models.ListResponse<Table> page1 = client.tables().list(params);
    assertEquals(2, page1.getData().size());

    // Get next page
    if (page1.getPaging().getAfter() != null) {
      params.setAfter(page1.getPaging().getAfter());
      org.openmetadata.sdk.models.ListResponse<Table> page2 = client.tables().list(params);
      assertTrue(page2.getData().size() >= 0);
    }
  }

  @Test
  void get_tableListWithDifferentFields_200_OK(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    // Create user as owner
    org.openmetadata.schema.entity.teams.User owner =
        UserTestFactory.createUser(client, ns, "field_owner");

    // Create classification and tag
    CreateClassification createClassification =
        new CreateClassification()
            .withName(ns.prefix("field_classification"))
            .withDescription("Field test classification");
    Classification classification = client.classifications().create(createClassification);

    CreateTag createTag =
        new CreateTag()
            .withName(ns.prefix("field_tag"))
            .withClassification(classification.getName());
    Tag tag = client.tags().create(createTag);

    // Create table with owner and tags
    TagLabel tableTag =
        new TagLabel()
            .withTagFQN(tag.getFullyQualifiedName())
            .withSource(TagLabel.TagSource.CLASSIFICATION);

    CreateTable req = createRequest(ns.prefix("field_table"), ns, client);
    req.setOwners(
        List.of(
            new EntityReference()
                .withId(owner.getId())
                .withType("user")
                .withName(owner.getName())));
    req.setTags(List.of(tableTag));

    client.tables().create(req);

    // List with different fields
    org.openmetadata.sdk.models.ListParams paramsWithOwners =
        new org.openmetadata.sdk.models.ListParams().setLimit(10).setFields("owners");
    org.openmetadata.sdk.models.ListResponse<Table> withOwners =
        client.tables().list(paramsWithOwners);
    assertNotNull(withOwners);

    org.openmetadata.sdk.models.ListParams paramsWithTags =
        new org.openmetadata.sdk.models.ListParams().setLimit(10).setFields("tags");
    org.openmetadata.sdk.models.ListResponse<Table> withTags = client.tables().list(paramsWithTags);
    assertNotNull(withTags);
  }

  @Test
  void get_tablesWithTestCases(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    // Create table
    CreateTable req = createRequest(ns.prefix("testcase_table"), ns, client);
    Table table = client.tables().create(req);

    // Create test suite
    CreateTestSuite createTestSuite =
        new CreateTestSuite()
            .withName(ns.prefix("test_suite"))
            .withExecutableEntityReference(table.getFullyQualifiedName());
    client.testSuites().create(createTestSuite);

    // Create test case
    CreateTestCase createTestCase =
        new CreateTestCase()
            .withName(ns.prefix("test_case"))
            .withEntityLink(
                "<#E::table::"
                    + table.getFullyQualifiedName()
                    + "::columns::"
                    + table.getColumns().get(0).getName()
                    + ">");
    client.testCases().create(createTestCase);

    // List tables (test cases linked via entity link)
    org.openmetadata.sdk.models.ListParams params =
        new org.openmetadata.sdk.models.ListParams().setLimit(10);
    org.openmetadata.sdk.models.ListResponse<Table> response = client.tables().list(params);
    assertNotNull(response);
  }

  @Test
  void test_listTablesWithTestSuite(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    // Create multiple tables with test suites
    for (int i = 0; i < 2; i++) {
      CreateTable req = createRequest(ns.prefix("suite_table_" + i), ns, client);
      Table table = client.tables().create(req);

      CreateTestSuite createTestSuite =
          new CreateTestSuite()
              .withName(ns.prefix("suite_" + i))
              .withExecutableEntityReference(table.getFullyQualifiedName());
      client.testSuites().create(createTestSuite);
    }

    // List tables
    org.openmetadata.sdk.models.ListParams params =
        new org.openmetadata.sdk.models.ListParams().setLimit(10);
    org.openmetadata.sdk.models.ListResponse<Table> response = client.tables().list(params);
    assertTrue(response.getData().size() >= 2);
  }

  // ===================================================================
  // ADDITIONAL TAG TESTS
  // ===================================================================

  @Test
  void test_columnWithMultipleTags_withClassificationReason(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    // Create two classifications
    CreateClassification classification1 =
        new CreateClassification()
            .withName(ns.prefix("classification1"))
            .withDescription("First classification");
    Classification c1 = client.classifications().create(classification1);

    CreateClassification classification2 =
        new CreateClassification()
            .withName(ns.prefix("classification2"))
            .withDescription("Second classification");
    Classification c2 = client.classifications().create(classification2);

    // Create tags under each classification
    CreateTag tag1 = new CreateTag().withName(ns.prefix("tag1")).withClassification(c1.getName());
    Tag t1 = client.tags().create(tag1);

    CreateTag tag2 = new CreateTag().withName(ns.prefix("tag2")).withClassification(c2.getName());
    Tag t2 = client.tags().create(tag2);

    // Create table
    CreateTable req = createRequest(ns.prefix("multi_tag_table"), ns, client);
    Table table = client.tables().create(req);

    // Add multiple tags to column
    Column column = table.getColumns().get(0);
    TagLabel tagLabel1 =
        new TagLabel()
            .withTagFQN(t1.getFullyQualifiedName())
            .withSource(TagLabel.TagSource.CLASSIFICATION);
    TagLabel tagLabel2 =
        new TagLabel()
            .withTagFQN(t2.getFullyQualifiedName())
            .withSource(TagLabel.TagSource.CLASSIFICATION);

    column.setTags(List.of(tagLabel1, tagLabel2));
    table.setColumns(Arrays.asList(column, table.getColumns().get(1)));

    Table updated = client.tables().update(table.getId().toString(), table);

    // Verify both tags
    assertEquals(2, updated.getColumns().get(0).getTags().size());
  }

  @Test
  void test_mutuallyExclusiveTags(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    // Create classification with mutually exclusive tags
    CreateClassification createClassification =
        new CreateClassification()
            .withName(ns.prefix("exclusive_classification"))
            .withMutuallyExclusive(true);
    Classification classification = client.classifications().create(createClassification);

    // Create two tags
    CreateTag tag1 =
        new CreateTag()
            .withName(ns.prefix("exclusive_tag1"))
            .withClassification(classification.getName());
    Tag t1 = client.tags().create(tag1);

    CreateTag tag2 =
        new CreateTag()
            .withName(ns.prefix("exclusive_tag2"))
            .withClassification(classification.getName());
    Tag t2 = client.tags().create(tag2);

    // Create table
    CreateTable req = createRequest(ns.prefix("exclusive_table"), ns, client);
    Table table = client.tables().create(req);

    // Add first tag
    Column column = table.getColumns().get(0);
    TagLabel tagLabel1 =
        new TagLabel()
            .withTagFQN(t1.getFullyQualifiedName())
            .withSource(TagLabel.TagSource.CLASSIFICATION);
    column.setTags(List.of(tagLabel1));
    table.setColumns(Arrays.asList(column, table.getColumns().get(1)));
    Table updated1 = client.tables().update(table.getId().toString(), table);

    // Try to add second mutually exclusive tag - should either fail or replace
    try {
      Table fetched = client.tables().get(updated1.getId().toString(), "columns");
      Column col = fetched.getColumns().get(0);
      TagLabel tagLabel2 =
          new TagLabel()
              .withTagFQN(t2.getFullyQualifiedName())
              .withSource(TagLabel.TagSource.CLASSIFICATION);
      col.setTags(List.of(tagLabel1, tagLabel2)); // Both tags
      fetched.setColumns(Arrays.asList(col, fetched.getColumns().get(1)));
      client.tables().update(fetched.getId().toString(), fetched);
      // If it succeeds, mutually exclusive constraint not enforced or tags replaced
    } catch (Exception e) {
      // Expected if mutually exclusive is enforced
      assertTrue(
          e.getMessage().contains("mutually exclusive") || e.getMessage().contains("exclusive"));
    }
  }

  // ===================================================================
  // DATA MODEL TEST
  // ===================================================================

  @Test
  void put_tableDataModel(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    CreateTable req = createRequest(ns.prefix("datamodel_table"), ns, client);
    Table table = client.tables().create(req);

    // Add data model
    org.openmetadata.schema.type.DataModel dataModel =
        new org.openmetadata.schema.type.DataModel()
            .withDescription("Test data model")
            .withModelType(org.openmetadata.schema.type.DataModel.ModelType.DBT);

    table.setDataModel(dataModel);
    Table updated = client.tables().update(table.getId().toString(), table);

    assertNotNull(updated.getDataModel());
    assertEquals("Test data model", updated.getDataModel().getDescription());
  }

  // ===================================================================
  // SEARCH/ELASTICSEARCH TESTS
  // ===================================================================

  @Test
  void get_entityWithoutDescriptionFromSearch(TestNamespace ns) throws Exception {
    OpenMetadataClient client = SdkClients.adminClient();

    // Create tables with and without descriptions
    CreateTable withNullDesc = createRequest(ns.prefix("null_desc_table"), ns, client);
    withNullDesc.setDescription(null);
    List<Column> cols1 = new ArrayList<>(withNullDesc.getColumns());
    cols1.get(0).setDescription(null);
    withNullDesc.setColumns(cols1);
    Table tableNullDesc = client.tables().create(withNullDesc);

    CreateTable withEmptyDesc = createRequest(ns.prefix("empty_desc_table"), ns, client);
    withEmptyDesc.setDescription("");
    List<Column> cols2 = new ArrayList<>(withEmptyDesc.getColumns());
    cols2.get(0).setDescription("");
    withEmptyDesc.setColumns(cols2);
    Table tableEmptyDesc = client.tables().create(withEmptyDesc);

    CreateTable withDesc = createRequest(ns.prefix("with_desc_table"), ns, client);
    withDesc.setDescription("FooBar description");
    List<Column> cols3 = new ArrayList<>(withDesc.getColumns());
    cols3.get(0).setDescription("Column description");
    withDesc.setColumns(cols3);
    Table tableWithDesc = client.tables().create(withDesc);

    // Wait for indexing (Elasticsearch needs time to index)
    Thread.sleep(2000);

    // Search using REST client to Elasticsearch directly
    try (es.org.elasticsearch.client.RestClient searchClient =
        org.openmetadata.it.env.TestSuiteBootstrap.createSearchClient()) {

      // Create search request for tables with missing descriptions
      String searchQuery =
          "{"
              + "  \"query\": {"
              + "    \"bool\": {"
              + "      \"must\": ["
              + "        { \"term\": { \"entityType\": \"table\" } },"
              + "        { \"bool\": {"
              + "            \"should\": ["
              + "              { \"bool\": { \"must_not\": { \"exists\": { \"field\": \"description\" } } } },"
              + "              { \"term\": { \"description\": \"\" } }"
              + "            ]"
              + "          }"
              + "        }"
              + "      ]"
              + "    }"
              + "  }"
              + "}";

      es.org.elasticsearch.client.Request request =
          new es.org.elasticsearch.client.Request("POST", "/table_search_index/_search");
      request.setJsonEntity(searchQuery);

      es.org.elasticsearch.client.Response response = searchClient.performRequest(request);

      // Verify response
      assertEquals(200, response.getStatusLine().getStatusCode());

      // Parse response to check tables without descriptions were found
      String responseBody =
          new String(
              response.getEntity().getContent().readAllBytes(),
              java.nio.charset.StandardCharsets.UTF_8);
      assertTrue(responseBody.contains("hits"));
    }
  }

  @Test
  void test_searchTableColumns_comprehensive(TestNamespace ns) throws Exception {
    OpenMetadataClient client = SdkClients.adminClient();

    // Create table with searchable column names and descriptions
    CreateTable req = createRequest(ns.prefix("searchable_table"), ns, client);

    List<Column> columns = new ArrayList<>();
    columns.add(
        org.openmetadata.sdk.fluent.builders.ColumnBuilder.of("customer_id", "BIGINT")
            .description("Unique customer identifier")
            .primaryKey()
            .build());
    columns.add(
        org.openmetadata.sdk.fluent.builders.ColumnBuilder.of("email_address", "VARCHAR")
            .description("Customer email for communication")
            .build());
    columns.add(
        org.openmetadata.sdk.fluent.builders.ColumnBuilder.of("purchase_amount", "DECIMAL")
            .description("Total purchase amount in USD")
            .build());

    req.setColumns(columns);
    req.setDescription("Customer transaction data with email and purchase information");

    Table table = client.tables().create(req);

    // Wait for indexing
    Thread.sleep(2000);

    // Search for tables containing "email" in columns
    try (es.org.elasticsearch.client.RestClient searchClient =
        org.openmetadata.it.env.TestSuiteBootstrap.createSearchClient()) {

      String searchQuery =
          "{"
              + "  \"query\": {"
              + "    \"bool\": {"
              + "      \"must\": ["
              + "        { \"term\": { \"entityType\": \"table\" } },"
              + "        { \"multi_match\": {"
              + "            \"query\": \"email\","
              + "            \"fields\": [\"columns.name\", \"columns.description\"]"
              + "          }"
              + "        }"
              + "      ]"
              + "    }"
              + "  }"
              + "}";

      es.org.elasticsearch.client.Request request =
          new es.org.elasticsearch.client.Request("POST", "/table_search_index/_search");
      request.setJsonEntity(searchQuery);

      es.org.elasticsearch.client.Response response = searchClient.performRequest(request);

      assertEquals(200, response.getStatusLine().getStatusCode());

      String responseBody =
          new String(
              response.getEntity().getContent().readAllBytes(),
              java.nio.charset.StandardCharsets.UTF_8);

      // Verify our table is in the results
      assertTrue(responseBody.contains(table.getName()) || responseBody.contains("email"));
    }
  }

  // ===================================================================
  // PHASE 3: List Operations Support
  // ===================================================================

  @Override
  protected org.openmetadata.sdk.models.ListResponse<Table> listEntities(
      org.openmetadata.sdk.models.ListParams params, OpenMetadataClient client) {
    return client.tables().list(params);
  }

  @Override
  protected Table getEntityWithFields(String id, String fields, OpenMetadataClient client) {
    return client.tables().get(id, fields);
  }

  @Override
  protected Table getEntityByNameWithFields(String fqn, String fields, OpenMetadataClient client) {
    return client.tables().getByName(fqn, fields);
  }

  @Override
  protected Table getEntityIncludeDeleted(String id, OpenMetadataClient client) {
    return client.tables().get(id, "owners,tags,columns", "deleted");
  }
}
